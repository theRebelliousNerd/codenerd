# Cortex 1.5.0 Schemas (EDB Declarations)
# Version: 1.5.0
# Philosophy: Logic determines Reality; the Model merely describes it.

# =============================================================================
# SECTION 1: INTENT SCHEMA (§1.1)
# =============================================================================

# user_intent(ID, Category, Verb, Target, Constraint)
# Category: /query, /mutation, /instruction
# Verb: /explain, /refactor, /debug, /generate, /scaffold, /init, /test, /review, /fix, /run, /research, /explore, /implement
Decl user_intent(ID, Category, Verb, Target, Constraint).

# =============================================================================
# SECTION 2: FOCUS RESOLUTION (§1.2)
# =============================================================================

# focus_resolution(RawReference, ResolvedPath, SymbolName, Confidence)
Decl focus_resolution(RawReference, ResolvedPath, SymbolName, Confidence).

# ambiguity_flag(MissingParam, ContextClue, Hypothesis)
Decl ambiguity_flag(MissingParam, ContextClue, Hypothesis).

# =============================================================================
# SECTION 3: FILE TOPOLOGY (§2.1)
# =============================================================================

# file_topology(Path, Hash, Language, LastModified, IsTestFile)
# Language: /go, /python, /ts, /rust, /java, /js
# IsTestFile: /true, /false
Decl file_topology(Path, Hash, Language, LastModified, IsTestFile).

# modified(FilePath) - marks a file as modified
Decl modified(FilePath).

# test_coverage(FilePath) - marks a file as having test coverage
Decl test_coverage(FilePath).

# =============================================================================
# SECTION 4: SYMBOL GRAPH / AST PROJECTION (§2.3)
# =============================================================================

# symbol_graph(SymbolID, Type, Visibility, DefinedAt, Signature)
# Type: /function, /class, /interface, /struct, /variable, /constant
# Visibility: /public, /private, /protected
Decl symbol_graph(SymbolID, Type, Visibility, DefinedAt, Signature).

# dependency_link(CallerID, CalleeID, ImportPath)
Decl dependency_link(CallerID, CalleeID, ImportPath).

# =============================================================================
# SECTION 5: DIAGNOSTICS / LINTER-LOGIC BRIDGE (§2.2)
# =============================================================================

# diagnostic(Severity, FilePath, Line, ErrorCode, Message)
# Severity: /panic, /error, /warning, /info
Decl diagnostic(Severity, FilePath, Line, ErrorCode, Message).

# =============================================================================
# SECTION 6: SHARD DELEGATION (§7.0)
# =============================================================================

# delegate_task(ShardType, TaskDescription, Status)
# ShardType: /researcher, /coder, /reviewer, /tester, /generalist, /specialist
# Status: /pending, /in_progress, /completed, /failed
Decl delegate_task(ShardType, TaskDescription, Status).

# shard_profile(AgentName, Type, KnowledgePath)
Decl shard_profile(AgentName, Type, KnowledgePath).

# =============================================================================
# SECTION 7: MEMORY SHARDS (§7.1-7.4)
# =============================================================================

# vector_recall(Query, Content, Score)
Decl vector_recall(Query, Content, Score).

# knowledge_link(EntityA, Relation, EntityB)
Decl knowledge_link(EntityA, Relation, EntityB).

# new_fact(FactID) - marks a fact as newly added (for activation)
Decl new_fact(FactID).

# =============================================================================
# SECTION 8: BROWSER PHYSICS (§9.0)
# =============================================================================

# dom_node(ID, Tag, Parent)
Decl dom_node(ID, Tag, Parent).

# attr(ID, Key, Val)
Decl attr(ID, Key, Val).

# geometry(ID, X, Y, W, H)
Decl geometry(ID, X, Y, W, H).

# computed_style(ID, Prop, Val)
Decl computed_style(ID, Prop, Val).

# interactable(ID, Type)
# Type: /button, /input, /link, /select, /checkbox
Decl interactable(ID, Type).

# visible_text(ID, Text)
Decl visible_text(ID, Text).

# =============================================================================
# SECTION 9: TDD REPAIR LOOP STATE (§3.2)
# =============================================================================

# test_state(State)
# State: /failing, /log_read, /cause_found, /patch_applied, /passing, /unknown
Decl test_state(State).

# retry_count(Count)
Decl retry_count(Count).

# =============================================================================
# SECTION 10: ACTION & EXECUTION (§4.0)
# =============================================================================

# next_action(ActionType)
# ActionType: /read_error_log, /analyze_root_cause, /generate_patch, /run_tests,
#             /escalate_to_user, /complete, /interrogative_mode
Decl next_action(ActionType).

# action_details(ActionType, Payload)
Decl action_details(ActionType, Payload).

# safe_action(ActionType)
Decl safe_action(ActionType).

# =============================================================================
# SECTION 11: CONSTITUTIONAL LOGIC / SAFETY (§5.0)
# =============================================================================

# permitted(ActionType) - derived predicate
Decl permitted(ActionType).

# dangerous_action(ActionType) - derived predicate
Decl dangerous_action(ActionType).

# admin_override(User)
Decl admin_override(User).

# signed_approval(ActionType)
Decl signed_approval(ActionType).

# allowed_domain(Domain) - network allowlist
Decl allowed_domain(Domain).

# network_permitted(URL) - derived predicate
Decl network_permitted(URL).

# security_violation(ViolationType) - derived predicate
Decl security_violation(ViolationType).

# =============================================================================
# SECTION 12: SPREADING ACTIVATION (§8.1)
# =============================================================================

# activation(Fact, Score)
Decl activation(Fact, Score).

# active_goal(Goal)
Decl active_goal(Goal).

# tool_capabilities(Tool, Cap)
# Tool: /fs_read, /fs_write, /exec_cmd, /browser, /code_graph
# Cap: /read, /write, /execute, /navigate, /click, /type, /analyze, /dependencies
Decl tool_capabilities(Tool, Cap).

# has_capability(Cap) - helper for safe negation in missing tool detection
Decl has_capability(Cap).

# goal_requires(Goal, Cap)
Decl goal_requires(Goal, Cap).

# context_atom(Fact) - derived predicate
Decl context_atom(Fact).

# =============================================================================
# SECTION 13: STRATEGY SELECTION (§3.1)
# =============================================================================

# active_strategy(Strategy)
# Strategy: /tdd_repair_loop, /breadth_first_survey, /project_init, /refactor_guard
Decl active_strategy(Strategy).

# target_is_large(Target) - true if target references multiple files/features (Go builtin)
Decl target_is_large(Target).

# target_is_complex(Target) - true if target requires multiple phases (Go builtin)
Decl target_is_complex(Target).

# =============================================================================
# SECTION 14: IMPACT ANALYSIS (§3.3)
# =============================================================================

# impacted(FilePath) - derived predicate
Decl impacted(FilePath).

# unsafe_to_refactor(Target) - derived predicate
Decl unsafe_to_refactor(Target).

# block_refactor(Target, Reason) - derived predicate
Decl block_refactor(Target, Reason).

# block_commit(Reason) - derived predicate
Decl block_commit(Reason).

# =============================================================================
# SECTION 15: ABDUCTIVE REASONING (§8.2)
# =============================================================================

# missing_hypothesis(RootCause)
Decl missing_hypothesis(RootCause).

# clarification_needed(Ref) - derived predicate
Decl clarification_needed(Ref).

# ambiguity_detected(Param) - derived predicate
Decl ambiguity_detected(Param).

# symptom(Context, SymptomType)
Decl symptom(Context, SymptomType).

# known_cause(SymptomType, Cause)
Decl known_cause(SymptomType, Cause).

# has_known_cause(SymptomType) - helper for safe negation
Decl has_known_cause(SymptomType).

# =============================================================================
# SECTION 16: AUTOPOIESIS / LEARNING (§8.3)
# =============================================================================

# rejection_count(Pattern, Count)
Decl rejection_count(Pattern, Count).

# preference_signal(Pattern) - derived predicate
Decl preference_signal(Pattern).

# derived_rule(Pattern, FactType, FactValue) - maps rejection patterns to facts for promotion
Decl derived_rule(Pattern, FactType, FactValue).

# promote_to_long_term(FactType, FactValue) - derived predicate for Autopoiesis (§8.3)
# FactType is a name constant (e.g., /style_preference, /avoid_pattern)
# FactValue is the specific value to learn
Decl promote_to_long_term(FactType, FactValue).

# =============================================================================
# SECTION 17: BROWSER SPATIAL REASONING (§9.0)
# =============================================================================

# left_of(A, B) - derived predicate
Decl left_of(A, B).

# above(A, B) - derived predicate
Decl above(A, B).

# honeypot_detected(ID) - derived predicate
Decl honeypot_detected(ID).

# safe_interactable(ID) - derived predicate
Decl safe_interactable(ID).

# target_checkbox(CheckID, LabelText) - derived predicate
Decl target_checkbox(CheckID, LabelText).

# =============================================================================
# SECTION 18: PROJECT PROFILE (nerd init)
# =============================================================================

# project_profile(ProjectID, Name, Description)
Decl project_profile(ProjectID, Name, Description).

# project_language(Language)
# Language: /go, /rust, /python, /javascript, /typescript, /java, etc.
Decl project_language(Language).

# project_framework(Framework)
# Framework: /gin, /echo, /nextjs, /react, /django, etc.
Decl project_framework(Framework).

# project_architecture(Architecture)
# Architecture: /monolith, /microservices, /clean_architecture, /serverless
Decl project_architecture(Architecture).

# build_system(BuildSystem)
# BuildSystem: /go, /npm, /cargo, /pip, /maven, /gradle
Decl build_system(BuildSystem).

# architectural_pattern(Pattern)
# Pattern: /standard_go_layout, /repository_pattern, /service_layer, /domain_driven
Decl architectural_pattern(Pattern).

# entry_point(FilePath)
Decl entry_point(FilePath).

# =============================================================================
# SECTION 19: USER PREFERENCES (Autopoiesis / Learning)
# =============================================================================

# user_preference(Key, Value)
# Keys: /test_style, /error_handling, /commit_style, /verbosity, /explanation_level
Decl user_preference(Key, Value).

# preference_learned(Key, Value, Timestamp, Confidence)
Decl preference_learned(Key, Value, Timestamp, Confidence).

# =============================================================================
# SECTION 20: SESSION STATE (Pause/Resume Protocol)
# =============================================================================

# session_state(SessionID, State, SerializedContext)
# State: /active, /suspended, /completed
Decl session_state(SessionID, State, SerializedContext).

# pending_clarification(Question, Options, DefaultValue)
Decl pending_clarification(Question, Options, DefaultValue).

# focus_clarification(Response) - user's clarification response
Decl focus_clarification(Response).

# turn_context(TurnNumber, IntentID, ActionsTaken)
Decl turn_context(TurnNumber, IntentID, ActionsTaken).

# =============================================================================
# SECTION 21: GIT-AWARE SAFETY (Chesterton's Fence)
# =============================================================================

# git_history(FilePath, CommitHash, Author, AgeDays, Message)
Decl git_history(FilePath, CommitHash, Author, AgeDays, Message).

# churn_rate(FilePath, ChangeFrequency)
Decl churn_rate(FilePath, ChangeFrequency).

# current_user(UserName)
Decl current_user(UserName).

# current_time(Timestamp) - current system time for learning timestamps
Decl current_time(Timestamp).

# recent_change_by_other(FilePath) - derived predicate
# True if file was changed < 2 days ago by a different author
Decl recent_change_by_other(FilePath).

# chesterton_fence_warning(FilePath, Reason) - derived predicate
# Warns before deleting recently-changed code
Decl chesterton_fence_warning(FilePath, Reason).

# =============================================================================
# SECTION 22: SHADOW MODE / COUNTERFACTUAL REASONING
# =============================================================================

# shadow_state(StateID, ActionID, IsValid)
Decl shadow_state(StateID, ActionID, IsValid).

# simulated_effect(ActionID, FactPredicate, FactArgs)
Decl simulated_effect(ActionID, FactPredicate, FactArgs).

# safe_projection(ActionID) - derived predicate
# True if the action passes safety checks in shadow simulation
Decl safe_projection(ActionID).

# projection_violation(ActionID, ViolationType) - derived predicate
Decl projection_violation(ActionID, ViolationType).

# =============================================================================
# SECTION 23: INTERACTIVE DIFF APPROVAL
# =============================================================================

# pending_mutation(MutationID, FilePath, OldContent, NewContent)
Decl pending_mutation(MutationID, FilePath, OldContent, NewContent).

# mutation_approved(MutationID, ApprovedBy, Timestamp)
Decl mutation_approved(MutationID, ApprovedBy, Timestamp).

# mutation_rejected(MutationID, RejectedBy, Reason)
Decl mutation_rejected(MutationID, RejectedBy, Reason).

# requires_approval(MutationID) - derived predicate
# True if the mutation requires user approval before execution
Decl requires_approval(MutationID).

# =============================================================================
# SECTION 24: KNOWLEDGE ATOMS (Research Results)
# =============================================================================

# knowledge_atom(SourceURL, Concept, Title, Confidence)
Decl knowledge_atom(SourceURL, Concept, Title, Confidence).

# code_pattern(Concept, PatternCode)
Decl code_pattern(Concept, PatternCode).

# anti_pattern(Concept, PatternCode, Reason)
Decl anti_pattern(Concept, PatternCode, Reason).

# research_complete(Query, AtomCount, DurationSeconds)
Decl research_complete(Query, AtomCount, DurationSeconds).

# =============================================================================
# SECTION 25: LSP INTEGRATION (Language Server Protocol)
# =============================================================================

# lsp_definition(Symbol, FilePath, Line, Column)
Decl lsp_definition(Symbol, FilePath, Line, Column).

# lsp_reference(Symbol, RefFile, RefLine)
Decl lsp_reference(Symbol, RefFile, RefLine).

# lsp_hover(Symbol, Documentation)
Decl lsp_hover(Symbol, Documentation).

# lsp_diagnostic(FilePath, Line, Severity, Message)
Decl lsp_diagnostic(FilePath, Line, Severity, Message).

# =============================================================================
# SECTION 26: DERIVATION TRACE (Glass Box Interface)
# =============================================================================

# derivation_trace(Conclusion, RuleApplied, Premises)
Decl derivation_trace(Conclusion, RuleApplied, Premises).

# proof_tree_node(NodeID, ParentID, Fact, RuleName)
Decl proof_tree_node(NodeID, ParentID, Fact, RuleName).

# =============================================================================
# SECTION 27: CAMPAIGN ORCHESTRATION (Long-Running Goal Execution)
# =============================================================================
# Campaigns are long-running, multi-phase goals that can span sessions.
# Examples: greenfield builds, large features, stability audits, migrations

# -----------------------------------------------------------------------------
# 27.1 Campaign Identity
# -----------------------------------------------------------------------------

# campaign(CampaignID, Type, Title, SourceMaterial, Status)
# Type: /greenfield, /feature, /audit, /migration, /remediation, /custom
# Status: /planning, /decomposing, /validating, /active, /paused, /completed, /failed
Decl campaign(CampaignID, Type, Title, SourceMaterial, Status).

# campaign_metadata(CampaignID, CreatedAt, EstimatedPhases, Confidence)
# Confidence: LLM's confidence in the plan (0.0-1.0)
Decl campaign_metadata(CampaignID, CreatedAt, EstimatedPhases, Confidence).

# campaign_goal(CampaignID, GoalDescription)
# The high-level goal in natural language
Decl campaign_goal(CampaignID, GoalDescription).

# -----------------------------------------------------------------------------
# 27.2 Phase Decomposition (LLM + Mangle Collaboration)
# -----------------------------------------------------------------------------

# campaign_phase(PhaseID, CampaignID, Name, Order, Status, ContextProfile)
# Status: /pending, /in_progress, /completed, /failed, /skipped
# ContextProfile: ID referencing what context this phase needs
Decl campaign_phase(PhaseID, CampaignID, Name, Order, Status, ContextProfile).

# phase_objective(PhaseID, ObjectiveType, Description, VerificationMethod)
# ObjectiveType: /create, /modify, /test, /research, /validate, /integrate, /review
# VerificationMethod: /tests_pass, /builds, /manual_review, /shard_validation, /none
Decl phase_objective(PhaseID, ObjectiveType, Description, VerificationMethod).

# phase_dependency(PhaseID, DependsOnPhaseID, DependencyType)
# DependencyType: /hard (must complete), /soft (preferred), /artifact (needs output)
Decl phase_dependency(PhaseID, DependsOnPhaseID, DependencyType).

# phase_estimate(PhaseID, EstimatedTasks, EstimatedComplexity)
# EstimatedComplexity: /low, /medium, /high, /critical
Decl phase_estimate(PhaseID, EstimatedTasks, EstimatedComplexity).

# -----------------------------------------------------------------------------
# 27.3 Task Granularity (Atomic Work Units)
# -----------------------------------------------------------------------------

# campaign_task(TaskID, PhaseID, Description, Status, TaskType)
# TaskType: /file_create, /file_modify, /test_write, /test_run, /research,
#           /shard_spawn, /tool_create, /verify, /document, /refactor, /integrate
# Status: /pending, /in_progress, /completed, /failed, /skipped, /blocked
Decl campaign_task(TaskID, PhaseID, Description, Status, TaskType).

# task_priority(TaskID, Priority)
# Priority: /critical, /high, /normal, /low
Decl task_priority(TaskID, Priority).

# task_dependency(TaskID, DependsOnTaskID)
Decl task_dependency(TaskID, DependsOnTaskID).

# task_artifact(TaskID, ArtifactType, Path, Hash)
# ArtifactType: /source_file, /test_file, /config, /shard_agent, /knowledge_base, /doc
Decl task_artifact(TaskID, ArtifactType, Path, Hash).

# task_inference(TaskID, InferredFrom, Confidence, Reasoning)
# Tracks WHERE this task came from (spec section, user intent, LLM inference)
Decl task_inference(TaskID, InferredFrom, Confidence, Reasoning).

# task_attempt(TaskID, AttemptNumber, Outcome, Timestamp)
# Outcome: /success, /failure, /partial
Decl task_attempt(TaskID, AttemptNumber, Outcome, Timestamp).

# task_error(TaskID, ErrorType, ErrorMessage)
Decl task_error(TaskID, ErrorType, ErrorMessage).

# -----------------------------------------------------------------------------
# 27.4 Context Profiles (Phase-Aware Context Paging)
# -----------------------------------------------------------------------------

# context_profile(ProfileID, RequiredSchemas, RequiredTools, FocusPatterns)
# RequiredSchemas: comma-separated schema sections (e.g., "file_topology,symbol_graph")
# RequiredTools: comma-separated tools (e.g., "fs_read,fs_write,exec_cmd")
# FocusPatterns: glob patterns for files to activate (e.g., "internal/core/*")
Decl context_profile(ProfileID, RequiredSchemas, RequiredTools, FocusPatterns).

# tool_in_list(Tool, ToolList) - helper predicate to check if tool is in comma-separated list
Decl tool_in_list(Tool, ToolList).

# phase_context_atom(PhaseID, FactPredicate, ActivationBoost)
# Specific facts that should be boosted for this phase
Decl phase_context_atom(PhaseID, FactPredicate, ActivationBoost).

# context_compression(PhaseID, CompressedSummary, OriginalAtomCount, Timestamp)
# When a phase completes, its verbose context is compressed to a summary
Decl context_compression(PhaseID, CompressedSummary, OriginalAtomCount, Timestamp).

# context_window_state(CampaignID, UsedTokens, TotalBudget, Utilization)
Decl context_window_state(CampaignID, UsedTokens, TotalBudget, Utilization).

# -----------------------------------------------------------------------------
# 27.5 Progress & Verification
# -----------------------------------------------------------------------------

# campaign_progress(CampaignID, CompletedPhases, TotalPhases, CompletedTasks, TotalTasks)
Decl campaign_progress(CampaignID, CompletedPhases, TotalPhases, CompletedTasks, TotalTasks).

# phase_checkpoint(PhaseID, CheckpointType, Passed, Details, Timestamp)
# CheckpointType: /tests, /build, /lint, /coverage, /manual, /integration
Decl phase_checkpoint(PhaseID, CheckpointType, Passed, Details, Timestamp).

# campaign_milestone(CampaignID, MilestoneID, Description, ReachedAt)
Decl campaign_milestone(CampaignID, MilestoneID, Description, ReachedAt).

# campaign_learning(CampaignID, LearningType, Pattern, Fact, AppliedAt)
# Tracks what the system learned during execution (autopoiesis)
# LearningType: /success_pattern, /failure_pattern, /preference, /optimization
Decl campaign_learning(CampaignID, LearningType, Pattern, Fact, AppliedAt).

# -----------------------------------------------------------------------------
# 27.6 Replanning & Adaptation
# -----------------------------------------------------------------------------

# replan_trigger(CampaignID, Reason, TriggeredAt)
# Reason: /task_failed, /new_requirement, /user_feedback, /dependency_change, /blocked
Decl replan_trigger(CampaignID, Reason, TriggeredAt).

# plan_revision(CampaignID, RevisionNumber, ChangeSummary, Timestamp)
Decl plan_revision(CampaignID, RevisionNumber, ChangeSummary, Timestamp).

# plan_validation_issue(CampaignID, IssueType, Description)
# IssueType: /missing_dependency, /circular_dependency, /unreachable_task, /ambiguous_goal
Decl plan_validation_issue(CampaignID, IssueType, Description).

# -----------------------------------------------------------------------------
# 27.7 Campaign Shard Delegation
# -----------------------------------------------------------------------------

# campaign_shard(CampaignID, ShardID, ShardType, Task, Status)
# Tracks shards spawned as part of campaign execution
Decl campaign_shard(CampaignID, ShardID, ShardType, Task, Status).

# shard_result(ShardID, ResultType, ResultData, Timestamp)
# ResultType: /success, /failure, /partial, /knowledge
Decl shard_result(ShardID, ResultType, ResultData, Timestamp).

# -----------------------------------------------------------------------------
# 27.8 Source Material Ingestion
# -----------------------------------------------------------------------------

# source_document(CampaignID, DocPath, DocType, ParsedAt)
# DocType: /spec, /requirements, /design, /readme, /api_doc, /tutorial
Decl source_document(CampaignID, DocPath, DocType, ParsedAt).

# source_requirement(CampaignID, ReqID, Description, Priority, Source)
# Requirements extracted from source documents
Decl source_requirement(CampaignID, ReqID, Description, Priority, Source).

# requirement_coverage(ReqID, TaskID)
# Maps requirements to tasks that fulfill them
Decl requirement_coverage(ReqID, TaskID).

# -----------------------------------------------------------------------------
# 27.9 Campaign Derived Predicates (Helpers)
# -----------------------------------------------------------------------------

# current_campaign(CampaignID) - derived: the active campaign
Decl current_campaign(CampaignID).

# current_phase(PhaseID) - derived: the current phase being executed
Decl current_phase(PhaseID).

# next_campaign_task(TaskID) - derived: the next task to execute
Decl next_campaign_task(TaskID).

# phase_eligible(PhaseID) - derived: phase ready to start
Decl phase_eligible(PhaseID).

# phase_blocked(PhaseID, Reason) - derived: phase cannot proceed
Decl phase_blocked(PhaseID, Reason).

# campaign_blocked(CampaignID, Reason) - derived: campaign cannot proceed
Decl campaign_blocked(CampaignID, Reason).

# replan_needed(CampaignID, Reason) - derived: campaign needs replanning
Decl replan_needed(CampaignID, Reason).

# =============================================================================
# SECTION 28: OUROBOROS / TOOL SELF-GENERATION (§8.3)
# =============================================================================
# Tool registry and lifecycle for self-generating tools

# tool_registered(ToolName, RegisteredAt) - tracks registered tools
Decl tool_registered(ToolName, RegisteredAt).

# tool_exists(ToolName) - derived: tool is in registry
Decl tool_exists(ToolName).

# tool_ready(ToolName) - derived: tool is compiled and ready
Decl tool_ready(ToolName).

# tool_hash(ToolName, Hash) - content hash for change detection
Decl tool_hash(ToolName, Hash).

# tool_capability(ToolName, Capability) - capabilities provided by a tool
Decl tool_capability(ToolName, Capability).

# capability_available(Capability) - derived: capability exists
Decl capability_available(Capability).

# Tool generation lifecycle
# tool_source_ready(ToolName) - source code has been generated
Decl tool_source_ready(ToolName).

# tool_safety_verified(ToolName) - passed safety checks
Decl tool_safety_verified(ToolName).

# tool_compiled(ToolName) - successfully compiled
Decl tool_compiled(ToolName).

# generation_state(ToolName, State) - current generation state
# State: /pending, /in_progress, /completed, /failed
Decl generation_state(ToolName, State).

# has_active_generation - helper for safe negation (true if any generation in progress)
Decl has_active_generation().

# is_tool_registered(ToolName) - helper for safe negation in tool registration check
Decl is_tool_registered(ToolName).

# missing_tool_for(Intent, Capability) - detected capability gap
Decl missing_tool_for(Intent, Capability).

# task_failure_reason(TaskID, ReasonType, Detail)
Decl task_failure_reason(TaskID, ReasonType, Detail).

# task_failure_count(Capability, Count) - tracks repeated failures
Decl task_failure_count(Capability, Count).

# =============================================================================
# SECTION 29: TOOL LEARNING / REFINEMENT (Autopoiesis)
# =============================================================================
# Predicates for tool quality tracking and refinement

# refinement_state(ToolName, State) - tracks refinement lifecycle
# State: /idle, /in_progress, /completed, /failed
Decl refinement_state(ToolName, State).

# tool_known_issue(ToolName, IssueType) - known issues with a tool
# IssueType: /pagination, /incomplete, /rate_limit, /timeout
Decl tool_known_issue(ToolName, IssueType).

# issue_occurrence_count(ToolName, IssueType, Count) - how often issue occurs
Decl issue_occurrence_count(ToolName, IssueType, Count).

# capability_similar_to(Capability, SimilarCapability) - capability relationships
Decl capability_similar_to(Capability, SimilarCapability).

# tool_refined(ToolName, OldVersion, NewVersion) - refinement history
Decl tool_refined(ToolName, OldVersion, NewVersion).

# version_quality(ToolName, Version, QualityScore) - quality per version
Decl version_quality(ToolName, Version, QualityScore).

# tool_quality_poor(ToolName) - derived: tool has low quality
Decl tool_quality_poor(ToolName).

# refinement_count(ToolName, Count) - number of refinements attempted
Decl refinement_count(ToolName, Count).

# tool_learning(ToolName, Executions, SuccessRate, AvgQuality) - learning metrics
Decl tool_learning(ToolName, Executions, SuccessRate, AvgQuality).

# active_generation(ToolName) - tool is being generated
Decl active_generation(ToolName).

# =============================================================================
# SECTION 30: CODER SHARD HELPERS
# =============================================================================

# file_content(FilePath, Content) - cached file content
Decl file_content(FilePath, Content).

# coder_state(State) - current coder state
# State: /idle, /context_ready, /code_generated, /edit_applied, /build_passed, /build_failed
Decl coder_state(State).

# pending_edit(FilePath, Content) - pending edits
Decl pending_edit(FilePath, Content).

# coder_block_write(FilePath, Reason) - derived: write is blocked
Decl coder_block_write(FilePath, Reason).

# coder_safe_to_write(FilePath) - derived: safe to write
Decl coder_safe_to_write(FilePath).

# is_binary_file(FilePath) - file is binary (cannot edit)
Decl is_binary_file(FilePath).

# build_state(State) - current build state
# State: /passing, /failing, /unknown
Decl build_state(State).

# =============================================================================
# SECTION 31: REVIEWER SHARD HELPERS
# =============================================================================

# file_line_count(FilePath, LineCount) - line count per file
Decl file_line_count(FilePath, LineCount).

# finding_count(Severity, Count) - count of findings by severity
Decl finding_count(Severity, Count).

# style_rule(RuleID, RuleName, Threshold) - style rule definitions
Decl style_rule(RuleID, RuleName, Threshold).

# =============================================================================
# SECTION 32: SAFE NEGATION HELPERS
# =============================================================================
# These helpers support safe negation patterns in Mangle rules

# has_block_commit() - helper: true if any block_commit exists
Decl has_block_commit().

# has_active_refinement() - helper: true if any refinement in progress
Decl has_active_refinement().

# has_eligible_phase() - helper: true if any phase is eligible
Decl has_eligible_phase().

# has_next_campaign_task() - helper: true if there's a next task
Decl has_next_campaign_task().

# has_in_progress_phase() - helper: true if any phase in progress
Decl has_in_progress_phase().

# has_incomplete_phase(CampaignID) - helper: campaign has incomplete phases
Decl has_incomplete_phase(CampaignID).

# has_incomplete_phase_task(PhaseID) - helper: phase has incomplete tasks
Decl has_incomplete_phase_task(PhaseID).

# =============================================================================
# SECTION 33: SYSTEM SHARD COORDINATION
# =============================================================================
# Predicates for coordinating the 6 Type 1 system shards:
# - perception_firewall: NL → atoms transduction
# - world_model_ingestor: file_topology, symbol_graph maintenance
# - executive_policy: next_action derivation
# - constitution_gate: safety enforcement
# - tactile_router: action → tool routing
# - session_planner: agenda/campaign orchestration

# -----------------------------------------------------------------------------
# 33.1 System Shard Registry
# -----------------------------------------------------------------------------

# system_shard(ShardName) - registered system shards
Decl system_shard(ShardName).

# system_shard_state(ShardName, State) - current shard state
# State: /idle, /starting, /running, /stopping, /stopped, /error
Decl system_shard_state(ShardName, State).

# system_heartbeat(ShardName, Timestamp) - last heartbeat from shard
Decl system_heartbeat(ShardName, Timestamp).

# -----------------------------------------------------------------------------
# 33.2 Intent Processing Flow
# -----------------------------------------------------------------------------

# processed_intent(IntentID) - intent has been processed by perception
Decl processed_intent(IntentID).

# pending_intent(IntentID) - derived: intent waiting to be processed
Decl pending_intent(IntentID).

# -----------------------------------------------------------------------------
# 33.3 Action Flow (Executive → Constitution → Router)
# -----------------------------------------------------------------------------

# pending_action(ActionType, Target, Timestamp) - action awaiting permission check
Decl pending_action(ActionType, Target, Timestamp).

# pending_permission_check(ActionID) - derived: action needs constitution check
Decl pending_permission_check(ActionID).

# action_permitted(ActionType, Target, Timestamp) - action passed constitution gate
Decl action_permitted(ActionType, Target, Timestamp).

# ready_for_routing(ActionID) - derived: action ready for router
Decl ready_for_routing(ActionID).

# exec_request(ToolName, Target, Timeout, CallID, Timestamp) - router output
Decl exec_request(ToolName, Target, Timeout, CallID, Timestamp).

# -----------------------------------------------------------------------------
# 33.4 Safety & Violations
# -----------------------------------------------------------------------------

# security_violation(ActionType, Reason, Timestamp) - blocked by constitution
Decl security_violation(ActionType, Reason, Timestamp).

# escalation_needed(ShardName, Type, Context, Reason, Timestamp) - needs human
Decl escalation_needed(ShardName, Type, Context, Reason, Timestamp).

# rule_proposal_pending(ShardName, MangleCode, Rationale, Confidence, Timestamp)
Decl rule_proposal_pending(ShardName, MangleCode, Rationale, Confidence, Timestamp).

# -----------------------------------------------------------------------------
# 33.5 System Health
# -----------------------------------------------------------------------------

# system_shard_healthy(ShardName) - derived: shard heartbeat recent
Decl system_shard_healthy(ShardName).

# system_shard_unhealthy(ShardName) - derived: shard heartbeat stale
Decl system_shard_unhealthy(ShardName).

# world_model_heartbeat(ShardID, FileCount, Timestamp) - world model status
Decl world_model_heartbeat(ShardID, FileCount, Timestamp).

# session_planner_status(Total, Pending, InProgress, Completed, Blocked, Timestamp)
Decl session_planner_status(Total, Pending, InProgress, Completed, Blocked, Timestamp).

# -----------------------------------------------------------------------------
# 33.6 Routing & Tool Management
# -----------------------------------------------------------------------------

# routing_error(ActionType, Reason, Timestamp) - router couldn't find handler
Decl routing_error(ActionType, Reason, Timestamp).

# route_added(ActionPattern, ToolName, Timestamp) - new route added via autopoiesis
Decl route_added(ActionPattern, ToolName, Timestamp).

# -----------------------------------------------------------------------------
# 33.7 Agenda & Planning
# -----------------------------------------------------------------------------

# agenda_item(ItemID, Description, Priority, Status, Timestamp)
Decl agenda_item(ItemID, Description, Priority, Status, Timestamp).

# session_checkpoint(CheckpointID, ItemsRemaining, Timestamp)
Decl session_checkpoint(CheckpointID, ItemsRemaining, Timestamp).

# task_completed(TaskID) - task marked complete
Decl task_completed(TaskID).

# task_blocked(TaskID) - task is blocked
Decl task_blocked(TaskID).

# -----------------------------------------------------------------------------
# 33.8 Perception Errors & Stats
# -----------------------------------------------------------------------------

# perception_error(Message, Timestamp) - perception shard error
Decl perception_error(Message, Timestamp).

# world_model_error(Message, Timestamp) - world model shard error
Decl world_model_error(Message, Timestamp).

# executive_error(Message, Timestamp) - executive shard error
Decl executive_error(Message, Timestamp).

# executive_trace(Action, FromRule, Rationale, Timestamp) - debug trace
Decl executive_trace(Action, FromRule, Rationale, Timestamp).

# strategy_activated(StrategyName, Timestamp) - strategy change
Decl strategy_activated(StrategyName, Timestamp).

# execution_blocked(Reason, Timestamp) - executive blocked
Decl execution_blocked(Reason, Timestamp).

# -----------------------------------------------------------------------------
# 33.8b Tactile Execution Audit Facts
# -----------------------------------------------------------------------------
# Facts generated by tactile/audit.go for execution event tracking

# execution_started(SessionID, RequestID, Binary, Timestamp) - command started
Decl execution_started(SessionID, RequestID, Binary, Timestamp).

# execution_command(RequestID, CommandString) - full command string
Decl execution_command(RequestID, CommandString).

# execution_working_dir(RequestID, WorkingDir) - working directory
Decl execution_working_dir(RequestID, WorkingDir).

# execution_completed(RequestID, ExitCode, DurationMs, Timestamp) - command finished
Decl execution_completed(RequestID, ExitCode, DurationMs, Timestamp).

# execution_output(RequestID, StdoutLen, StderrLen) - output lengths
Decl execution_output(RequestID, StdoutLen, StderrLen).

# execution_success(RequestID) - successful execution (exit code 0)
Decl execution_success(RequestID).

# execution_nonzero(RequestID, ExitCode) - non-zero exit code
Decl execution_nonzero(RequestID, ExitCode).

# execution_failure(RequestID, Error) - infrastructure failure
Decl execution_failure(RequestID, Error).

# execution_resource_usage(RequestID, CPUTimeMs, MemoryBytes) - resource metrics
Decl execution_resource_usage(RequestID, CPUTimeMs, MemoryBytes).

# execution_io(RequestID, ReadBytes, WriteBytes) - I/O metrics
Decl execution_io(RequestID, ReadBytes, WriteBytes).

# execution_sandbox(RequestID, SandboxMode) - sandbox mode used
Decl execution_sandbox(RequestID, SandboxMode).

# execution_killed(RequestID, Reason, DurationMs) - command was killed
Decl execution_killed(RequestID, Reason, DurationMs).

# execution_error(RequestID, ErrorMessage) - execution error
Decl execution_error(RequestID, ErrorMessage).

# -----------------------------------------------------------------------------
# 33.9 Policy Derived Predicates (Section 21 Support)
# -----------------------------------------------------------------------------

# Intent processing derived predicates
Decl intent_processed(IntentID).
Decl focus_needs_resolution(Ref).
Decl intent_ready_for_executive(IntentID).

# Action flow derived predicates
Decl action_pending_permission(ActionID).
Decl permission_checked(ActionID).
Decl permission_check_result(ActionID, Result, Reason).
Decl action_blocked(ActionID, Reason).
Decl action_routed(ActionID).
Decl routing_result(ActionID, Result, Details).
Decl routing_succeeded(ActionID).
Decl routing_failed(ActionID, Error).

# Health monitoring derived predicates
Decl shard_heartbeat_stale(ShardName).

# Safety derived predicates
Decl block_all_actions(Reason).
Decl security_anomaly(AnomalyID, Type, Details).
Decl anomaly_investigated(AnomalyID).
Decl investigation_result(AnomalyID, Result).
Decl violation_count(Pattern, Count).
Decl propose_safety_rule(Pattern).
Decl repeated_violation_pattern(Pattern).
Decl safety_violation(ViolationID, Pattern, ActionType, Timestamp).

# World model derived predicates
Decl world_model_stale(File).
Decl file_in_project(File).
Decl symbol_reachable(From, To).

# Routing derived predicates
Decl routing_table(ActionType, Tool, RiskLevel).
Decl tool_allowlist(Tool, Timestamp).
Decl tool_allowed(Tool, ActionType).
Decl route_action(ActionID, Tool).
Decl action_type(ActionID, ActionType).
Decl routing_blocked(ActionID, Reason).
Decl has_tool_for_action(ActionType).

# Agenda/Planning derived predicates
Decl agenda_item_ready(ItemID).
Decl has_incomplete_dependency(ItemID).
Decl agenda_dependency(ItemID, DepID).
Decl next_agenda_item(ItemID).
Decl has_higher_priority_item(ItemID).
Decl checkpoint_due().
Decl last_checkpoint_time(Timestamp).
Decl agenda_item_escalate(ItemID, Reason).
Decl item_retry_count(ItemID, Count).

# Shard activation derived predicates
Decl activate_shard(ShardName).
Decl system_startup(ShardName, Mode).

# Autopoiesis derived predicates
Decl unhandled_case_count(ShardName, Count).
Decl unhandled_cases(ShardName, Cases).
Decl propose_new_rule(ShardName).
Decl proposed_rule(RuleID, ShardName, MangleCode, Confidence).
Decl rule_needs_approval(RuleID).
Decl auto_apply_rule(RuleID).
Decl rule_applied(RuleID).
Decl applied_rule(RuleID, Timestamp).
Decl learning_signal(SignalType, RuleID).
Decl rule_outcome(RuleID, Outcome, Details).

# OODA loop derived predicates
Decl ooda_phase(Phase).
Decl has_next_action().
Decl current_ooda_phase(Phase).
Decl ooda_stalled(Reason).
Decl last_action_time(Timestamp).

# Builtin helper predicates (implemented in Go runtime)
Decl time_diff(Time1, Time2, Diff).
Decl list_length(List, Length).

# =============================================================================
# SECTION 34: CODE DOM (Interactive Code Elements)
# =============================================================================
# Analogous to Browser DOM, Code DOM projects code into semantic chunks
# (functions, structs, interfaces) with stable refs for querying and editing.
# Uses 1-hop dependency scope: active file + imports + files that import it.

# -----------------------------------------------------------------------------
# 34.1 File Scope Management
# -----------------------------------------------------------------------------

# active_file(Path) - the primary file being worked on
Decl active_file(Path).

# file_in_scope(Path, Hash, Language, LineCount) - files in current scope
# Language: /go, /python, /ts, /rust
Decl file_in_scope(Path, Hash, Language, LineCount).

# -----------------------------------------------------------------------------
# 34.2 Code Elements (Semantic Chunks)
# -----------------------------------------------------------------------------

# code_element(Ref, ElemType, File, StartLine, EndLine)
# Ref: stable reference like "fn:context.Compressor.Compress"
# ElemType: /function, /method, /struct, /interface, /type, /const, /var
Decl code_element(Ref, ElemType, File, StartLine, EndLine).

# element_signature(Ref, Signature) - declaration line
Decl element_signature(Ref, Signature).

# element_body(Ref, BodyText) - full text for display/editing
Decl element_body(Ref, BodyText).

# element_parent(Ref, ParentRef) - containment (method -> struct)
Decl element_parent(Ref, ParentRef).

# element_visibility(Ref, Visibility) - /public, /private
Decl element_visibility(Ref, Visibility).

# code_interactable(Ref, ActionType) - available actions per element
# ActionType: /view, /replace, /insert_before, /insert_after, /delete
Decl code_interactable(Ref, ActionType).

# -----------------------------------------------------------------------------
# 34.3 Edit Tracking
# -----------------------------------------------------------------------------

# element_modified(Ref, SessionID, Timestamp) - tracks element changes
Decl element_modified(Ref, SessionID, Timestamp).

# lines_edited(File, StartLine, EndLine, SessionID) - line-level tracking
Decl lines_edited(File, StartLine, EndLine, SessionID).

# lines_inserted(File, AfterLine, LineCount, SessionID) - insertions
Decl lines_inserted(File, AfterLine, LineCount, SessionID).

# lines_deleted(File, StartLine, EndLine, SessionID) - deletions
Decl lines_deleted(File, StartLine, EndLine, SessionID).

# file_read(Path, SessionID, Timestamp) - file access tracking
Decl file_read(Path, SessionID, Timestamp).

# file_written(Path, Hash, SessionID, Timestamp) - file write tracking
Decl file_written(Path, Hash, SessionID, Timestamp).

# -----------------------------------------------------------------------------
# 34.4 Code DOM Derived Predicates
# -----------------------------------------------------------------------------

# in_scope(File) - derived: file is in current scope
Decl in_scope(File).

# editable(Ref) - derived: element can be edited
Decl editable(Ref).

# function_in_scope(Ref, File, Sig) - derived: functions in scope
Decl function_in_scope(Ref, File, Sig).

# method_of(MethodRef, StructRef) - derived: method belongs to struct
Decl method_of(MethodRef, StructRef).

# code_contains(Parent, Child) - derived: transitive containment
Decl code_contains(Parent, Child).

# safe_to_modify(Ref) - derived: has tests, builds pass
Decl safe_to_modify(Ref).

# requires_campaign(Intent) - derived: complex refactor needs campaign
Decl requires_campaign(Intent).

# code_edit_outcome(Ref, EditType, Success) - edit result tracking
Decl code_edit_outcome(Ref, EditType, Success).

# proven_safe_edit(Ref, EditType) - derived: edit pattern is safe
Decl proven_safe_edit(Ref, EditType).
# Cortex 1.5.0 Executive Policy (IDB)
# Version: 1.5.0
# Philosophy: Logic determines Reality; the Model merely describes it.

# =============================================================================
# SECTION 1: SPREADING ACTIVATION (Context Selection)
# =============================================================================
# Per §8.1: Energy flows from the user's intent through the graph of known facts

# 1. Base Activation (Recency) - High priority for new facts
activation(Fact, 100) :- new_fact(Fact).

# 2. Spreading Activation (Dependency)
# Energy flows from goals to required tools
activation(Tool, 80) :-
    active_goal(Goal),
    tool_capabilities(Tool, Cap),
    goal_requires(Goal, Cap).

# 3. Intent-driven activation
activation(Target, 90) :-
    user_intent(_, _, _, Target, _).

# 4. File modification spreads to dependents
activation(Dep, 70) :-
    modified(File),
    dependency_link(Dep, File, _).

# 5. Context Pruning - Only high-activation facts enter working memory
context_atom(Fact) :-
    activation(Fact, Score),
    Score > 30.

# =============================================================================
# SECTION 2: STRATEGY SELECTION (§3.1)
# =============================================================================
# Different coding tasks require different logical loops

# TDD Repair Loop for bug fixes
active_strategy(/tdd_repair_loop) :-
    user_intent(_, _, /fix, _, _),
    diagnostic(/error, _, _, _, _).

active_strategy(/tdd_repair_loop) :-
    user_intent(_, _, /debug, _, _).

# Exploration for queries
active_strategy(/breadth_first_survey) :-
    user_intent(_, /query, /explore, _, _).

active_strategy(/breadth_first_survey) :-
    user_intent(_, /query, /explain, _, _).

# Code generation for scaffolding
active_strategy(/project_init) :-
    user_intent(_, /mutation, /scaffold, _, _).

active_strategy(/project_init) :-
    user_intent(_, /mutation, /init, _, _).

# Refactor guard for modifications
active_strategy(/refactor_guard) :-
    user_intent(_, /mutation, /refactor, _, _).

# =============================================================================
# SECTION 3: TDD REPAIR LOOP (§3.2)
# =============================================================================
# State machine: Write -> Test -> Analyze -> Fix

# State Transitions
next_action(/read_error_log) :-
    test_state(/failing),
    retry_count(N), N < 3.

next_action(/analyze_root_cause) :-
    test_state(/log_read).

next_action(/generate_patch) :-
    test_state(/cause_found).

next_action(/run_tests) :-
    test_state(/patch_applied).

next_action(/run_tests) :-
    test_state(/unknown),
    user_intent(_, _, /test, _, _).

# Surrender Logic - Escalate after 3 retries
next_action(/escalate_to_user) :-
    test_state(/failing),
    retry_count(N), N >= 3.

# Success state
next_action(/complete) :-
    test_state(/passing).

# =============================================================================
# SECTION 4: FOCUS RESOLUTION & CLARIFICATION (§1.2)
# =============================================================================

# Clarification threshold - block execution if confidence < 0.85
clarification_needed(Ref) :-
    focus_resolution(Ref, _, _, Score),
    Score < 0.85.

# Block action derivation when clarification is needed
next_action(/interrogative_mode) :-
    clarification_needed(_).

# Ambiguity detection
ambiguity_detected(Param) :-
    ambiguity_flag(Param, _, _).

next_action(/interrogative_mode) :-
    ambiguity_detected(_).

# =============================================================================
# SECTION 5: IMPACT ANALYSIS & REFACTORING GUARD (§3.3)
# =============================================================================

# Direct impact
impacted(X) :-
    dependency_link(X, Y, _),
    modified(Y).

# Transitive closure (recursive impact)
impacted(X) :-
    dependency_link(X, Z, _),
    impacted(Z).

# Unsafe to refactor if impacted code lacks test coverage
unsafe_to_refactor(Target) :-
    impacted(Target),
    !test_coverage(Target).

# Block refactoring when unsafe
block_refactor(Target, "uncovered_dependency") :-
    unsafe_to_refactor(Target).

# =============================================================================
# SECTION 6: COMMIT BARRIER (§2.2)
# =============================================================================

# Cannot commit if there are errors
block_commit("Build Broken") :-
    diagnostic(/error, _, _, _, _).

block_commit("Tests Failing") :-
    test_state(/failing).

# Helper for safe negation
has_block_commit() :-
    block_commit(_).

# Safe to commit
safe_to_commit() :-
    !has_block_commit().

# =============================================================================
# SECTION 7: CONSTITUTIONAL LOGIC / SAFETY (§5.0)
# =============================================================================

# Default deny - permitted must be positively derived
permitted(Action) :-
    safe_action(Action).

permitted(Action) :-
    dangerous_action(Action),
    admin_override(User),
    signed_approval(Action).

# Dangerous action patterns - marked by explicit facts
# dangerous_action is derived from danger_marker facts
# (String matching to be implemented via custom builtins)

# Network policy - allowlist approach
allowed_domain("github.com").
allowed_domain("pypi.org").
allowed_domain("crates.io").
allowed_domain("npmjs.com").
allowed_domain("pkg.go.dev").

# Note: network_permitted and security_violation require string matching
# which will be implemented via custom Go builtins at runtime

# =============================================================================
# SECTION 8: SHARD DELEGATION (§7.0)
# =============================================================================

# Delegate to researcher for init/explore
delegate_task(/researcher, "Initialize codebase analysis", /pending) :-
    user_intent(_, _, /init, _, _).

delegate_task(/researcher, Task, /pending) :-
    user_intent(_, _, /research, Task, _).

delegate_task(/researcher, Task, /pending) :-
    user_intent(_, /query, /explore, Task, _).

# Delegate to coder for coding tasks
delegate_task(/coder, Task, /pending) :-
    user_intent(_, /mutation, /implement, Task, _).

# Note: Negation with unbound variables is unsafe in Datalog
# Delegate refactoring task only when block_refactor facts don't exist
# This is handled at runtime by checking block_refactor before delegation
delegate_task(/coder, Task, /pending) :-
    user_intent(_, /mutation, /refactor, Task, _).

# Delegate to tester for test tasks
delegate_task(/tester, Task, /pending) :-
    user_intent(_, _, /test, Task, _).

delegate_task(/tester, "Generate tests for impacted code", /pending) :-
    impacted(File),
    !test_coverage(File).

# Delegate to reviewer for review tasks
delegate_task(/reviewer, Task, /pending) :-
    user_intent(_, _, /review, Task, _).

# =============================================================================
# SECTION 9: BROWSER PHYSICS (§9.0)
# =============================================================================

# Spatial reasoning - element to the left
left_of(A, B) :-
    geometry(A, Ax, _, _, _),
    geometry(B, Bx, _, _, _),
    Ax < Bx.

# Element above another
above(A, B) :-
    geometry(A, _, Ay, _, _),
    geometry(B, _, By, _, _),
    Ay < By.

# Honeypot detection via CSS properties
honeypot_detected(ID) :-
    computed_style(ID, "display", "none").

honeypot_detected(ID) :-
    computed_style(ID, "visibility", "hidden").

honeypot_detected(ID) :-
    computed_style(ID, "opacity", "0").

honeypot_detected(ID) :-
    geometry(ID, _, _, 0, _).

honeypot_detected(ID) :-
    geometry(ID, _, _, _, 0).

# Safe interactive elements (not honeypots)
safe_interactable(ID) :-
    interactable(ID, _),
    !honeypot_detected(ID).

# Target checkbox to the left of label text
target_checkbox(CheckID, LabelText) :-
    dom_node(CheckID, /input, _),
    attr(CheckID, "type", "checkbox"),
    visible_text(TextID, LabelText),
    left_of(CheckID, TextID).

# =============================================================================
# SECTION 10: TOOL CAPABILITY MAPPING & ACTION MAPPING
# =============================================================================

# Tool capabilities for spreading activation
tool_capabilities(/fs_read, /read).
tool_capabilities(/fs_write, /write).
tool_capabilities(/exec_cmd, /execute).
tool_capabilities(/browser, /navigate).
tool_capabilities(/browser, /click).
tool_capabilities(/browser, /type).
tool_capabilities(/code_graph, /analyze).
tool_capabilities(/code_graph, /dependencies).

# Goal capability requirements
goal_requires(Goal, /read) :-
    user_intent(_, /query, _, Goal, _).

goal_requires(Goal, /write) :-
    user_intent(_, /mutation, _, Goal, _).

goal_requires(Goal, /execute) :-
    user_intent(_, _, /run, Goal, _).

goal_requires(Goal, /analyze) :-
    user_intent(_, _, /explain, Goal, _).

# Action Mappings: Map intent verbs to executable actions
# Core actions
action_mapping(/explain, /analyze_code).
action_mapping(/read, /fs_read).
action_mapping(/search, /search_files).
action_mapping(/run, /exec_cmd).
action_mapping(/test, /run_tests).

# Code review & analysis actions (delegate to reviewer shard)
action_mapping(/review, /delegate_reviewer).
action_mapping(/security, /delegate_reviewer).
action_mapping(/analyze, /delegate_reviewer).

# Code mutation actions (delegate to coder shard)
action_mapping(/fix, /delegate_coder).
action_mapping(/refactor, /delegate_coder).
action_mapping(/create, /delegate_coder).
action_mapping(/delete, /delegate_coder).
action_mapping(/write, /fs_write).
action_mapping(/document, /delegate_coder).
action_mapping(/commit, /delegate_coder).

# Debug actions
action_mapping(/debug, /delegate_coder).

# Research actions (delegate to researcher shard)
action_mapping(/research, /delegate_researcher).
action_mapping(/explore, /delegate_researcher).

# Autopoiesis/Tool generation actions (delegate to tool_generator shard)
action_mapping(/generate_tool, /delegate_tool_generator).
action_mapping(/refine_tool, /delegate_tool_generator).
action_mapping(/list_tools, /delegate_tool_generator).
action_mapping(/tool_status, /delegate_tool_generator).

# Diff actions
action_mapping(/diff, /show_diff).

# Derive next_action from intent and mapping
next_action(Action) :-
    user_intent(_, _, Verb, _, _),
    action_mapping(Verb, Action).

# Specific file system actions
next_action(/fs_read) :-
    user_intent(_, _, /read, _, _).

next_action(/fs_write) :-
    user_intent(_, _, /write, _, _).

# Review delegation - high confidence triggers immediate delegation
delegate_task(/reviewer, Target, /pending) :-
    user_intent(_, _, /review, Target, _).

delegate_task(/reviewer, Target, /pending) :-
    user_intent(_, _, /security, Target, _).

delegate_task(/reviewer, Target, /pending) :-
    user_intent(_, _, /analyze, Target, _).

# Tool generator delegation - autopoiesis operations
delegate_task(/tool_generator, Target, /pending) :-
    user_intent(_, _, /generate_tool, Target, _).

delegate_task(/tool_generator, Target, /pending) :-
    user_intent(_, _, /refine_tool, Target, _).

delegate_task(/tool_generator, "", /pending) :-
    user_intent(_, _, /list_tools, _, _).

delegate_task(/tool_generator, Target, /pending) :-
    user_intent(_, _, /tool_status, Target, _).

# Auto-delegate when missing capability detected (implicit tool generation)
delegate_task(/tool_generator, Cap, /pending) :-
    missing_tool_for(_, Cap),
    !tool_generation_blocked(Cap).

# =============================================================================
# SECTION 11: ABDUCTIVE REASONING (§8.2)
# =============================================================================

# Abductive reasoning: missing hypotheses are symptoms without known causes
# This rule requires all variables to be bound in the negated atom
# Implementation: We use a helper predicate has_known_cause to track which symptoms have causes
# Then negate against that helper

# Mark symptoms that have known causes
has_known_cause(Symptom) :-
    known_cause(Symptom, _).

# Symptoms without causes need investigation
# Note: Using has_known_cause helper to ensure safe negation
missing_hypothesis(Symptom) :-
    symptom(_, Symptom),
    !has_known_cause(Symptom).

# Trigger clarification for missing hypotheses
next_action(/interrogative_mode) :-
    missing_hypothesis(_).

# =============================================================================
# SECTION 12: AUTOPOIESIS / LEARNING (§8.3)
# =============================================================================

# Detect repeated rejection pattern
preference_signal(Pattern) :-
    rejection_count(Pattern, N),
    N >= 3.

# Promote to long-term memory
promote_to_long_term(FactType, FactValue) :-
    preference_signal(Pattern),
    derived_rule(Pattern, FactType, FactValue).

# Autopoiesis: Missing Tool Detection
# Helper: derive when we HAVE a capability (for safe negation)
has_capability(Cap) :-
    tool_capabilities(_, Cap).

# Derive missing_tool_for if user intent requires a capability we don't have
missing_tool_for(IntentID, Cap) :-
    user_intent(IntentID, _, _, _, _),
    goal_requires(_, Cap),
    !has_capability(Cap).

# Trigger tool generation if tool is missing
next_action(/generate_tool) :-
    missing_tool_for(_, _).

# =============================================================================
# SECTION 12B: OUROBOROS LOOP - TOOL SELF-GENERATION
# =============================================================================
# The Ouroboros Loop: Detection → Specification → Safety → Compile → Register → Execute
# Named after the ancient symbol of a serpent eating its own tail.

# Tool exists in registry
tool_exists(ToolName) :-
    tool_registered(ToolName, _).

# Tool is ready for execution (compiled and registered)
tool_ready(ToolName) :-
    tool_exists(ToolName),
    tool_hash(ToolName, _).

# Capability is available if any tool provides it
capability_available(Cap) :-
    tool_capability(_, Cap).

# Need new tool when capability missing and user explicitly requests it
explicit_tool_request(Cap) :-
    user_intent(_, /mutation, /generate_tool, Cap, _).

# Need new tool when repeated failures suggest capability gap
capability_gap_detected(Cap) :-
    task_failure_reason(_, "missing_capability", Cap),
    task_failure_count(Cap, N),
    N >= 2.

# Tool generation is permitted (safety gate)
tool_generation_permitted(Cap) :-
    missing_tool_for(_, Cap),
    !tool_generation_blocked(Cap).

# Block tool generation for dangerous capabilities
tool_generation_blocked(Cap) :-
    dangerous_capability(Cap).

# Define dangerous capabilities that should never be auto-generated
dangerous_capability(/exec_arbitrary).
dangerous_capability(/network_unconstrained).
dangerous_capability(/system_admin).
dangerous_capability(/credential_access).

# Ouroboros next actions
next_action(/ouroboros_detect) :-
    capability_gap_detected(_).

next_action(/ouroboros_generate) :-
    tool_generation_permitted(_),
    !has_active_generation().

next_action(/ouroboros_compile) :-
    tool_source_ready(ToolName),
    tool_safety_verified(ToolName),
    !tool_compiled(ToolName).

next_action(/ouroboros_register) :-
    tool_compiled(ToolName),
    !is_tool_registered(ToolName).

# Track active tool generation (prevent parallel generations)
active_generation(ToolName) :-
    generation_state(ToolName, /in_progress).

# Helper for safe negation - true if any generation is in progress
has_active_generation() :-
    active_generation(_).

# Helper for safe negation - true if tool is registered
is_tool_registered(ToolName) :-
    tool_registered(ToolName, _).

# Tool lifecycle states
tool_lifecycle(ToolName, /detected) :-
    missing_tool_for(_, ToolName).

tool_lifecycle(ToolName, /generating) :-
    generation_state(ToolName, /in_progress).

tool_lifecycle(ToolName, /safety_check) :-
    tool_source_ready(ToolName),
    !tool_safety_verified(ToolName).

tool_lifecycle(ToolName, /compiling) :-
    tool_safety_verified(ToolName),
    !tool_compiled(ToolName).

tool_lifecycle(ToolName, /ready) :-
    tool_ready(ToolName).

# =============================================================================
# SECTION 12C: TOOL LEARNING AND OPTIMIZATION
# =============================================================================
# Learning from tool executions to improve future generations.

# Tool quality tracking
tool_quality_poor(ToolName) :-
    tool_learning(ToolName, Executions, SuccessRate, AvgQuality),
    Executions >= 3,
    AvgQuality < 0.5.

tool_quality_acceptable(ToolName) :-
    tool_learning(ToolName, Executions, _, AvgQuality),
    Executions >= 3,
    AvgQuality >= 0.5,
    AvgQuality < 0.8.

tool_quality_good(ToolName) :-
    tool_learning(ToolName, Executions, _, AvgQuality),
    Executions >= 3,
    AvgQuality >= 0.8.

# Trigger refinement for poor quality tools
tool_needs_refinement(ToolName) :-
    tool_quality_poor(ToolName).

tool_needs_refinement(ToolName) :-
    tool_known_issue(ToolName, /pagination),
    tool_learning(ToolName, Executions, _, _),
    Executions >= 2.

tool_needs_refinement(ToolName) :-
    tool_known_issue(ToolName, /incomplete),
    tool_learning(ToolName, Executions, _, _),
    Executions >= 2.

# Next action for refinement
next_action(/refine_tool) :-
    tool_needs_refinement(_),
    !has_active_refinement().

# Prevent parallel refinements
active_refinement(ToolName) :-
    refinement_state(ToolName, /in_progress).

# Helper for safe negation - true if any refinement is in progress
has_active_refinement() :-
    active_refinement(_).

# Learning pattern signals
learning_pattern_detected(ToolName, IssueType) :-
    tool_known_issue(ToolName, IssueType),
    issue_occurrence_count(ToolName, IssueType, Count),
    Count >= 3.

# Promote learnings to tool generation hints
tool_generation_hint(Capability, "add_pagination") :-
    learning_pattern_detected(_, /pagination),
    capability_similar_to(Capability, _).

tool_generation_hint(Capability, "increase_limits") :-
    learning_pattern_detected(_, /incomplete),
    capability_similar_to(Capability, _).

tool_generation_hint(Capability, "add_retry") :-
    learning_pattern_detected(_, /rate_limit),
    capability_similar_to(Capability, _).

# Track refinement success
refinement_effective(ToolName) :-
    tool_refined(ToolName, OldVersion, NewVersion),
    version_quality(ToolName, OldVersion, OldQuality),
    version_quality(ToolName, NewVersion, NewQuality),
    NewQuality > OldQuality.

# Escalate if refinement didn't help
escalate_to_user(ToolName, "refinement_ineffective") :-
    tool_refined(ToolName, _, _),
    tool_quality_poor(ToolName),
    refinement_count(ToolName, Count),
    Count >= 2.

# =============================================================================
# SECTION 13: GIT-AWARE SAFETY / CHESTERTON'S FENCE (§21)
# =============================================================================

# Recent change by another author (within 2 days)
recent_change_by_other(File) :-
    git_history(File, _, Author, Age, _),
    current_user(CurrentUser),
    Author != CurrentUser,
    Age < 2.

# Chesterton's Fence warning - warn before deleting recently-changed code
chesterton_fence_warning(File, "recent_change_by_other") :-
    user_intent(_, /mutation, /delete, File, _),
    recent_change_by_other(File).

chesterton_fence_warning(File, "high_churn_file") :-
    user_intent(_, /mutation, /refactor, File, _),
    churn_rate(File, Freq),
    Freq > 5.0.

# Trigger clarification for Chesterton's Fence
clarification_needed(File) :-
    chesterton_fence_warning(File, _).

# =============================================================================
# SECTION 14: SHADOW MODE / COUNTERFACTUAL REASONING (§22)
# =============================================================================

# Helper for safe negation
has_projection_violation(ActionID) :-
    projection_violation(ActionID, _).

# Safe projection - action passes safety checks in shadow simulation
safe_projection(ActionID) :-
    shadow_state(_, ActionID, /valid),
    !has_projection_violation(ActionID).

# Projection violation detection
projection_violation(ActionID, "test_failure") :-
    simulated_effect(ActionID, "diagnostic", _),
    simulated_effect(ActionID, "diagnostic_severity", /error).

projection_violation(ActionID, "security_violation") :-
    simulated_effect(ActionID, "security_violation", _).

# Block action if projection fails
block_commit("shadow_simulation_failed") :-
    pending_mutation(MutationID, _, _, _),
    !safe_projection(MutationID).

# =============================================================================
# SECTION 15: INTERACTIVE DIFF APPROVAL (§23)
# =============================================================================

# Require approval for dangerous mutations
requires_approval(MutationID) :-
    pending_mutation(MutationID, File, _, _),
    chesterton_fence_warning(File, _).

requires_approval(MutationID) :-
    pending_mutation(MutationID, File, _, _),
    impacted(File).

# Helper for safe negation
is_mutation_approved(MutationID) :-
    mutation_approved(MutationID, _, _).

# Block mutation without approval
next_action(/ask_user) :-
    pending_mutation(MutationID, _, _, _),
    requires_approval(MutationID),
    !is_mutation_approved(MutationID).

# =============================================================================
# SECTION 16: SESSION STATE / CLARIFICATION LOOP (§20)
# =============================================================================

# Resume from clarification
next_action(/resume_task) :-
    session_state(_, /suspended, _),
    focus_clarification(_).

# Clear clarification when answered
# (Handled at runtime - logic marks session as active)

# =============================================================================
# SECTION 17: KNOWLEDGE ATOM INTEGRATION (§24)
# =============================================================================

# Knowledge atoms inform strategy selection
active_strategy(/domain_expert) :-
    knowledge_atom(_, Concept, _, Confidence),
    Confidence > 0.8,
    user_intent(_, _, _, Target, _).
    # When high-confidence knowledge about the domain exists

# =============================================================================
# SECTION 18: SHARD TYPE CLASSIFICATION (§6.1 Taxonomy)
# =============================================================================

# Type 1: System Level - Always on, high reliability
shard_type(/system, /permanent, /high_reliability).

# Type 2: Ephemeral - Fast spawning, RAM only
shard_type(/ephemeral, /spawn_die, /speed_optimized).

# Type 3: Persistent LLM-Created - Background tasks, SQLite
shard_type(/persistent, /long_running, /adaptive).

# Type 4: User Configured - Deep domain knowledge
shard_type(/user, /explicit, /user_defined).

# Model capability mapping for shards
shard_model_config(/system, /high_reasoning).
shard_model_config(/ephemeral, /high_speed).
shard_model_config(/persistent, /balanced).
shard_model_config(/user, /high_reasoning).

# =============================================================================
# SECTION 19: CAMPAIGN ORCHESTRATION POLICY
# =============================================================================
# Long-running, multi-phase goal execution with context management

# -----------------------------------------------------------------------------
# 19.1 Campaign State Machine
# -----------------------------------------------------------------------------

# Current campaign is the one that's active
current_campaign(CampaignID) :-
    campaign(CampaignID, _, _, _, /active).

# Campaign execution strategy activates when a campaign is active
active_strategy(/campaign_execution) :-
    current_campaign(_).

# -----------------------------------------------------------------------------
# 19.2 Phase Eligibility & Sequencing
# -----------------------------------------------------------------------------

# Helper: check if a phase has incomplete hard dependencies
has_incomplete_hard_dep(PhaseID) :-
    phase_dependency(PhaseID, DepPhaseID, /hard),
    campaign_phase(DepPhaseID, _, _, _, Status, _),
    Status != /completed .

# A phase is eligible when all hard dependencies are complete
phase_eligible(PhaseID) :-
    campaign_phase(PhaseID, CampaignID, _, _, /pending, _),
    current_campaign(CampaignID),
    !has_incomplete_hard_dep(PhaseID).

# Helper: check if there's an earlier eligible phase
# Note: Order is bound by looking up PhaseID's order within the rule
has_earlier_phase(PhaseID) :-
    campaign_phase(PhaseID, _, _, Order, _, _),
    phase_eligible(OtherPhaseID),
    OtherPhaseID != PhaseID,
    campaign_phase(OtherPhaseID, _, _, OtherOrder, _, _),
    OtherOrder < Order.

# Current phase: lowest order eligible phase, or the one in progress
current_phase(PhaseID) :-
    campaign_phase(PhaseID, CampaignID, _, _, /in_progress, _),
    current_campaign(CampaignID).

current_phase(PhaseID) :-
    phase_eligible(PhaseID),
    !has_earlier_phase(PhaseID),
    !has_in_progress_phase().

# Helper: check if any phase is in progress
has_in_progress_phase() :-
    campaign_phase(_, CampaignID, _, _, /in_progress, _),
    current_campaign(CampaignID).

# Phase is blocked if it has incomplete hard dependencies
phase_blocked(PhaseID, "hard_dependency_incomplete") :-
    campaign_phase(PhaseID, CampaignID, _, _, /pending, _),
    current_campaign(CampaignID),
    has_incomplete_hard_dep(PhaseID).

# -----------------------------------------------------------------------------
# 19.3 Task Selection & Execution
# -----------------------------------------------------------------------------

# Helper: check if task has blocking dependencies
has_blocking_task_dep(TaskID) :-
    task_dependency(TaskID, BlockerID),
    campaign_task(BlockerID, _, _, Status, _),
    Status != /completed,
    Status != /skipped .

# Helper: check if there's an earlier pending task
has_earlier_task(TaskID, PhaseID) :-
    campaign_task(OtherTaskID, PhaseID, _, /pending, _),
    OtherTaskID != TaskID,
    task_priority(OtherTaskID, OtherPriority),
    task_priority(TaskID, Priority),
    priority_higher(OtherPriority, Priority).

# Priority ordering helper (will be implemented as Go builtin)
# For now, we use simple rules
priority_higher(/critical, /high).
priority_higher(/critical, /normal).
priority_higher(/critical, /low).
priority_higher(/high, /normal).
priority_higher(/high, /low).
priority_higher(/normal, /low).

# Next task: highest priority pending task in current phase without blockers
next_campaign_task(TaskID) :-
    current_phase(PhaseID),
    campaign_task(TaskID, PhaseID, _, /pending, _),
    !has_blocking_task_dep(TaskID).

# Derive next_action based on campaign task type
next_action(/campaign_create_file) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /file_create).

next_action(/campaign_modify_file) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /file_modify).

next_action(/campaign_write_test) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /test_write).

next_action(/campaign_run_test) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /test_run).

next_action(/campaign_research) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /research).

next_action(/campaign_verify) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /verify).

next_action(/campaign_document) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /document).

next_action(/campaign_refactor) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /refactor).

next_action(/campaign_integrate) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /integrate).

# Auto-spawn researcher shard for research tasks
delegate_task(/researcher, Description, /pending) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, Description, _, /research).

# Auto-spawn coder shard for file creation/modification
delegate_task(/coder, Description, /pending) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, Description, _, /file_create).

delegate_task(/coder, Description, /pending) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, Description, _, /file_modify).

# Auto-spawn tester shard for test tasks
delegate_task(/tester, Description, /pending) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, Description, _, /test_write).

delegate_task(/tester, Description, /pending) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, Description, _, /test_run).

# -----------------------------------------------------------------------------
# 19.4 Context Paging (Phase-Aware Spreading Activation)
# -----------------------------------------------------------------------------

# Boost activation for current phase context
activation(Fact, 150) :-
    current_phase(PhaseID),
    phase_context_atom(PhaseID, Fact, _).

# Boost files matching current task's target
activation(Target, 140) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, _),
    task_artifact(TaskID, _, Target, _).

# Suppress context from completed phases
activation(Fact, -50) :-
    context_compression(PhaseID, _, _, _),
    phase_context_atom(PhaseID, Fact, _).

# -----------------------------------------------------------------------------
# 19.5 Checkpoint & Verification
# -----------------------------------------------------------------------------

# Helper: check if phase has pending checkpoint
has_pending_checkpoint(PhaseID) :-
    phase_objective(PhaseID, _, _, VerifyMethod),
    VerifyMethod != /none,
    !has_passed_checkpoint(PhaseID, VerifyMethod).

has_passed_checkpoint(PhaseID, CheckType) :-
    phase_checkpoint(PhaseID, CheckType, /true, _, _).

# Helper: check if all phase tasks are complete
has_incomplete_phase_task(PhaseID) :-
    campaign_task(_, PhaseID, _, Status, _),
    Status != /completed,
    Status != /skipped .

all_phase_tasks_complete(PhaseID) :-
    campaign_phase(PhaseID, _, _, _, _, _),
    !has_incomplete_phase_task(PhaseID).

# Trigger checkpoint when all tasks complete but checkpoint pending
next_action(/run_phase_checkpoint) :-
    current_phase(PhaseID),
    all_phase_tasks_complete(PhaseID),
    has_pending_checkpoint(PhaseID).

# Block phase completion if checkpoint failed
phase_blocked(PhaseID, "checkpoint_failed") :-
    phase_checkpoint(PhaseID, _, /false, _, _).

# -----------------------------------------------------------------------------
# 19.6 Replanning Triggers
# -----------------------------------------------------------------------------

# Helper: identify failed tasks (for counting in Go runtime)
failed_campaign_task(CampaignID, TaskID) :-
    current_campaign(CampaignID),
    campaign_task(TaskID, PhaseID, Desc, /failed, TaskType),
    campaign_phase(PhaseID, CampaignID, PhaseName, Seq, Status, Profile).

# Trigger replan on repeated failures (threshold checked in Go runtime)
# The Go runtime counts failed_campaign_task facts and triggers replan if > 3
replan_needed(CampaignID, "task_failure_cascade") :-
    current_campaign(CampaignID),
    failed_campaign_task(CampaignID, TaskID1),
    failed_campaign_task(CampaignID, TaskID2),
    failed_campaign_task(CampaignID, TaskID3),
    TaskID1 != TaskID2,
    TaskID2 != TaskID3,
    TaskID1 != TaskID3.

# Trigger replan if user provides new instruction during campaign
replan_needed(CampaignID, "user_instruction") :-
    current_campaign(CampaignID),
    user_intent(_, /instruction, _, _, _).

# Trigger replan if explicit trigger exists
replan_needed(CampaignID, Reason) :-
    replan_trigger(CampaignID, Reason, _).

# Pause and replan action
next_action(/pause_and_replan) :-
    replan_needed(_, _).

# -----------------------------------------------------------------------------
# 19.7 Campaign Helpers for Safe Negation
# -----------------------------------------------------------------------------

# Helper: true if any phase is eligible to start
has_eligible_phase() :-
    phase_eligible(_).

# Helper: true if any phase is in progress
has_in_progress_phase() :-
    campaign_phase(_, _, _, _, /in_progress, _).

# Helper: true if there's a next campaign task available
has_next_campaign_task() :-
    next_campaign_task(_).

# Helper: check if any phase is not complete
has_incomplete_phase(CampaignID) :-
    campaign_phase(_, CampaignID, _, _, Status, _),
    Status != /completed,
    Status != /skipped .

# Campaign complete when all phases complete
campaign_complete(CampaignID) :-
    current_campaign(CampaignID),
    !has_incomplete_phase(CampaignID).

next_action(/campaign_complete) :-
    campaign_complete(_).

# -----------------------------------------------------------------------------
# 19.8 Campaign Blocking Conditions
# -----------------------------------------------------------------------------

# Campaign blocked if no eligible phases and none in progress
campaign_blocked(CampaignID, "no_eligible_phases") :-
    current_campaign(CampaignID),
    !has_eligible_phase(),
    !has_in_progress_phase(),
    has_incomplete_phase(CampaignID).

# Campaign blocked if all remaining tasks are blocked
campaign_blocked(CampaignID, "all_tasks_blocked") :-
    current_campaign(CampaignID),
    current_phase(PhaseID),
    !has_next_campaign_task(),
    has_incomplete_phase_task(PhaseID).

# -----------------------------------------------------------------------------
# 19.9 Autopoiesis During Campaign
# -----------------------------------------------------------------------------

# Track successful phase types for learning (Go runtime extracts from kernel)
phase_success_pattern(PhaseType) :-
    campaign_phase(PhaseID, CampaignID, PhaseName, Seq, /completed, Profile),
    phase_objective(PhaseID, PhaseType, Desc, Priority),
    phase_checkpoint(PhaseID, CheckpointID, /true, ValidatedAt, ValidatorShard).

# Learn from phase completion - promotes success pattern for phase type
promote_to_long_term(/phase_success, PhaseType) :-
    phase_success_pattern(PhaseType).

# Learn from task failures for future avoidance
campaign_learning(CampaignID, /failure_pattern, TaskType, ErrorMsg, Now) :-
    current_campaign(CampaignID),
    campaign_task(TaskID, _, _, /failed, TaskType),
    task_error(TaskID, _, ErrorMsg),
    current_time(Now).

# -----------------------------------------------------------------------------
# 19.10 Campaign-Aware Tool Permissions
# -----------------------------------------------------------------------------

# During campaigns, only permit tools in the phase's context profile
phase_tool_permitted(Tool) :-
    current_phase(PhaseID),
    campaign_phase(PhaseID, _, _, _, _, ContextProfile),
    context_profile(ContextProfile, _, RequiredTools, _),
    tool_in_list(Tool, RequiredTools).

# Block tools not in phase profile during active campaign
# (This is advisory - Go runtime can override for safety)
# Note: Tool is bound via tool_capabilities before negation check
tool_advisory_block(Tool, "not_in_phase_profile") :-
    current_campaign(_),
    current_phase(_),
    tool_capabilities(Tool, _),
    !phase_tool_permitted(Tool).

# =============================================================================
# SECTION 20: CAMPAIGN START TRIGGER
# =============================================================================

# Trigger campaign mode when user wants to start a campaign
active_strategy(/campaign_planning) :-
    user_intent(_, /mutation, /campaign, _, _).

# Alternative triggers for campaign-like requests
active_strategy(/campaign_planning) :-
    user_intent(_, /mutation, /build, Target, _),
    target_is_large(Target).

active_strategy(/campaign_planning) :-
    user_intent(_, /mutation, /implement, Target, _),
    target_is_complex(Target).

# Heuristics for complexity (implemented in Go builtins)
# target_is_large(Target) - true if target references multiple files/features
# target_is_complex(Target) - true if target requires multiple phases

# =============================================================================
# SECTION 21: SYSTEM SHARD COORDINATION
# =============================================================================
# Coordinates the 6 system shards: perception_firewall, executive_policy,
# constitution_gate, world_model_ingestor, tactile_router, session_planner.
# These are Type 1 (permanent/continuous) shards that form the OODA loop.

# -----------------------------------------------------------------------------
# 21.1 Intent Processing Flow (Perception → Executive)
# -----------------------------------------------------------------------------

# A user_intent is pending if not yet processed by executive
pending_intent(IntentID) :-
    user_intent(IntentID, _, _, _, _),
    !intent_processed(IntentID).

# Helper for safe negation
intent_processed(IntentID) :-
    processed_intent(IntentID).

# Focus needs resolution if confidence is low
focus_needs_resolution(Ref) :-
    focus_resolution(Ref, _, _, Score),
    Score < 0.70.

# Intent ready for executive processing
intent_ready_for_executive(IntentID) :-
    user_intent(IntentID, _, _, Target, _),
    !focus_needs_resolution(Target).

# -----------------------------------------------------------------------------
# 21.2 Action Flow (Executive → Constitution → Router)
# -----------------------------------------------------------------------------

# Action is pending permission check from constitution gate
action_pending_permission(ActionID) :-
    pending_permission_check(ActionID),
    !permission_checked(ActionID).

# Helper for safe negation
permission_checked(ActionID) :-
    permission_check_result(ActionID, _, _).

# Action is permitted by constitution gate
action_permitted(ActionID) :-
    permission_check_result(ActionID, /permit, _).

# Action is blocked by constitution gate
action_blocked(ActionID, Reason) :-
    permission_check_result(ActionID, /deny, Reason).

# Action ready for routing (permitted and not yet routed)
action_ready_for_routing(ActionID) :-
    action_permitted(ActionID),
    !action_routed(ActionID).

# Helper for safe negation
action_routed(ActionID) :-
    ready_for_routing(ActionID),
    routing_result(ActionID, _, _).

# Derive routing result success
routing_succeeded(ActionID) :-
    routing_result(ActionID, /success, _).

# Derive routing result failure
routing_failed(ActionID, Error) :-
    routing_result(ActionID, /failure, Error).

# -----------------------------------------------------------------------------
# 21.3 System Shard Health Monitoring
# -----------------------------------------------------------------------------

# System shard is healthy if heartbeat within threshold (30 seconds)
system_shard_healthy(ShardName) :-
    system_heartbeat(ShardName, Timestamp),
    current_time(Now),
    time_diff(Now, Timestamp, Diff),
    Diff < 30.

# Helper: check if shard has no recent heartbeat
shard_heartbeat_stale(ShardName) :-
    system_shard(ShardName, _),
    !system_shard_healthy(ShardName).

# Escalate if critical system shard is unhealthy
escalation_needed(/system_health, ShardName, "heartbeat_timeout") :-
    shard_heartbeat_stale(ShardName),
    system_startup(ShardName, /auto).

# System shards that must auto-start
system_startup(/perception_firewall, /auto).
system_startup(/executive_policy, /auto).
system_startup(/constitution_gate, /auto).
system_startup(/world_model_ingestor, /on_demand).
system_startup(/tactile_router, /on_demand).
system_startup(/session_planner, /on_demand).

# -----------------------------------------------------------------------------
# 21.4 Safety Violation Handling (Constitution Gate)
# -----------------------------------------------------------------------------

# A safety violation blocks all further actions
block_all_actions("safety_violation") :-
    safety_violation(_, _, _, _).

# Security anomaly triggers investigation
next_action(/investigate_anomaly) :-
    security_anomaly(_, _, _),
    !anomaly_investigated(_).

# Helper for safe negation
anomaly_investigated(AnomalyID) :-
    security_anomaly(AnomalyID, _, _),
    investigation_result(AnomalyID, _).

# Pattern recognition for repeated violations
repeated_violation_pattern(Pattern) :-
    safety_violation(_, Pattern, _, _),
    violation_count(Pattern, Count),
    Count >= 3.

# Propose rule when pattern detected (Autopoiesis)
propose_safety_rule(Pattern) :-
    repeated_violation_pattern(Pattern).

# -----------------------------------------------------------------------------
# 21.5 World Model Updates (World Model Ingestor)
# -----------------------------------------------------------------------------

# File change triggers world model update
world_model_stale(File) :-
    modified(File),
    file_topology(File, _, _, LastUpdate),
    current_time(Now),
    time_diff(Now, LastUpdate, Diff),
    Diff > 5.

# Trigger ingestor when world model is stale
next_action(/update_world_model) :-
    world_model_stale(_),
    system_shard_healthy(/world_model_ingestor).

# File topology derived from filesystem
file_in_project(File) :-
    file_topology(File, _, _, _).

# Symbol graph connectivity
symbol_reachable(From, To) :-
    symbol_graph(From, To, _).

symbol_reachable(From, To) :-
    symbol_graph(From, Mid, _),
    symbol_reachable(Mid, To).

# -----------------------------------------------------------------------------
# 21.6 Routing Table (Tactile Router)
# -----------------------------------------------------------------------------

# Default routing table entries (can be extended via Autopoiesis)
routing_table(/fs_read, /read_file, /low).
routing_table(/fs_write, /write_file, /medium).
routing_table(/exec_cmd, /execute_command, /high).
routing_table(/browser, /browser_action, /high).
routing_table(/code_graph, /analyze_code, /low).

# Tool is allowed for action type
tool_allowed(Tool, ActionType) :-
    routing_table(ActionType, Tool, _),
    tool_allowlist(Tool, _).

# Route action to appropriate tool
route_action(ActionID, Tool) :-
    action_ready_for_routing(ActionID),
    action_type(ActionID, ActionType),
    tool_allowed(Tool, ActionType).

# Routing blocked if no tool available
routing_blocked(ActionID, "no_tool_available") :-
    action_ready_for_routing(ActionID),
    action_type(ActionID, ActionType),
    !has_tool_for_action(ActionType).

# Helper for safe negation
has_tool_for_action(ActionType) :-
    tool_allowed(_, ActionType).

# -----------------------------------------------------------------------------
# 21.7 Session Planning (Session Planner)
# -----------------------------------------------------------------------------

# Agenda item is ready when dependencies complete
agenda_item_ready(ItemID) :-
    agenda_item(ItemID, _, _, /pending, _),
    !has_incomplete_dependency(ItemID).

# Helper for dependency checking
has_incomplete_dependency(ItemID) :-
    agenda_dependency(ItemID, DepID),
    agenda_item(DepID, _, _, Status, _),
    Status != /completed.

# Next agenda item: highest priority ready item
next_agenda_item(ItemID) :-
    agenda_item_ready(ItemID),
    !has_higher_priority_item(ItemID).

# Helper for priority ordering
has_higher_priority_item(ItemID) :-
    agenda_item(ItemID, _, Priority, _, _),
    agenda_item_ready(OtherID),
    OtherID != ItemID,
    agenda_item(OtherID, _, OtherPriority, _, _),
    OtherPriority > Priority.

# Checkpoint needed based on time or completion
checkpoint_due() :-
    last_checkpoint_time(LastTime),
    current_time(Now),
    time_diff(Now, LastTime, Diff),
    Diff > 600.

next_action(/create_checkpoint) :-
    checkpoint_due().

# Blocked item triggers escalation after retries
agenda_item_escalate(ItemID, "max_retries_exceeded") :-
    agenda_item(ItemID, _, _, /blocked, _),
    item_retry_count(ItemID, Count),
    Count >= 3.

escalation_needed(/session_planner, ItemID, Reason) :-
    agenda_item_escalate(ItemID, Reason).

# -----------------------------------------------------------------------------
# 21.8 On-Demand Shard Activation
# -----------------------------------------------------------------------------

# Activate world_model_ingestor when files change
activate_shard(/world_model_ingestor) :-
    modified(_),
    !system_shard_healthy(/world_model_ingestor).

# Activate tactile_router when actions are pending
activate_shard(/tactile_router) :-
    action_ready_for_routing(_),
    !system_shard_healthy(/tactile_router).

# Activate session_planner for campaigns or complex goals
activate_shard(/session_planner) :-
    current_campaign(_),
    !system_shard_healthy(/session_planner).

activate_shard(/session_planner) :-
    user_intent(_, _, /plan, _, _),
    !system_shard_healthy(/session_planner).

# -----------------------------------------------------------------------------
# 21.9 Autopoiesis Integration for System Shards
# -----------------------------------------------------------------------------

# Unhandled case tracking (for rule learning)
unhandled_case_count(ShardName, Count) :-
    system_shard(ShardName, _),
    unhandled_cases(ShardName, Cases),
    list_length(Cases, Count).

# Trigger LLM for rule proposal when threshold reached
propose_new_rule(ShardName) :-
    unhandled_case_count(ShardName, Count),
    Count >= 3.

# Proposed rule needs human approval if low confidence
rule_needs_approval(RuleID) :-
    proposed_rule(RuleID, _, _, Confidence),
    Confidence < 0.80.

# Auto-apply rule if high confidence
auto_apply_rule(RuleID) :-
    proposed_rule(RuleID, _, _, Confidence),
    Confidence >= 0.80,
    !rule_applied(RuleID).

# Helper for safe negation
rule_applied(RuleID) :-
    applied_rule(RuleID, _).

# Learn from successful rule applications
learning_signal(/rule_success, RuleID) :-
    applied_rule(RuleID, Timestamp),
    rule_outcome(RuleID, /success, _).

# -----------------------------------------------------------------------------
# 21.10 OODA Loop Coordination
# -----------------------------------------------------------------------------

# OODA phases: Observe → Orient → Decide → Act
ooda_phase(/observe) :-
    pending_intent(_),
    !intent_ready_for_executive(_).

ooda_phase(/orient) :-
    intent_ready_for_executive(_),
    !has_next_action().

ooda_phase(/decide) :-
    has_next_action(),
    !action_permitted(_).

ooda_phase(/act) :-
    action_ready_for_routing(_).

# Helper for OODA phase detection
has_next_action() :-
    next_action(_).

# Current OODA state for debugging/monitoring
current_ooda_phase(Phase) :-
    ooda_phase(Phase).

# OODA loop stalled detection
ooda_stalled(Reason) :-
    pending_intent(_),
    !has_next_action(),
    current_time(Now),
    last_action_time(LastTime),
    time_diff(Now, LastTime, Diff),
    Diff > 30,
    Reason = "no_action_derived".

# Escalate stalled OODA loop
escalation_needed(/ooda_loop, "stalled", Reason) :-
    ooda_stalled(Reason).
