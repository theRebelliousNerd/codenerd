# =============================================================================
# codeNERD Log Analysis Schema
# Complete Mangle schema for log-based debugging
# =============================================================================
#
# This schema defines the EDB (extensible database) declarations and IDB
# (intensional database) rules for analyzing codeNERD system logs.
#
# Usage:
#   1. Generate facts with parse_log.py: python parse_log.py .nerd/logs/*.log > facts.mg
#   2. Load this schema and facts: ::load log-schema.mg
#   3. Load facts: ::load facts.mg
#   4. Query: ?error_entry(Time, Category, Message).
#
# =============================================================================

# =============================================================================
# SECTION 1: CORE EDB DECLARATIONS
# =============================================================================

# Primary log entry fact - generated by parse_log.py
# log_entry(Timestamp_ms, Category, Level, Message, Filename, LineNumber)
Decl log_entry(
    Time.Type<int>,           # Unix timestamp in milliseconds
    Category.Type<name>,      # Log category (e.g., /kernel, /shards)
    Level.Type<name>,         # Log level (/debug, /info, /warn, /error)
    Message.Type<string>,     # Log message content
    File.Type<string>,        # Source filename
    Line.Type<int>            # Source line number
).

# =============================================================================
# SECTION 2: LEVEL FILTER PREDICATES
# =============================================================================

# Error entries only
Decl error_entry(Time.Type<int>, Category.Type<name>, Message.Type<string>).
error_entry(T, C, M) :- log_entry(T, C, /error, M, _, _).

# Warning entries only
Decl warning_entry(Time.Type<int>, Category.Type<name>, Message.Type<string>).
warning_entry(T, C, M) :- log_entry(T, C, /warn, M, _, _).

# Info entries only
Decl info_entry(Time.Type<int>, Category.Type<name>, Message.Type<string>).
info_entry(T, C, M) :- log_entry(T, C, /info, M, _, _).

# Debug entries only
Decl debug_entry(Time.Type<int>, Category.Type<name>, Message.Type<string>).
debug_entry(T, C, M) :- log_entry(T, C, /debug, M, _, _).

# =============================================================================
# SECTION 3: CATEGORY STATISTICS
# =============================================================================

# Category event stream (timestamp + level per category)
Decl category_event(Category.Type<name>, Time.Type<int>, Level.Type<name>).
category_event(C, T, L) :- log_entry(T, C, L, _, _, _).

# Entry count by category
Decl entry_count(Category.Type<name>, Count.Type<int>).
entry_count(C, N) :-
    log_entry(_, C, _, _, _, _) |>
    do fn:group_by(C),
    let N = fn:Count().

# Error count by category
Decl error_count(Category.Type<name>, Count.Type<int>).
error_count(C, N) :-
    error_entry(_, C, _) |>
    do fn:group_by(C),
    let N = fn:Count().

# Warning count by category
Decl warning_count(Category.Type<name>, Count.Type<int>).
warning_count(C, N) :-
    warning_entry(_, C, _) |>
    do fn:group_by(C),
    let N = fn:Count().

# Level distribution per category
Decl level_dist(Category.Type<name>, Level.Type<name>, Count.Type<int>).
level_dist(C, L, N) :-
    log_entry(_, C, L, _, _, _) |>
    do fn:group_by(C, L),
    let N = fn:Count().

# =============================================================================
# SECTION 4: TEMPORAL PREDICATES
# =============================================================================

# First entry per category (session start marker)
Decl first_entry(Category.Type<name>, Time.Type<int>).
first_entry(C, MinT) :-
    log_entry(T, C, _, _, _, _) |>
    do fn:group_by(C),
    let MinT = fn:Min(T).

# Last entry per category (most recent)
Decl last_entry(Category.Type<name>, Time.Type<int>).
last_entry(C, MaxT) :-
    log_entry(T, C, _, _, _, _) |>
    do fn:group_by(C),
    let MaxT = fn:Max(T).

# Session time range
Decl session_range(StartTime.Type<int>, EndTime.Type<int>, DurationMs.Type<int>).
session_range(MinT, MaxT, Duration) :-
    log_entry(T, _, _, _, _, _) |>
    let MinT = fn:Min(T),
    let MaxT = fn:Max(T),
    Duration = fn:minus(MaxT, MinT).

# =============================================================================
# SECTION 5: CORRELATION PREDICATES
# =============================================================================

# Events correlated within time window (100ms default)
Decl correlated(Time1.Type<int>, Cat1.Type<name>, Time2.Type<int>, Cat2.Type<name>).
correlated(T1, C1, T2, C2) :-
    log_entry(T1, C1, _, _, _, _),
    log_entry(T2, C2, _, _, _, _),
    C1 != C2,
    T2 > T1,
    fn:minus(T2, T1) < 100.

# Strongly correlated (within 50ms)
Decl strongly_correlated(Time1.Type<int>, Cat1.Type<name>, Time2.Type<int>, Cat2.Type<name>).
strongly_correlated(T1, C1, T2, C2) :-
    log_entry(T1, C1, _, _, _, _),
    log_entry(T2, C2, _, _, _, _),
    C1 != C2,
    T2 > T1,
    fn:minus(T2, T1) < 50.

# Category interaction count
Decl category_interaction(Cat1.Type<name>, Cat2.Type<name>, Count.Type<int>).
category_interaction(C1, C2, N) :-
    correlated(_, C1, _, C2) |>
    do fn:group_by(C1, C2),
    let N = fn:Count().

# =============================================================================
# SECTION 6: ERROR ANALYSIS PREDICATES
# =============================================================================

# Error context (events within 500ms before an error)
Decl error_context(
    ErrorTime.Type<int>,
    ErrorCat.Type<name>,
    PriorTime.Type<int>,
    PriorCat.Type<name>,
    PriorMsg.Type<string>
).
error_context(ET, EC, PT, PC, PM) :-
    error_entry(ET, EC, _),
    log_entry(PT, PC, _, PM, _, _),
    PT < ET,
    fn:minus(ET, PT) < 500.

# Error cascade detection (errors triggering other errors within 100ms)
Decl error_cascade(
    Error1Time.Type<int>,
    Error1Cat.Type<name>,
    Error2Time.Type<int>,
    Error2Cat.Type<name>
).
error_cascade(E1T, E1C, E2T, E2C) :-
    error_entry(E1T, E1C, _),
    error_entry(E2T, E2C, _),
    E2T > E1T,
    fn:minus(E2T, E1T) < 100.

# Root cause (first error in a cascade chain)
Decl root_cause(Time.Type<int>, Category.Type<name>, Message.Type<string>).
root_cause(T, C, M) :-
    error_entry(T, C, M),
    !error_cascade(_, _, T, C).

# First error per category
Decl first_error(Category.Type<name>, Time.Type<int>, Message.Type<string>).
first_error(C, MinT, M) :-
    error_entry(T, C, M) |>
    do fn:group_by(C),
    let MinT = fn:Min(T).

# Repeated error messages (potential loops)
Decl repeated_error(Message.Type<string>, Count.Type<int>).
repeated_error(M, N) :-
    error_entry(_, _, M) |>
    do fn:group_by(M),
    let N = fn:Count().

# =============================================================================
# SECTION 7: EXECUTION FLOW PREDICATES
# =============================================================================

# Sequential flow edges (consecutive events within 50ms)
Decl flow_edge(FromCat.Type<name>, ToCat.Type<name>, Time.Type<int>).
flow_edge(C1, C2, T2) :-
    log_entry(T1, C1, _, _, _, _),
    log_entry(T2, C2, _, _, _, _),
    C1 != C2,
    T2 > T1,
    fn:minus(T2, T1) < 50.

# Transitive reachability (can events in Cat1 eventually reach Cat2?)
Decl reachable(FromCat.Type<name>, ToCat.Type<name>).
reachable(C1, C2) :- flow_edge(C1, C2, _).
reachable(C1, C3) :- flow_edge(C1, C2, _), reachable(C2, C3).

# Flow frequency between categories
Decl flow_frequency(FromCat.Type<name>, ToCat.Type<name>, Count.Type<int>).
flow_frequency(C1, C2, N) :-
    flow_edge(C1, C2, _) |>
    do fn:group_by(C1, C2),
    let N = fn:Count().

# =============================================================================
# SECTION 8: ANOMALY DETECTION PREDICATES
# =============================================================================

# Categories with high error rate (>10%)
Decl high_error_rate(Category.Type<name>, ErrorRate.Type<int>).
high_error_rate(C, Rate) :-
    entry_count(C, Total),
    error_count(C, Errors),
    Total > 0,
    Rate = fn:div(fn:mult(Errors, 100), Total),
    Rate > 10.

# Event gaps (potential hangs - gaps > 5 seconds)
Decl event_gap(
    Time1.Type<int>,
    Cat1.Type<name>,
    Time2.Type<int>,
    Cat2.Type<name>,
    GapMs.Type<int>
).
event_gap(T1, C1, T2, C2, Gap) :-
    log_entry(T1, C1, _, _, _, _),
    log_entry(T2, C2, _, _, _, _),
    T2 > T1,
    Gap = fn:minus(T2, T1),
    Gap > 5000.

# Error bursts (>5 errors in 1 second)
Decl error_burst(BucketSec.Type<int>, Count.Type<int>).
error_burst(Bucket, N) :-
    error_entry(T, _, _),
    Bucket = fn:div(T, 1000) |>
    do fn:group_by(Bucket),
    let N = fn:Count(),
    N > 5.

# =============================================================================
# SECTION 9: CATEGORY-SPECIFIC PREDICATES
# =============================================================================

# Kernel events
Decl kernel_event(Time.Type<int>, Level.Type<name>, Message.Type<string>).
kernel_event(T, L, M) :- log_entry(T, /kernel, L, M, _, _).

# Shard events
Decl shard_event(Time.Type<int>, Level.Type<name>, Message.Type<string>).
shard_event(T, L, M) :- log_entry(T, /shards, L, M, _, _).

# Perception events
Decl perception_event(Time.Type<int>, Level.Type<name>, Message.Type<string>).
perception_event(T, L, M) :- log_entry(T, /perception, L, M, _, _).

# Articulation events
Decl articulation_event(Time.Type<int>, Level.Type<name>, Message.Type<string>).
articulation_event(T, L, M) :- log_entry(T, /articulation, L, M, _, _).

# API events
Decl api_event(Time.Type<int>, Level.Type<name>, Message.Type<string>).
api_event(T, L, M) :- log_entry(T, /api, L, M, _, _).

# Campaign events
Decl campaign_event(Time.Type<int>, Level.Type<name>, Message.Type<string>).
campaign_event(T, L, M) :- log_entry(T, /campaign, L, M, _, _).

# =============================================================================
# SECTION 10: SUMMARY PREDICATES
# =============================================================================

# Category summary with all stats
Decl category_summary(
    Category.Type<name>,
    Total.Type<int>,
    Errors.Type<int>,
    Warnings.Type<int>,
    FirstTime.Type<int>,
    LastTime.Type<int>
).
category_summary(C, Total, Errors, Warnings, First, Last) :-
    entry_count(C, Total),
    error_count(C, Errors),
    warning_count(C, Warnings),
    first_entry(C, First),
    last_entry(C, Last).

# Session health summary
Decl session_health(
    TotalEntries.Type<int>,
    TotalErrors.Type<int>,
    TotalWarnings.Type<int>,
    CategoryCount.Type<int>,
    DurationMs.Type<int>
).
session_health(Total, Errors, Warnings, CatCount, Duration) :-
    log_entry(_, _, _, _, _, _) |>
    let Total = fn:Count(),
    error_entry(_, _, _) |>
    let Errors = fn:Count(),
    warning_entry(_, _, _) |>
    let Warnings = fn:Count(),
    entry_count(_, _) |>
    let CatCount = fn:Count(),
    session_range(_, _, Duration).

# =============================================================================
# SECTION 11: STRUCTURED EVENT FACTS (for loop/anomaly detection)
# =============================================================================

# Tool execution start event (from tools.log)
Decl tool_execution_start(Time.Type<int>, ToolName.Type<string>, Action.Type<name>, Target.Type<string>, CallId.Type<string>).

# Tool execution complete event (from tools.log)
Decl tool_execution_complete(Time.Type<int>, ToolName.Type<string>, CallId.Type<string>, DurationMs.Type<int>, ResultLen.Type<int>).

# Action routing event (from virtual_store.log)
Decl action_routing(Time.Type<int>, Predicate.Type<name>, ArgCount.Type<int>).

# Action completion event (from virtual_store.log)
Decl action_completed(Time.Type<int>, Action.Type<name>, Success.Type<name>, OutputLen.Type<int>).

# API scheduler slot status (from shards.log)
Decl slot_status(Time.Type<int>, ShardId.Type<string>, Active.Type<int>, MaxSlots.Type<int>, Waiting.Type<int>).

# Slot acquisition event (from shards.log)
Decl slot_acquired(Time.Type<int>, ShardId.Type<string>, WaitDurationMs.Type<int>).

# =============================================================================
# SECTION 12: LOOP DETECTION PREDICATES
# =============================================================================

# Repeated call_id (same ID used multiple times = potential loop)
Decl repeated_call_id(CallId.Type<string>, Count.Type<int>, FirstTime.Type<int>, LastTime.Type<int>).
repeated_call_id(CID, N, FirstT, LastT) :-
    tool_execution_start(T, _, _, _, CID) |>
    do fn:group_by(CID),
    let N = fn:Count(),
    let FirstT = fn:Min(T),
    let LastT = fn:Max(T),
    N > 2.

# Action loop detection (same action executed repeatedly)
Decl action_loop(Action.Type<name>, Count.Type<int>, WindowMs.Type<int>, FirstTime.Type<int>, LastTime.Type<int>).
action_loop(Act, N, Window, FirstT, LastT) :-
    action_completed(T, Act, _, _) |>
    do fn:group_by(Act),
    let N = fn:Count(),
    let FirstT = fn:Min(T),
    let LastT = fn:Max(T),
    Window = fn:minus(LastT, FirstT),
    N > 5.

# =============================================================================
# SECTION 13: STATE STAGNATION DETECTION
# =============================================================================

# Routing stagnation (same predicate queried repeatedly)
Decl routing_stagnation(Predicate.Type<name>, Count.Type<int>, DurationMs.Type<int>).
routing_stagnation(Pred, N, Dur) :-
    action_routing(T, Pred, _) |>
    do fn:group_by(Pred),
    let N = fn:Count(),
    let FirstT = fn:Min(T),
    let LastT = fn:Max(T),
    Dur = fn:minus(LastT, FirstT),
    N > 10.

# =============================================================================
# SECTION 14: IDENTICAL RESULT DETECTION
# =============================================================================

# Suspicious result pattern (same result_len repeatedly)
Decl identical_results(Action.Type<name>, ResultLen.Type<int>, Count.Type<int>).
identical_results(Act, Len, N) :-
    action_completed(_, Act, /true, Len) |>
    do fn:group_by(Act, Len),
    let N = fn:Count(),
    N > 5.

# =============================================================================
# SECTION 15: SLOT STARVATION DETECTION
# =============================================================================

# Slot starvation (waiting count > 3)
Decl slot_starvation_event(ShardId.Type<string>, MaxWaiting.Type<int>, DurationMs.Type<int>).
slot_starvation_event(SID, MaxW, Dur) :-
    slot_status(T, SID, _, _, W) |>
    do fn:group_by(SID),
    let MaxW = fn:Max(W),
    let FirstT = fn:Min(T),
    let LastT = fn:Max(T),
    Dur = fn:minus(LastT, FirstT),
    MaxW > 3.

# Long slot wait (>10 seconds)
Decl long_slot_wait(ShardId.Type<string>, WaitDurationMs.Type<int>).
long_slot_wait(SID, Wait) :-
    slot_acquired(_, SID, Wait),
    Wait > 10000.

# =============================================================================
# SECTION 16: SUCCESS MASKING FAILURE DETECTION
# =============================================================================

# False success (success=true but same action loops)
Decl false_success_loop(Action.Type<name>, SuccessCount.Type<int>, LoopDurationMs.Type<int>).
false_success_loop(Act, N, Dur) :-
    action_loop(Act, N, Dur, _, _),
    action_completed(_, Act, /true, _).

# Combined anomaly severity
Decl loop_anomaly(Action.Type<name>, Severity.Type<name>, Evidence.Type<string>).
loop_anomaly(Act, /critical, "repeated_call_id") :-
    repeated_call_id(CID, N, _, _), N > 10,
    tool_execution_start(_, _, Act, _, CID).
loop_anomaly(Act, /critical, "action_loop") :-
    action_loop(Act, N, _, _, _), N > 20.
loop_anomaly(Act, /high, "identical_results") :-
    identical_results(Act, _, N), N > 10.
loop_anomaly(Act, /high, "false_success") :-
    false_success_loop(Act, _, _).

# =============================================================================
# SECTION 17: ROOT CAUSE DIAGNOSIS
# =============================================================================

# Kernel fact assertion tracking
Decl kernel_fact_asserted(Time.Type<int>, FactType.Type<string>).
kernel_fact_asserted(T, M) :-
    log_entry(T, /kernel, _, M, _, _),
    :string_contains(M, "Asserting").

# Check if fact was asserted within window after time T
Decl kernel_fact_asserted_after(ActionTime.Type<int>, WindowMs.Type<int>).
kernel_fact_asserted_after(AT, Window) :-
    kernel_fact_asserted(FT, _),
    FT > AT,
    fn:minus(FT, AT) < Window.

# Missing state update (no fact assertion after action)
Decl missing_state_update(ActionTime.Type<int>, Action.Type<name>).
missing_state_update(AT, Act) :-
    action_completed(AT, Act, /true, _),
    !kernel_fact_asserted_after(AT, 500).

# Root cause diagnosis
Decl loop_root_cause(Action.Type<name>, Cause.Type<name>, Evidence.Type<string>).

# Cause 1: No fact assertion after action
loop_root_cause(Act, /missing_fact_update, "action completes but no kernel fact asserted") :-
    action_loop(Act, _, _, _, _),
    missing_state_update(_, Act).

# Cause 2: Same next_action derived repeatedly (kernel rule issue)
loop_root_cause(Act, /kernel_rule_stuck, "next_action derives same result") :-
    action_loop(Act, N, _, _, _),
    routing_stagnation(/next_action, N2, _),
    N2 > 5.

# Cause 3: Tool returning cached/dummy response
loop_root_cause(Act, /tool_caching, "tool returns identical result every time") :-
    action_loop(Act, _, _, _, _),
    identical_results(Act, _, N),
    N > 5.

# Cause 4: Slot starvation blocking state updates
loop_root_cause(Act, /slot_starvation, "API slots exhausted during loop") :-
    action_loop(Act, _, _, _, _),
    slot_starvation_event(_, _, Dur),
    Dur > 10000.

# Full diagnosis report
Decl loop_diagnosis(Action.Type<name>, LoopCount.Type<int>, DurationMs.Type<int>, RootCause.Type<name>, Severity.Type<name>).
loop_diagnosis(Act, N, Dur, Cause, Sev) :-
    action_loop(Act, N, Dur, _, _),
    loop_root_cause(Act, Cause, _),
    loop_anomaly(Act, Sev, _).

# =============================================================================
# END OF SCHEMA
# =============================================================================
