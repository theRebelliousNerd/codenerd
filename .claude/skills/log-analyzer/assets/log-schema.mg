# =============================================================================
# codeNERD Log Analysis Schema
# Complete Mangle schema for log-based debugging
# =============================================================================
#
# This schema defines the EDB (extensible database) declarations and IDB
# (intensional database) rules for analyzing codeNERD system logs.
#
# Usage:
#   1. Generate facts with parse_log.py: python parse_log.py .nerd/logs/*.log > facts.mg
#   2. Load this schema and facts: ::load log-schema.mg
#   3. Load facts: ::load facts.mg
#   4. Query: ?error_entry(Time, Category, Message).
#
# =============================================================================

# =============================================================================
# SECTION 1: CORE EDB DECLARATIONS
# =============================================================================

# Primary log entry fact - generated by parse_log.py
# log_entry(Timestamp_ms, Category, Level, Message, Filename, LineNumber)
Decl log_entry(
    Time.Type<int>,           # Unix timestamp in milliseconds
    Category.Type<name>,      # Log category (e.g., /kernel, /shards)
    Level.Type<name>,         # Log level (/debug, /info, /warn, /error)
    Message.Type<string>,     # Log message content
    File.Type<string>,        # Source filename
    Line.Type<int>            # Source line number
).

# =============================================================================
# SECTION 2: LEVEL FILTER PREDICATES
# =============================================================================

# Error entries only
Decl error_entry(Time.Type<int>, Category.Type<name>, Message.Type<string>).
error_entry(T, C, M) :- log_entry(T, C, /error, M, _, _).

# Warning entries only
Decl warning_entry(Time.Type<int>, Category.Type<name>, Message.Type<string>).
warning_entry(T, C, M) :- log_entry(T, C, /warn, M, _, _).

# Info entries only
Decl info_entry(Time.Type<int>, Category.Type<name>, Message.Type<string>).
info_entry(T, C, M) :- log_entry(T, C, /info, M, _, _).

# Debug entries only
Decl debug_entry(Time.Type<int>, Category.Type<name>, Message.Type<string>).
debug_entry(T, C, M) :- log_entry(T, C, /debug, M, _, _).

# =============================================================================
# SECTION 3: CATEGORY STATISTICS
# =============================================================================

# Category event stream (timestamp + level per category)
Decl category_event(Category.Type<name>, Time.Type<int>, Level.Type<name>).
category_event(C, T, L) :- log_entry(T, C, L, _, _, _).

# Entry count by category
Decl entry_count(Category.Type<name>, Count.Type<int>).
entry_count(C, N) :-
    log_entry(_, C, _, _, _, _) |>
    do fn:group_by(C),
    let N = fn:Count().

# Error count by category
Decl error_count(Category.Type<name>, Count.Type<int>).
error_count(C, N) :-
    error_entry(_, C, _) |>
    do fn:group_by(C),
    let N = fn:Count().

# Warning count by category
Decl warning_count(Category.Type<name>, Count.Type<int>).
warning_count(C, N) :-
    warning_entry(_, C, _) |>
    do fn:group_by(C),
    let N = fn:Count().

# Level distribution per category
Decl level_dist(Category.Type<name>, Level.Type<name>, Count.Type<int>).
level_dist(C, L, N) :-
    log_entry(_, C, L, _, _, _) |>
    do fn:group_by(C, L),
    let N = fn:Count().

# =============================================================================
# SECTION 4: TEMPORAL PREDICATES
# =============================================================================

# First entry per category (session start marker)
Decl first_entry(Category.Type<name>, Time.Type<int>).
first_entry(C, MinT) :-
    log_entry(T, C, _, _, _, _) |>
    do fn:group_by(C),
    let MinT = fn:Min(T).

# Last entry per category (most recent)
Decl last_entry(Category.Type<name>, Time.Type<int>).
last_entry(C, MaxT) :-
    log_entry(T, C, _, _, _, _) |>
    do fn:group_by(C),
    let MaxT = fn:Max(T).

# Session time range
Decl session_range(StartTime.Type<int>, EndTime.Type<int>, DurationMs.Type<int>).
session_range(MinT, MaxT, Duration) :-
    log_entry(T, _, _, _, _, _) |>
    let MinT = fn:Min(T),
    let MaxT = fn:Max(T),
    Duration = fn:minus(MaxT, MinT).

# =============================================================================
# SECTION 5: CORRELATION PREDICATES
# =============================================================================

# Events correlated within time window (100ms default)
Decl correlated(Time1.Type<int>, Cat1.Type<name>, Time2.Type<int>, Cat2.Type<name>).
correlated(T1, C1, T2, C2) :-
    log_entry(T1, C1, _, _, _, _),
    log_entry(T2, C2, _, _, _, _),
    C1 != C2,
    T2 > T1,
    fn:minus(T2, T1) < 100.

# Strongly correlated (within 50ms)
Decl strongly_correlated(Time1.Type<int>, Cat1.Type<name>, Time2.Type<int>, Cat2.Type<name>).
strongly_correlated(T1, C1, T2, C2) :-
    log_entry(T1, C1, _, _, _, _),
    log_entry(T2, C2, _, _, _, _),
    C1 != C2,
    T2 > T1,
    fn:minus(T2, T1) < 50.

# Category interaction count
Decl category_interaction(Cat1.Type<name>, Cat2.Type<name>, Count.Type<int>).
category_interaction(C1, C2, N) :-
    correlated(_, C1, _, C2) |>
    do fn:group_by(C1, C2),
    let N = fn:Count().

# =============================================================================
# SECTION 6: ERROR ANALYSIS PREDICATES
# =============================================================================

# Error context (events within 500ms before an error)
Decl error_context(
    ErrorTime.Type<int>,
    ErrorCat.Type<name>,
    PriorTime.Type<int>,
    PriorCat.Type<name>,
    PriorMsg.Type<string>
).
error_context(ET, EC, PT, PC, PM) :-
    error_entry(ET, EC, _),
    log_entry(PT, PC, _, PM, _, _),
    PT < ET,
    fn:minus(ET, PT) < 500.

# Error cascade detection (errors triggering other errors within 100ms)
Decl error_cascade(
    Error1Time.Type<int>,
    Error1Cat.Type<name>,
    Error2Time.Type<int>,
    Error2Cat.Type<name>
).
error_cascade(E1T, E1C, E2T, E2C) :-
    error_entry(E1T, E1C, _),
    error_entry(E2T, E2C, _),
    E2T > E1T,
    fn:minus(E2T, E1T) < 100.

# Root cause (first error in a cascade chain)
Decl root_cause(Time.Type<int>, Category.Type<name>, Message.Type<string>).
root_cause(T, C, M) :-
    error_entry(T, C, M),
    !error_cascade(_, _, T, C).

# First error per category
Decl first_error(Category.Type<name>, Time.Type<int>, Message.Type<string>).
first_error(C, MinT, M) :-
    error_entry(T, C, M) |>
    do fn:group_by(C),
    let MinT = fn:Min(T).

# Repeated error messages (potential loops)
Decl repeated_error(Message.Type<string>, Count.Type<int>).
repeated_error(M, N) :-
    error_entry(_, _, M) |>
    do fn:group_by(M),
    let N = fn:Count().

# =============================================================================
# SECTION 7: EXECUTION FLOW PREDICATES
# =============================================================================

# Sequential flow edges (consecutive events within 50ms)
Decl flow_edge(FromCat.Type<name>, ToCat.Type<name>, Time.Type<int>).
flow_edge(C1, C2, T2) :-
    log_entry(T1, C1, _, _, _, _),
    log_entry(T2, C2, _, _, _, _),
    C1 != C2,
    T2 > T1,
    fn:minus(T2, T1) < 50.

# Transitive reachability (can events in Cat1 eventually reach Cat2?)
Decl reachable(FromCat.Type<name>, ToCat.Type<name>).
reachable(C1, C2) :- flow_edge(C1, C2, _).
reachable(C1, C3) :- flow_edge(C1, C2, _), reachable(C2, C3).

# Flow frequency between categories
Decl flow_frequency(FromCat.Type<name>, ToCat.Type<name>, Count.Type<int>).
flow_frequency(C1, C2, N) :-
    flow_edge(C1, C2, _) |>
    do fn:group_by(C1, C2),
    let N = fn:Count().

# =============================================================================
# SECTION 8: ANOMALY DETECTION PREDICATES
# =============================================================================

# Categories with high error rate (>10%)
Decl high_error_rate(Category.Type<name>, ErrorRate.Type<int>).
high_error_rate(C, Rate) :-
    entry_count(C, Total),
    error_count(C, Errors),
    Total > 0,
    Rate = fn:div(fn:mult(Errors, 100), Total),
    Rate > 10.

# Event gaps (potential hangs - gaps > 5 seconds)
Decl event_gap(
    Time1.Type<int>,
    Cat1.Type<name>,
    Time2.Type<int>,
    Cat2.Type<name>,
    GapMs.Type<int>
).
event_gap(T1, C1, T2, C2, Gap) :-
    log_entry(T1, C1, _, _, _, _),
    log_entry(T2, C2, _, _, _, _),
    T2 > T1,
    Gap = fn:minus(T2, T1),
    Gap > 5000.

# Error bursts (>5 errors in 1 second)
Decl error_burst(BucketSec.Type<int>, Count.Type<int>).
error_burst(Bucket, N) :-
    error_entry(T, _, _),
    Bucket = fn:div(T, 1000) |>
    do fn:group_by(Bucket),
    let N = fn:Count(),
    N > 5.

# =============================================================================
# SECTION 9: CATEGORY-SPECIFIC PREDICATES
# =============================================================================

# Kernel events
Decl kernel_event(Time.Type<int>, Level.Type<name>, Message.Type<string>).
kernel_event(T, L, M) :- log_entry(T, /kernel, L, M, _, _).

# Shard events
Decl shard_event(Time.Type<int>, Level.Type<name>, Message.Type<string>).
shard_event(T, L, M) :- log_entry(T, /shards, L, M, _, _).

# Perception events
Decl perception_event(Time.Type<int>, Level.Type<name>, Message.Type<string>).
perception_event(T, L, M) :- log_entry(T, /perception, L, M, _, _).

# Articulation events
Decl articulation_event(Time.Type<int>, Level.Type<name>, Message.Type<string>).
articulation_event(T, L, M) :- log_entry(T, /articulation, L, M, _, _).

# API events
Decl api_event(Time.Type<int>, Level.Type<name>, Message.Type<string>).
api_event(T, L, M) :- log_entry(T, /api, L, M, _, _).

# Campaign events
Decl campaign_event(Time.Type<int>, Level.Type<name>, Message.Type<string>).
campaign_event(T, L, M) :- log_entry(T, /campaign, L, M, _, _).

# =============================================================================
# SECTION 10: SUMMARY PREDICATES
# =============================================================================

# Category summary with all stats
Decl category_summary(
    Category.Type<name>,
    Total.Type<int>,
    Errors.Type<int>,
    Warnings.Type<int>,
    FirstTime.Type<int>,
    LastTime.Type<int>
).
category_summary(C, Total, Errors, Warnings, First, Last) :-
    entry_count(C, Total),
    error_count(C, Errors),
    warning_count(C, Warnings),
    first_entry(C, First),
    last_entry(C, Last).

# Session health summary
Decl session_health(
    TotalEntries.Type<int>,
    TotalErrors.Type<int>,
    TotalWarnings.Type<int>,
    CategoryCount.Type<int>,
    DurationMs.Type<int>
).
session_health(Total, Errors, Warnings, CatCount, Duration) :-
    log_entry(_, _, _, _, _, _) |>
    let Total = fn:Count(),
    error_entry(_, _, _) |>
    let Errors = fn:Count(),
    warning_entry(_, _, _) |>
    let Warnings = fn:Count(),
    entry_count(_, _) |>
    let CatCount = fn:Count(),
    session_range(_, _, Duration).

# =============================================================================
# END OF SCHEMA
# =============================================================================
