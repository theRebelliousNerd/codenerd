# =============================================================================
# codeNERD Log Analysis Schema
# Complete Mangle schema for log-based debugging
# =============================================================================
#
# This schema defines the EDB (extensible database) declarations and IDB
# (intensional database) rules for analyzing codeNERD system logs.
#
# Usage:
#   1. Generate facts with parse_log.py: python parse_log.py .nerd/logs/*.log > facts.mg
#   2. Load this schema and facts: ::load log-schema.mg
#   3. Load facts: ::load facts.mg
#   4. Query: ?error_entry(Time, Category, Message).
#
# =============================================================================

# =============================================================================
# SECTION 1: CORE EDB DECLARATIONS
# =============================================================================

# Primary log entry fact - generated by parse_log.py
# log_entry(Timestamp_ms, Category, Level, Message, Filename, LineNumber)
Decl log_entry(Time, Category, Level, Message, File, Line)
    bound [/number, /name, /name, /string, /string, /number].

# =============================================================================
# SECTION 2: LEVEL FILTER PREDICATES
# =============================================================================

# Error entries only
Decl error_entry(Time, Category, Message) bound [/number, /name, /string].
error_entry(T, C, M) :- log_entry(T, C, /error, M, _, _).

# Warning entries only
Decl warning_entry(Time, Category, Message) bound [/number, /name, /string].
warning_entry(T, C, M) :- log_entry(T, C, /warn, M, _, _).

# Info entries only
Decl info_entry(Time, Category, Message) bound [/number, /name, /string].
info_entry(T, C, M) :- log_entry(T, C, /info, M, _, _).

# Debug entries only
Decl debug_entry(Time, Category, Message) bound [/number, /name, /string].
debug_entry(T, C, M) :- log_entry(T, C, /debug, M, _, _).

# =============================================================================
# SECTION 3: CATEGORY STATISTICS
# =============================================================================

# Category event stream (timestamp + level per category)
Decl category_event(Category, Time, Level) bound [/name, /number, /name].
category_event(C, T, L) :- log_entry(T, C, L, _, _, _).

# Entry count by category
Decl entry_count(Category, Count) bound [/name, /number].
entry_count(C, N) :-
    log_entry(_, C, _, _, _, _) |>
    do fn:group_by(C),
    let N = fn:count().

# Error count by category
Decl error_count(Category, Count) bound [/name, /number].
error_count(C, N) :-
    error_entry(_, C, _) |>
    do fn:group_by(C),
    let N = fn:count().

# Warning count by category
Decl warning_count(Category, Count) bound [/name, /number].
warning_count(C, N) :-
    warning_entry(_, C, _) |>
    do fn:group_by(C),
    let N = fn:count().

# Level distribution per category
Decl level_dist(Category, Level, Count) bound [/name, /name, /number].
level_dist(C, L, N) :-
    log_entry(_, C, L, _, _, _) |>
    do fn:group_by(C, L),
    let N = fn:count().

# =============================================================================
# SECTION 4: TEMPORAL PREDICATES
# =============================================================================

# First entry per category (session start marker)
Decl first_entry(Category, Time) bound [/name, /number].
first_entry(C, MinT) :-
    log_entry(T, C, _, _, _, _) |>
    do fn:group_by(C),
    let MinT = fn:min(T).

# Last entry per category (most recent)
Decl last_entry(Category, Time) bound [/name, /number].
last_entry(C, MaxT) :-
    log_entry(T, C, _, _, _, _) |>
    do fn:group_by(C),
    let MaxT = fn:max(T).

# Session time range (helper aggregation)
Decl session_time_bounds(MinTime, MaxTime) bound [/number, /number].
session_time_bounds(MinT, MaxT) :-
    log_entry(T, _, _, _, _, _) |>
    let MinT = fn:min(T),
    let MaxT = fn:max(T).

# Session range with duration
Decl session_range(StartTime, EndTime, DurationMs) bound [/number, /number, /number].
session_range(MinT, MaxT, Duration) :-
    session_time_bounds(MinT, MaxT) |>
    let Duration = fn:minus(MaxT, MinT).

# =============================================================================
# SECTION 5: CORRELATION PREDICATES
# =============================================================================

# Events correlated within time window (100ms default)
Decl correlated(Time1, Cat1, Time2, Cat2) bound [/number, /name, /number, /name].
correlated(T1, C1, T2, C2) :-
    log_entry(T1, C1, _, _, _, _),
    log_entry(T2, C2, _, _, _, _),
    C1 != C2,
    T2 > T1,
    fn:minus(T2, T1) < 100.

# Strongly correlated (within 50ms)
Decl strongly_correlated(Time1, Cat1, Time2, Cat2) bound [/number, /name, /number, /name].
strongly_correlated(T1, C1, T2, C2) :-
    log_entry(T1, C1, _, _, _, _),
    log_entry(T2, C2, _, _, _, _),
    C1 != C2,
    T2 > T1,
    fn:minus(T2, T1) < 50.

# Category interaction count
Decl category_interaction(Cat1, Cat2, Count) bound [/name, /name, /number].
category_interaction(C1, C2, N) :-
    correlated(_, C1, _, C2) |>
    do fn:group_by(C1, C2),
    let N = fn:count().

# =============================================================================
# SECTION 6: ERROR ANALYSIS PREDICATES
# =============================================================================

# Error context (events within 500ms before an error)
Decl error_context(ErrorTime, ErrorCat, PriorTime, PriorCat, PriorMsg)
    bound [/number, /name, /number, /name, /string].
error_context(ET, EC, PT, PC, PM) :-
    error_entry(ET, EC, _),
    log_entry(PT, PC, _, PM, _, _),
    PT < ET,
    fn:minus(ET, PT) < 500.

# Error cascade detection (errors triggering other errors within 100ms)
Decl error_cascade(Error1Time, Error1Cat, Error2Time, Error2Cat)
    bound [/number, /name, /number, /name].
error_cascade(E1T, E1C, E2T, E2C) :-
    error_entry(E1T, E1C, _),
    error_entry(E2T, E2C, _),
    E2T > E1T,
    fn:minus(E2T, E1T) < 100.

# Root cause (first error in a cascade chain)
Decl root_cause(Time, Category, Message) bound [/number, /name, /string].
root_cause(T, C, M) :-
    error_entry(T, C, M),
    !error_cascade(_, _, T, C).

# First error per category
Decl first_error(Category, Time, Message) bound [/name, /number, /string].
first_error(C, MinT, M) :-
    error_entry(T, C, M) |>
    do fn:group_by(C),
    let MinT = fn:min(T).

# Repeated error messages (potential loops)
Decl repeated_error(Message, Count) bound [/string, /number].
repeated_error(M, N) :-
    error_entry(_, _, M) |>
    do fn:group_by(M),
    let N = fn:count().

# =============================================================================
# SECTION 7: EXECUTION FLOW PREDICATES
# =============================================================================

# Sequential flow edges (consecutive events within 50ms)
Decl flow_edge(FromCat, ToCat, Time) bound [/name, /name, /number].
flow_edge(C1, C2, T2) :-
    log_entry(T1, C1, _, _, _, _),
    log_entry(T2, C2, _, _, _, _),
    C1 != C2,
    T2 > T1,
    fn:minus(T2, T1) < 50.

# Transitive reachability (can events in Cat1 eventually reach Cat2?)
Decl reachable(FromCat, ToCat) bound [/name, /name].
reachable(C1, C2) :- flow_edge(C1, C2, _).
reachable(C1, C3) :- flow_edge(C1, C2, _), reachable(C2, C3).

# Flow frequency between categories
Decl flow_frequency(FromCat, ToCat, Count) bound [/name, /name, /number].
flow_frequency(C1, C2, N) :-
    flow_edge(C1, C2, _) |>
    do fn:group_by(C1, C2),
    let N = fn:count().

# =============================================================================
# SECTION 8: ANOMALY DETECTION PREDICATES
# =============================================================================

# Error rate per category (intermediate)
Decl error_rate_raw(Category, Rate) bound [/name, /number].
error_rate_raw(C, Rate) :-
    entry_count(C, Total),
    error_count(C, Errors),
    Total > 0 |>
    let Rate = fn:div(fn:mult(Errors, 100), Total).

# Categories with high error rate (>10%)
Decl high_error_rate(Category, ErrorRate) bound [/name, /number].
high_error_rate(C, Rate) :-
    error_rate_raw(C, Rate),
    Rate > 10.

# Event gap detection (intermediate - computes all gaps)
Decl event_gap_raw(Time1, Cat1, Time2, Cat2, GapMs)
    bound [/number, /name, /number, /name, /number].
event_gap_raw(T1, C1, T2, C2, Gap) :-
    log_entry(T1, C1, _, _, _, _),
    log_entry(T2, C2, _, _, _, _),
    T2 > T1 |>
    let Gap = fn:minus(T2, T1).

# Event gaps (potential hangs - gaps > 5 seconds)
Decl event_gap(Time1, Cat1, Time2, Cat2, GapMs)
    bound [/number, /name, /number, /name, /number].
event_gap(T1, C1, T2, C2, Gap) :-
    event_gap_raw(T1, C1, T2, C2, Gap),
    Gap > 5000.

# Error entry with bucket (intermediate for aggregation)
Decl error_entry_bucket(Time, BucketSec) bound [/number, /number].
error_entry_bucket(T, Bucket) :-
    error_entry(T, _, _) |>
    let Bucket = fn:div(T, 1000).

# Error burst aggregation (count per second)
Decl error_burst_raw(BucketSec, Count) bound [/number, /number].
error_burst_raw(Bucket, N) :-
    error_entry_bucket(_, Bucket) |>
    do fn:group_by(Bucket),
    let N = fn:count().

# Error bursts (>5 errors in 1 second)
Decl error_burst(BucketSec, Count) bound [/number, /number].
error_burst(Bucket, N) :- error_burst_raw(Bucket, N), N > 5.

# =============================================================================
# SECTION 9: CATEGORY-SPECIFIC PREDICATES
# =============================================================================

# Kernel events
Decl kernel_event(Time, Level, Message) bound [/number, /name, /string].
kernel_event(T, L, M) :- log_entry(T, /kernel, L, M, _, _).

# Shard events
Decl shard_event(Time, Level, Message) bound [/number, /name, /string].
shard_event(T, L, M) :- log_entry(T, /shards, L, M, _, _).

# Perception events
Decl perception_event(Time, Level, Message) bound [/number, /name, /string].
perception_event(T, L, M) :- log_entry(T, /perception, L, M, _, _).

# Articulation events
Decl articulation_event(Time, Level, Message) bound [/number, /name, /string].
articulation_event(T, L, M) :- log_entry(T, /articulation, L, M, _, _).

# API events
Decl api_event(Time, Level, Message) bound [/number, /name, /string].
api_event(T, L, M) :- log_entry(T, /api, L, M, _, _).

# Campaign events
Decl campaign_event(Time, Level, Message) bound [/number, /name, /string].
campaign_event(T, L, M) :- log_entry(T, /campaign, L, M, _, _).

# =============================================================================
# SECTION 10: SUMMARY PREDICATES
# =============================================================================

# Category summary with all stats
Decl category_summary(Category, Total, Errors, Warnings, FirstTime, LastTime)
    bound [/name, /number, /number, /number, /number, /number].
category_summary(C, Total, Errors, Warnings, First, Last) :-
    entry_count(C, Total),
    error_count(C, Errors),
    warning_count(C, Warnings),
    first_entry(C, First),
    last_entry(C, Last).

# Session health helpers
Decl total_entries(Count) bound [/number].
total_entries(Total) :- entry_count(_, N) |> let Total = fn:sum(N).

Decl total_errors(Count) bound [/number].
total_errors(Total) :- error_count(_, N) |> let Total = fn:sum(N).

Decl total_warnings(Count) bound [/number].
total_warnings(Total) :- warning_count(_, N) |> let Total = fn:sum(N).

Decl category_count(Count) bound [/number].
category_count(N) :- entry_count(_, _) |> let N = fn:count().

# Session health - computed from aggregated predicates
Decl session_health(TotalEntries, TotalErrors, TotalWarnings, CategoryCount, DurationMs)
    bound [/number, /number, /number, /number, /number].
session_health(Total, Errors, Warnings, CatCount, Duration) :-
    total_entries(Total),
    total_errors(Errors),
    total_warnings(Warnings),
    category_count(CatCount),
    session_range(_, _, Duration).

# =============================================================================
# SECTION 11: STRUCTURED EVENT FACTS (for loop/anomaly detection)
# =============================================================================

# Tool execution start event (from tools.log)
Decl tool_execution_start(Time, ToolName, Action, Target, CallId)
    bound [/number, /string, /name, /string, /string].

# Tool execution complete event (from tools.log)
Decl tool_execution_complete(Time, ToolName, CallId, DurationMs, ResultLen)
    bound [/number, /string, /string, /number, /number].

# Action routing event (from virtual_store.log)
Decl action_routing(Time, Predicate, ArgCount) bound [/number, /name, /number].

# Action completion event (from virtual_store.log)
Decl action_completed(Time, Action, Success, OutputLen) bound [/number, /name, /name, /number].

# API scheduler slot status (from shards.log)
Decl slot_status(Time, ShardId, Active, MaxSlots, Waiting)
    bound [/number, /string, /number, /number, /number].

# Slot acquisition event (from shards.log)
Decl slot_acquired(Time, ShardId, WaitDurationMs) bound [/number, /string, /number].

# =============================================================================
# SECTION 12: LOOP DETECTION PREDICATES
# =============================================================================

# Repeated call_id aggregation
Decl repeated_call_id_raw(CallId, Count, FirstTime, LastTime)
    bound [/string, /number, /number, /number].
repeated_call_id_raw(CID, N, FirstT, LastT) :-
    tool_execution_start(T, _, _, _, CID) |>
    do fn:group_by(CID),
    let N = fn:count(),
    let FirstT = fn:min(T),
    let LastT = fn:max(T).

# Repeated call_id (same ID used multiple times = potential loop)
Decl repeated_call_id(CallId, Count, FirstTime, LastTime)
    bound [/string, /number, /number, /number].
repeated_call_id(CID, N, FirstT, LastT) :-
    repeated_call_id_raw(CID, N, FirstT, LastT), N > 2.

# Action loop aggregation
Decl action_loop_raw(Action, Count, FirstTime, LastTime)
    bound [/name, /number, /number, /number].
action_loop_raw(Act, N, FirstT, LastT) :-
    action_completed(T, Act, _, _) |>
    do fn:group_by(Act),
    let N = fn:count(),
    let FirstT = fn:min(T),
    let LastT = fn:max(T).

# Action loop detection (same action executed repeatedly)
Decl action_loop(Action, Count, WindowMs, FirstTime, LastTime)
    bound [/name, /number, /number, /number, /number].
action_loop(Act, N, Window, FirstT, LastT) :-
    action_loop_raw(Act, N, FirstT, LastT),
    N > 5 |>
    let Window = fn:minus(LastT, FirstT).

# =============================================================================
# SECTION 13: STATE STAGNATION DETECTION
# =============================================================================

# Routing stagnation aggregation
Decl routing_stagnation_raw(Predicate, Count, FirstTime, LastTime)
    bound [/name, /number, /number, /number].
routing_stagnation_raw(Pred, N, FirstT, LastT) :-
    action_routing(T, Pred, _) |>
    do fn:group_by(Pred),
    let N = fn:count(),
    let FirstT = fn:min(T),
    let LastT = fn:max(T).

# Routing stagnation (same predicate queried repeatedly)
Decl routing_stagnation(Predicate, Count, DurationMs) bound [/name, /number, /number].
routing_stagnation(Pred, N, Dur) :-
    routing_stagnation_raw(Pred, N, FirstT, LastT),
    N > 10 |>
    let Dur = fn:minus(LastT, FirstT).

# =============================================================================
# SECTION 14: IDENTICAL RESULT DETECTION
# =============================================================================

# Identical results aggregation
Decl identical_results_raw(Action, ResultLen, Count) bound [/name, /number, /number].
identical_results_raw(Act, Len, N) :-
    action_completed(_, Act, /true, Len) |>
    do fn:group_by(Act, Len),
    let N = fn:count().

# Suspicious result pattern (same result_len repeatedly)
Decl identical_results(Action, ResultLen, Count) bound [/name, /number, /number].
identical_results(Act, Len, N) :- identical_results_raw(Act, Len, N), N > 5.

# =============================================================================
# SECTION 15: SLOT STARVATION DETECTION
# =============================================================================

# Slot starvation aggregation
Decl slot_starvation_raw(ShardId, MaxWaiting, FirstTime, LastTime)
    bound [/string, /number, /number, /number].
slot_starvation_raw(SID, MaxW, FirstT, LastT) :-
    slot_status(T, SID, _, _, W) |>
    do fn:group_by(SID),
    let MaxW = fn:max(W),
    let FirstT = fn:min(T),
    let LastT = fn:max(T).

# Slot starvation (waiting count > 3)
Decl slot_starvation_event(ShardId, MaxWaiting, DurationMs) bound [/string, /number, /number].
slot_starvation_event(SID, MaxW, Dur) :-
    slot_starvation_raw(SID, MaxW, FirstT, LastT),
    MaxW > 3 |>
    let Dur = fn:minus(LastT, FirstT).

# Long slot wait (>10 seconds)
Decl long_slot_wait(ShardId, WaitDurationMs) bound [/string, /number].
long_slot_wait(SID, Wait) :-
    slot_acquired(_, SID, Wait),
    Wait > 10000.

# =============================================================================
# SECTION 16: SUCCESS MASKING FAILURE DETECTION
# =============================================================================

# False success (success=true but same action loops)
Decl false_success_loop(Action, SuccessCount, LoopDurationMs) bound [/name, /number, /number].
false_success_loop(Act, N, Dur) :-
    action_loop(Act, N, Dur, _, _),
    action_completed(_, Act, /true, _).

# Combined anomaly severity
Decl loop_anomaly(Action, Severity, Evidence) bound [/name, /name, /string].
loop_anomaly(Act, /critical, "repeated_call_id") :-
    repeated_call_id(CID, N, _, _), N > 10,
    tool_execution_start(_, _, Act, _, CID).
loop_anomaly(Act, /critical, "action_loop") :-
    action_loop(Act, N, _, _, _), N > 20.
loop_anomaly(Act, /high, "identical_results") :-
    identical_results(Act, _, N), N > 10.
loop_anomaly(Act, /high, "false_success") :-
    false_success_loop(Act, _, _).

# =============================================================================
# SECTION 17: ROOT CAUSE DIAGNOSIS
# =============================================================================

# Kernel fact assertion tracking
# Note: This is an EDB fact - must be populated by the log parser
# The parser should extract messages containing "Asserting" patterns
Decl kernel_fact_asserted(Time, FactType) bound [/number, /string].

# Helper: Check if fact was asserted within 500ms of an action time
# Derives the action times that DO have follow-up fact assertions
Decl action_with_fact_followup(ActionTime) bound [/number].
action_with_fact_followup(AT) :-
    action_completed(AT, _, /true, _),
    kernel_fact_asserted(FT, _),
    FT > AT,
    fn:minus(FT, AT) < 500.

# Missing state update (no fact assertion after action)
Decl missing_state_update(ActionTime, Action) bound [/number, /name].
missing_state_update(AT, Act) :-
    action_completed(AT, Act, /true, _),
    !action_with_fact_followup(AT).

# Root cause diagnosis
Decl loop_root_cause(Action, Cause, Evidence) bound [/name, /name, /string].

# Cause 1: No fact assertion after action
loop_root_cause(Act, /missing_fact_update, "action completes but no kernel fact asserted") :-
    action_loop(Act, _, _, _, _),
    missing_state_update(_, Act).

# Cause 2: Same next_action derived repeatedly (kernel rule issue)
loop_root_cause(Act, /kernel_rule_stuck, "next_action derives same result") :-
    action_loop(Act, N, _, _, _),
    routing_stagnation(/next_action, N2, _),
    N2 > 5.

# Cause 3: Tool returning cached/dummy response
loop_root_cause(Act, /tool_caching, "tool returns identical result every time") :-
    action_loop(Act, _, _, _, _),
    identical_results(Act, _, N),
    N > 5.

# Cause 4: Slot starvation blocking state updates
loop_root_cause(Act, /slot_starvation, "API slots exhausted during loop") :-
    action_loop(Act, _, _, _, _),
    slot_starvation_event(_, _, Dur),
    Dur > 10000.

# Full diagnosis report
Decl loop_diagnosis(Action, LoopCount, DurationMs, RootCause, Severity)
    bound [/name, /number, /number, /name, /name].
loop_diagnosis(Act, N, Dur, Cause, Sev) :-
    action_loop(Act, N, Dur, _, _),
    loop_root_cause(Act, Cause, _),
    loop_anomaly(Act, Sev, _).

# =============================================================================
# END OF SCHEMA
# =============================================================================
