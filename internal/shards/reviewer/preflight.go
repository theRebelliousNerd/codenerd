// Package reviewer implements the Reviewer ShardAgent per Cortex 1.5.0 Section 7.0.
// This file provides pre-flight compilation checks to avoid wasting LLM tokens
// on code that does not compile.
package reviewer

import (
	"bufio"
	"context"
	"fmt"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"

	"codenerd/internal/build"
	"codenerd/internal/logging"
)

// =============================================================================
// PRE-FLIGHT DIAGNOSTIC TYPES
// =============================================================================

// Diagnostic represents a pre-flight check finding.
// These are generated by running go build and go vet before LLM review.
type Diagnostic struct {
	Severity string // "CRITICAL", "ERROR", "WARNING"
	Message  string
	Detail   string
	File     string
	Line     int
}

// PreFlightResult holds the aggregated result of pre-flight checks.
type PreFlightResult struct {
	Diagnostics  []Diagnostic
	Passed       bool
	Duration     time.Duration
	BuildOutput  string
	VetOutput    string
	PackageCount int
}

// =============================================================================
// PRE-FLIGHT CHECK EXECUTION
// =============================================================================

// PreFlightCheck runs compilation and static analysis before review.
// Returns diagnostics and a boolean indicating whether to proceed with review.
// If false, review should be aborted because the code does not compile.
func (r *ReviewerShard) PreFlightCheck(ctx context.Context, files []string) ([]Diagnostic, bool) {
	startTime := time.Now()
	logging.Reviewer("Starting pre-flight checks for %d files", len(files))

	var diagnostics []Diagnostic

	// Filter to Go files only - pre-flight checks are Go-specific
	goFiles := filterGoFiles(files)
	if len(goFiles) == 0 {
		logging.ReviewerDebug("No Go files to pre-flight check, skipping")
		return diagnostics, true
	}

	// Determine unique packages from files
	packages := getPackagesFromFiles(goFiles)
	logging.ReviewerDebug("Pre-flight checking %d packages: %v", len(packages), packages)

	if len(packages) == 0 {
		logging.ReviewerDebug("No packages identified, skipping pre-flight")
		return diagnostics, true
	}

	workingDir := r.reviewerConfig.WorkingDir
	if workingDir == "" {
		workingDir = "."
	}

	// 1. Run go build -n for syntax check on affected packages
	// Using -n for dry run (doesn't produce binary) but still checks compilation
	for _, pkg := range packages {
		select {
		case <-ctx.Done():
			diagnostics = append(diagnostics, Diagnostic{
				Severity: "ERROR",
				Message:  "Pre-flight check cancelled",
				Detail:   ctx.Err().Error(),
			})
			return diagnostics, false
		default:
		}

		buildDiags, compiles := r.checkBuild(ctx, pkg, workingDir)
		diagnostics = append(diagnostics, buildDiags...)

		if !compiles {
			logging.Reviewer("Pre-flight FAILED: package %s does not compile", pkg)
			return diagnostics, false // Abort review - code doesn't compile
		}
	}

	// 2. Run go vet for static analysis
	for _, pkg := range packages {
		select {
		case <-ctx.Done():
			return diagnostics, true // Build passed, allow review even if vet cancelled
		default:
		}

		vetDiags := r.checkVet(ctx, pkg, workingDir)
		diagnostics = append(diagnostics, vetDiags...)
	}

	duration := time.Since(startTime)
	logging.Reviewer("Pre-flight checks complete in %v: %d diagnostics, proceed=%t",
		duration, len(diagnostics), true)

	return diagnostics, true // Proceed with review
}

// checkBuild runs go build on a package and returns diagnostics.
// Returns (diagnostics, true) if compilation succeeds, (diagnostics, false) if it fails.
func (r *ReviewerShard) checkBuild(ctx context.Context, pkg, workingDir string) ([]Diagnostic, bool) {
	var diagnostics []Diagnostic

	// Create a context with timeout to prevent hanging builds
	buildCtx, cancel := context.WithTimeout(ctx, 60*time.Second)
	defer cancel()

	// Use go build with -o to prevent actual binary creation
	// For Windows, we use NUL as the null device
	nullDevice := "/dev/null"
	if strings.Contains(workingDir, "\\") || strings.HasPrefix(workingDir, "C:") {
		nullDevice = "NUL"
	}

	cmd := exec.CommandContext(buildCtx, "go", "build", "-o", nullDevice, pkg)
	cmd.Dir = workingDir
	cmd.Env = build.GetBuildEnv(nil, workingDir) // Use unified build environment

	output, err := cmd.CombinedOutput()
	outputStr := string(output)

	if err != nil {
		// Check if it's a context cancellation
		if buildCtx.Err() == context.DeadlineExceeded {
			diagnostics = append(diagnostics, Diagnostic{
				Severity: "ERROR",
				Message:  "Build timeout exceeded (60s)",
				Detail:   fmt.Sprintf("Package: %s", pkg),
			})
			return diagnostics, false
		}

		if buildCtx.Err() == context.Canceled {
			diagnostics = append(diagnostics, Diagnostic{
				Severity: "ERROR",
				Message:  "Build cancelled",
				Detail:   fmt.Sprintf("Package: %s", pkg),
			})
			return diagnostics, false
		}

		// Parse build errors into diagnostics
		buildDiags := parseBuildOutput(outputStr)
		if len(buildDiags) > 0 {
			diagnostics = append(diagnostics, buildDiags...)
		} else {
			// Fallback if parsing failed
			diagnostics = append(diagnostics, Diagnostic{
				Severity: "CRITICAL",
				Message:  "Code does not compile",
				Detail:   outputStr,
			})
		}

		logging.ReviewerDebug("Build failed for %s: %s", pkg, outputStr)
		return diagnostics, false
	}

	logging.ReviewerDebug("Build passed for %s", pkg)
	return diagnostics, true
}

// checkVet runs go vet on a package and returns diagnostics.
func (r *ReviewerShard) checkVet(ctx context.Context, pkg, workingDir string) []Diagnostic {
	var diagnostics []Diagnostic

	// Create a context with timeout
	vetCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
	defer cancel()

	cmd := exec.CommandContext(vetCtx, "go", "vet", pkg)
	cmd.Dir = workingDir
	cmd.Env = build.GetBuildEnv(nil, workingDir) // Use unified build environment

	output, err := cmd.CombinedOutput()
	outputStr := string(output)

	if err != nil {
		// Check for context errors first
		if vetCtx.Err() == context.DeadlineExceeded {
			diagnostics = append(diagnostics, Diagnostic{
				Severity: "WARNING",
				Message:  "go vet timeout exceeded (30s)",
				Detail:   fmt.Sprintf("Package: %s", pkg),
			})
			return diagnostics
		}

		if vetCtx.Err() == context.Canceled {
			return diagnostics // Just return, don't add a diagnostic for cancellation
		}

		// Parse vet output into diagnostics
		vetDiags := parseVetOutput(outputStr)
		diagnostics = append(diagnostics, vetDiags...)

		logging.ReviewerDebug("go vet found issues in %s: %d diagnostics", pkg, len(vetDiags))
	} else {
		logging.ReviewerDebug("go vet passed for %s", pkg)
	}

	return diagnostics
}

// =============================================================================
// OUTPUT FORMATTING
// =============================================================================

// formatPreFlightFailure formats a failure response for the user.
// This creates a clear message explaining why review was aborted.
func (r *ReviewerShard) formatPreFlightFailure(diagnostics []Diagnostic) string {
	var sb strings.Builder

	sb.WriteString("# Pre-Flight Check Failed\n\n")
	sb.WriteString("**Review aborted**: The code does not compile. Fix the following issues before requesting review.\n\n")

	// Group diagnostics by severity
	critical := make([]Diagnostic, 0)
	errors := make([]Diagnostic, 0)
	warnings := make([]Diagnostic, 0)

	for _, d := range diagnostics {
		switch d.Severity {
		case "CRITICAL":
			critical = append(critical, d)
		case "ERROR":
			errors = append(errors, d)
		case "WARNING":
			warnings = append(warnings, d)
		}
	}

	// Critical issues first
	if len(critical) > 0 {
		sb.WriteString("## Critical Issues (Must Fix)\n\n")
		for _, d := range critical {
			formatDiagnostic(&sb, d)
		}
	}

	// Errors
	if len(errors) > 0 {
		sb.WriteString("## Errors\n\n")
		for _, d := range errors {
			formatDiagnostic(&sb, d)
		}
	}

	// Warnings
	if len(warnings) > 0 {
		sb.WriteString("## Warnings\n\n")
		for _, d := range warnings {
			formatDiagnostic(&sb, d)
		}
	}

	sb.WriteString("\n---\n")
	sb.WriteString("*Run `go build ./...` locally to see full error details.*\n")

	return sb.String()
}

// formatDiagnostic writes a single diagnostic to the string builder.
func formatDiagnostic(sb *strings.Builder, d Diagnostic) {
	if d.File != "" {
		if d.Line > 0 {
			sb.WriteString(fmt.Sprintf("- **%s:%d**: %s\n", d.File, d.Line, d.Message))
		} else {
			sb.WriteString(fmt.Sprintf("- **%s**: %s\n", d.File, d.Message))
		}
	} else {
		sb.WriteString(fmt.Sprintf("- %s\n", d.Message))
	}

	if d.Detail != "" {
		// Truncate very long details
		detail := d.Detail
		if len(detail) > 500 {
			detail = detail[:500] + "... (truncated)"
		}
		sb.WriteString(fmt.Sprintf("  ```\n  %s\n  ```\n", strings.ReplaceAll(detail, "\n", "\n  ")))
	}
}

// =============================================================================
// HYPOTHESIS INJECTION
// =============================================================================

// injectVetDiagnostics converts go vet diagnostics to hypotheses for verification.
// This allows the LLM reviewer to specifically verify these potential issues.
func (r *ReviewerShard) injectVetDiagnostics(diagnostics []Diagnostic) {
	if r.kernel == nil {
		logging.ReviewerDebug("No kernel available, skipping vet diagnostic injection")
		return
	}

	for _, d := range diagnostics {
		// Only inject vet warnings (not build errors) as hypotheses
		if d.Severity != "WARNING" {
			continue
		}

		// Create a hypothesis fact for the LLM to verify
		// Format: review_hypothesis(File, Line, Category, Description, Source)
		hypothesis := fmt.Sprintf("review_hypothesis(%q, %d, %q, %q, %q)",
			d.File,
			d.Line,
			categorizeVetMessage(d.Message),
			d.Message,
			"go_vet",
		)

		logging.ReviewerDebug("Injecting vet hypothesis: %s", hypothesis)

		// Parse and assert the hypothesis
		if fact := parseMangleAtom(hypothesis); fact != nil {
			if err := r.kernel.Assert(*fact); err != nil {
				logging.ReviewerDebug("Failed to assert vet hypothesis: %v", err)
			}
		}
	}
}

// categorizeVetMessage maps go vet messages to review categories.
func categorizeVetMessage(message string) string {
	lowerMsg := strings.ToLower(message)

	switch {
	case strings.Contains(lowerMsg, "printf"):
		return "format"
	case strings.Contains(lowerMsg, "unreachable"):
		return "dead_code"
	case strings.Contains(lowerMsg, "shadow"):
		return "shadowing"
	case strings.Contains(lowerMsg, "lock"):
		return "concurrency"
	case strings.Contains(lowerMsg, "race"):
		return "concurrency"
	case strings.Contains(lowerMsg, "nil"):
		return "nil_safety"
	case strings.Contains(lowerMsg, "loop variable"):
		return "loop_capture"
	case strings.Contains(lowerMsg, "assign"):
		return "assignment"
	case strings.Contains(lowerMsg, "struct"):
		return "struct"
	case strings.Contains(lowerMsg, "atomic"):
		return "concurrency"
	default:
		return "general"
	}
}

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

// filterGoFiles returns only .go files from the input list.
func filterGoFiles(files []string) []string {
	result := make([]string, 0, len(files))
	for _, f := range files {
		if strings.HasSuffix(f, ".go") && !strings.HasSuffix(f, "_test.go") {
			result = append(result, f)
		}
	}
	return result
}

// getPackagesFromFiles determines unique Go packages from a list of file paths.
// Returns package import paths suitable for go build/vet commands.
func getPackagesFromFiles(files []string) []string {
	// Use a map to deduplicate packages
	pkgSet := make(map[string]struct{})

	for _, file := range files {
		// Get the directory containing the file
		dir := filepath.Dir(file)

		// Normalize path separators
		dir = filepath.ToSlash(dir)

		// Convert to a package path
		// If it starts with ./ or has no prefix, use it as-is for local packages
		if dir == "" || dir == "." {
			dir = "."
		}

		// For paths like "internal/foo/bar.go", use "./internal/foo"
		if !strings.HasPrefix(dir, ".") && !strings.HasPrefix(dir, "/") {
			dir = "./" + dir
		}

		pkgSet[dir] = struct{}{}
	}

	// Convert map to slice
	packages := make([]string, 0, len(pkgSet))
	for pkg := range pkgSet {
		packages = append(packages, pkg)
	}

	return packages
}

// parseBuildOutput parses go build error output into Diagnostics.
// Go build errors typically have the format: file.go:line:col: message
func parseBuildOutput(output string) []Diagnostic {
	var diagnostics []Diagnostic

	// Regex to match Go build error format: path/file.go:line:col: message
	// Also matches: path/file.go:line: message (without column)
	errorRegex := regexp.MustCompile(`^([^:]+\.go):(\d+):(?:(\d+):)?\s*(.+)$`)

	scanner := bufio.NewScanner(strings.NewReader(output))
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}

		matches := errorRegex.FindStringSubmatch(line)
		if len(matches) >= 5 {
			file := matches[1]
			lineNum, _ := strconv.Atoi(matches[2])
			message := matches[4]

			// Determine severity based on message content
			severity := "ERROR"
			if strings.Contains(strings.ToLower(message), "undefined") ||
				strings.Contains(strings.ToLower(message), "cannot") ||
				strings.Contains(strings.ToLower(message), "invalid") {
				severity = "CRITICAL"
			}

			diagnostics = append(diagnostics, Diagnostic{
				Severity: severity,
				Message:  message,
				File:     file,
				Line:     lineNum,
			})
		} else if strings.Contains(line, "error") || strings.Contains(line, "cannot") {
			// Fallback for lines that don't match the regex but contain error info
			diagnostics = append(diagnostics, Diagnostic{
				Severity: "ERROR",
				Message:  line,
			})
		}
	}

	return diagnostics
}

// parseVetOutput parses go vet output into Diagnostics.
// go vet output format: file.go:line:col: message
func parseVetOutput(output string) []Diagnostic {
	var diagnostics []Diagnostic

	// Regex to match go vet output format
	vetRegex := regexp.MustCompile(`^#?\s*([^:]+\.go):(\d+):(?:(\d+):)?\s*(.+)$`)

	scanner := bufio.NewScanner(strings.NewReader(output))
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}

		// Skip package header lines like "# package/path"
		if strings.HasPrefix(line, "#") && !strings.Contains(line, ".go:") {
			continue
		}

		matches := vetRegex.FindStringSubmatch(line)
		if len(matches) >= 5 {
			file := matches[1]
			lineNum, _ := strconv.Atoi(matches[2])
			message := matches[4]

			diagnostics = append(diagnostics, Diagnostic{
				Severity: "WARNING",
				Message:  message,
				File:     file,
				Line:     lineNum,
			})
		} else if strings.Contains(line, ":") && strings.Contains(line, ".go") {
			// Fallback for non-standard vet output
			diagnostics = append(diagnostics, Diagnostic{
				Severity: "WARNING",
				Message:  line,
			})
		}
	}

	return diagnostics
}

// =============================================================================
// INTEGRATION WITH REVIEW FLOW
// =============================================================================

// RunPreFlightAndProceed runs pre-flight checks and decides whether to proceed.
// Returns the formatted failure message if pre-flight fails, empty string otherwise.
// This is a convenience method for integration into the main review flow.
func (r *ReviewerShard) RunPreFlightAndProceed(ctx context.Context, files []string) (string, bool) {
	diagnostics, proceed := r.PreFlightCheck(ctx, files)

	if !proceed {
		return r.formatPreFlightFailure(diagnostics), false
	}

	// Inject vet warnings as hypotheses for LLM verification
	if len(diagnostics) > 0 {
		r.injectVetDiagnostics(diagnostics)
		logging.Reviewer("Pre-flight passed with %d warnings, injected as hypotheses", len(diagnostics))
	}

	return "", true
}

// =============================================================================
// SOLUTION PROPOSAL FOR BUILD ERRORS
// =============================================================================

// proposeSolutionForDiagnostic generates a proposed fix for a pre-flight diagnostic.
// This enables the review to continue while providing actionable remediation advice.
func (r *ReviewerShard) proposeSolutionForDiagnostic(diag Diagnostic) string {
	msg := strings.ToLower(diag.Message)
	detail := strings.ToLower(diag.Detail)
	combined := msg + " " + detail

	// Environment issues
	if strings.Contains(combined, "gocache") && strings.Contains(combined, "not defined") {
		return "Set GOCACHE environment variable: `$env:GOCACHE = \"$env:USERPROFILE\\.cache\\go-build\"` (PowerShell) or `export GOCACHE=~/.cache/go-build` (bash)"
	}
	if strings.Contains(combined, "gopath") && strings.Contains(combined, "not defined") {
		return "Set GOPATH environment variable: `$env:GOPATH = \"$env:USERPROFILE\\go\"` (PowerShell) or `export GOPATH=~/go` (bash)"
	}
	if strings.Contains(combined, "go.mod") && strings.Contains(combined, "not found") {
		return "Initialize Go module: `go mod init <module-name>` or ensure you're in the correct directory"
	}

	// Import errors
	if strings.Contains(combined, "could not import") || strings.Contains(combined, "cannot find package") {
		return "Run `go mod tidy` to fetch missing dependencies, or check import path spelling"
	}
	if strings.Contains(combined, "import cycle") {
		return "Refactor to break the import cycle - consider moving shared types to a separate package"
	}

	// Syntax errors
	if strings.Contains(combined, "undefined:") {
		// Extract the undefined symbol if possible
		return "Check for typos in the identifier name, ensure it's exported (capitalized) if from another package, or add the missing declaration"
	}
	if strings.Contains(combined, "expected") && strings.Contains(combined, "found") {
		return "Fix the syntax error - check for missing brackets, parentheses, or semicolons near the indicated line"
	}
	if strings.Contains(combined, "missing return") {
		return "Add a return statement at the end of the function for all code paths"
	}

	// Type errors
	if strings.Contains(combined, "cannot use") && strings.Contains(combined, "as type") {
		return "Fix the type mismatch - use a type conversion or change the variable/parameter type"
	}
	if strings.Contains(combined, "not enough arguments") || strings.Contains(combined, "too many arguments") {
		return "Check the function signature and provide the correct number of arguments"
	}
	if strings.Contains(combined, "cannot assign") {
		return "Check if the variable is assignable (not a constant or unexported field)"
	}

	// Build environment issues
	if strings.Contains(combined, "cgo") && (strings.Contains(combined, "gcc") || strings.Contains(combined, "cc")) {
		return "Install C compiler (gcc/clang) or set CGO_ENABLED=0 if C dependencies aren't needed"
	}
	if strings.Contains(combined, "build constraints exclude") {
		return "Check build tags and GOOS/GOARCH settings match your target platform"
	}

	// CGO header file issues (sqlite, etc.)
	if strings.Contains(combined, "sqlite3.h") && strings.Contains(combined, "not found") {
		return "Set CGO_CFLAGS to include sqlite headers: `$env:CGO_CFLAGS=\"-IC:/CodeProjects/codeNERD/sqlite_headers\"` or add to .nerd/config.json build.env_vars"
	}
	if strings.Contains(combined, ".h") && strings.Contains(combined, "not found") {
		return "Missing C header file - set CGO_CFLAGS with the include path: `CGO_CFLAGS=\"-I/path/to/headers\"`"
	}

	// Timeout/resource issues
	if strings.Contains(combined, "timeout") {
		return "Build is taking too long - check for circular dependencies or try `go clean -cache` to clear build cache"
	}

	// Generic fallback
	if diag.Severity == "CRITICAL" || diag.Severity == "ERROR" {
		return "Run `go build ./...` locally to see detailed error output and fix the compilation issue"
	}

	return ""
}
