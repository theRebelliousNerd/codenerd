# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: antipatterns/string_manipulation.md

- id: "language/mangle/docs/antipatterns/string_manipulation"
  category: "language"
  subcategory: "mangle"
  description: "Anti-Pattern: String Manipulation"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Anti-Pattern: String Manipulation
    
    ## Category
    Limited Built-in Support (Complex String Operations)
    
    ## Description
    Expecting rich string manipulation functions (split, regex, interpolation, formatting) when Mangle has minimal string support. Complex string operations should happen in Go.
    
    ---
    
    ## Anti-Pattern 1: String Interpolation
    
    ### Wrong Approach
    ```python
    name = "Alice"
    message = f"Hello, {name}!"
    ```
    
    Attempting:
    ```mangle
    # WRONG - no string interpolation
    greeting(Name, Msg) :-
        user_name(Name),
        Msg = f"Hello, {Name}!".
    ```
    
    ### Why It Fails
    No string interpolation syntax like `${}`, `f""`, or `#{}`.
    
    ### Correct Mangle Way
    ```mangle
    # Use fn:string_concat (if available):
    greeting(Name, Msg) :-
        user_name(Name),
        fn:string_concat(["Hello, ", Name, "!"], Msg).
    
    # Or build the string in Go before loading:
    // msg := fmt.Sprintf("Hello, %s!", name)
    // store.Add(engine.NewAtom("greeting", engine.String(name), engine.String(msg)))
    
    # Query:
    Decl greeting(Name.Type<string>, Msg.Type<string>).
    ```
    
    ---
    
    ## Anti-Pattern 2: String Split
    
    ### Wrong Approach
    ```javascript
    const parts = "a,b,c".split(",");  // ["a", "b", "c"]
    ```
    
    Attempting:
    ```mangle
    # WRONG - no split function
    parse_csv(Line, Parts) :-
        csv_line(Line),
        Parts = split(Line, ",").
    ```
    
    ### Why It Fails
    Mangle likely doesn't have a built-in `split` function. Check the `builtin` package.
    
    ### Correct Mangle Way
    ```mangle
    # Option 1: Split in Go and load as facts
    // line := "a,b,c"
    // parts := strings.Split(line, ",")
    // for i, part := range parts {
    //     store.Add(engine.NewAtom("csv_part", engine.Number(i), engine.String(part)))
    // }
    
    Decl csv_part(Index.Type<int>, Value.Type<string>).
    
    # Option 2: If fn:string:split exists:
    parse_csv(Parts) :-
        csv_line(Line),
        fn:string:split(Line, ",", Parts).
    
    # Option 3: Model delimited data as separate facts
    Decl field(Line.Type</atom>, Index.Type<int>, Value.Type<string>).
    
    field(/line1, 0, "a").
    field(/line1, 1, "b").
    field(/line1, 2, "c").
    ```
    
    ---
    
    ## Anti-Pattern 3: Regular Expressions
    
    ### Wrong Approach
    ```python
    import re
    match = re.search(r"(\d{3})-(\d{4})", phone)
    ```
    
    Attempting:
    ```mangle
    # WRONG - no regex support
    extract_phone(Phone, AreaCode, Number) :-
        phone_string(Phone),
        regex_match(Phone, r"(\d{3})-(\d{4})", AreaCode, Number).
    ```
    
    ### Why It Fails
    No built-in regex support.
    
    ### Correct Mangle Way
    ```mangle
    # Parse in Go and load results:
    // re := regexp.MustCompile(`(\d{3})-(\d{4})`)
    // matches := re.FindStringSubmatch(phone)
    // if len(matches) == 3 {
    //     store.Add(engine.NewAtom("phone_parts",
    //         engine.String(phone),
    //         engine.String(matches[1]), // area code
    //         engine.String(matches[2]))) // number
    // }
    
    Decl phone_parts(Phone.Type<string>, AreaCode.Type<string>, Number.Type<string>).
    
    format_phone(Phone, Formatted) :-
        phone_parts(Phone, Area, Num),
        fn:string_concat(["(", Area, ") ", Num], Formatted).
    ```
    
    ---
    
    ## Anti-Pattern 4: Substring / Slicing
    
    ### Wrong Approach
    ```python
    first_three = text[0:3]
    rest = text[3:]
    ```
    
    Attempting:
    ```mangle
    # WRONG - no substring/slicing
    extract(Text, First, Rest) :-
        data(Text),
        First = Text[0:3],
        Rest = Text[3:].
    ```
    
    ### Why It Fails
    No substring or slicing syntax.
    
    ### Correct Mangle Way
    ```mangle
    # If fn:string:substring exists:
    extract(Text, First, Rest) :-
        data(Text),
        fn:string:substring(Text, 0, 3, First),
        fn:string:substring(Text, 3, fn:length(Text), Rest).
    
    # Or do it in Go:
    // first := text[0:3]
    // rest := text[3:]
    // store.Add(engine.NewAtom("text_parts",
    //     engine.String(text),
    //     engine.String(first),
    //     engine.String(rest)))
    
    Decl text_parts(Text.Type<string>, First.Type<string>, Rest.Type<string>).
    ```
    
    ---
    
    ## Anti-Pattern 5: String Formatting
    
    ### Wrong Approach
    ```python
    formatted = "{:>10}".format(value)  # Right-align, width 10
    ```
    
    Attempting:
    ```mangle
    # WRONG - no format strings
    format_value(Val, Formatted) :-
        value(Val),
        Formatted = format("{:>10}", Val).
    ```
    
    ### Why It Fails
    No printf-style or template formatting.
    
    ### Correct Mangle Way
    ```mangle
    # Format in Go:
    // formatted := fmt.Sprintf("%10s", value)
    // store.Add(engine.NewAtom("formatted_value", engine.String(value), engine.String(formatted)))
    
    Decl formatted_value(Value.Type<string>, Formatted.Type<string>).
    ```
    
    ---
    
    ## Anti-Pattern 6: Case Conversion
    
    ### Wrong Approach
    ```javascript
    upper = text.toUpperCase();
    lower = text.toLowerCase();
    ```
    
    Attempting:
    ```mangle
    # WRONG - may not have case functions
    uppercase(Text, Upper) :-
        data(Text),
        Upper = Text.toUpperCase().
    ```
    
    ### Why It Fails
    Check if `fn:string:upper` or similar exists. May not be available.
    
    ### Correct Mangle Way
    ```mangle
    # If available:
    uppercase(Text, Upper) :-
        data(Text),
        fn:string:upper(Text, Upper).
    
    # Otherwise, do in Go:
    // upper := strings.ToUpper(text)
    // store.Add(engine.NewAtom("uppercase", engine.String(text), engine.String(upper)))
    
    Decl uppercase(Original.Type<string>, Upper.Type<string>).
    ```
    
    ---
    
    ## Anti-Pattern 7: String Trimming
    
    ### Wrong Approach
    ```python
    trimmed = text.strip()
    ```
    
    Attempting:
    ```mangle
    # WRONG - may not have trim
    clean(Text, Trimmed) :-
        input(Text),
        Trimmed = trim(Text).
    ```
    
    ### Why It Fails
    Check if `fn:string:trim` exists.
    
    ### Correct Mangle Way
    ```mangle
    # If available:
    clean(Text, Trimmed) :-
        input(Text),
        fn:string:trim(Text, Trimmed).
    
    # Or in Go:
    // trimmed := strings.TrimSpace(text)
    // store.Add(engine.NewAtom("cleaned", engine.String(text), engine.String(trimmed)))
    ```
    
    ---
    
    ## Anti-Pattern 8: String Replace
    
    ### Wrong Approach
    ```python
    new_text = text.replace("old", "new")
    ```
    
    Attempting:
    ```mangle
    # WRONG - may not have replace
    substitute(Text, New) :-
        data(Text),
        New = replace(Text, "old", "new").
    ```
    
    ### Why It Fails
    Check if `fn:string:replace` exists.
    
    ### Correct Mangle Way
    ```mangle
    # If available:
    substitute(Text, New) :-
        data(Text),
        fn:string:replace(Text, "old", "new", New).
    
    # Or in Go:
    // new := strings.ReplaceAll(text, "old", "new")
    // store.Add(engine.NewAtom("substituted", engine.String(text), engine.String(new)))
    ```
    
    ---
    
    ## Anti-Pattern 9: String Contains / Index
    
    ### Wrong Approach
    ```python
    if "needle" in haystack:
        index = haystack.index("needle")
    ```
    
    Attempting:
    ```mangle
    # WRONG - may not have contains/index
    found(Haystack, Index) :-
        data(Haystack),
        contains(Haystack, "needle"),
        Index = indexOf(Haystack, "needle").
    ```
    
    ### Why It Fails
    Check if `fn:string:contains` or `fn:string:index` exist.
    
    ### Correct Mangle Way
    ```mangle
    # If available:
    found(Haystack, Index) :-
        data(Haystack),
        fn:string:contains(Haystack, "needle"),
        fn:string:index(Haystack, "needle", Index).
    
    # Or check in Go and load result:
    // if strings.Contains(haystack, "needle") {
    //     index := strings.Index(haystack, "needle")
    //     store.Add(engine.NewAtom("found", engine.String(haystack), engine.Number(index)))
    // }
    ```
    
    ---
    
    ## Anti-Pattern 10: Multi-line Strings / Heredoc
    
    ### Wrong Approach
    ```python
    sql = """
        SELECT *
        FROM users
        WHERE active = true
    """
    ```
    
    Attempting:
    ```mangle
    # WRONG - no multi-line string literals (usually)
    query(SQL) :-
        SQL = """
        SELECT *
        FROM users
        """.
    ```
    
    ### Why It Fails
    Most Datalog variants don't support multi-line strings.
    
    ### Correct Mangle Way
    ```mangle
    # Use string concatenation:
    query(SQL) :-
        fn:string_concat([
            "SELECT * ",
            "FROM users ",
            "WHERE active = true"
        ], SQL).
    
    # Or load from Go:
    // sql := `
    //     SELECT *
    //     FROM users
    //     WHERE active = true
    // `
    // store.Add(engine.NewAtom("query", engine.String(sql)))
    
    Decl query(SQL.Type<string>).
    ```
    
    ---
    
    ## Anti-Pattern 11: String Reversal
    
    ### Wrong Approach
    ```python
    reversed_text = text[::-1]
    ```
    
    Attempting:
    ```mangle
    # WRONG - no reverse function
    reverse_string(Text, Rev) :-
        data(Text),
        Rev = reverse(Text).
    ```
    
    ### Why It Fails
    Unlikely to have a built-in reverse function.
    
    ### Correct Mangle Way
    ```mangle
    # Do in Go:
    // runes := []rune(text)
    // for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
    //     runes[i], runes[j] = runes[j], runes[i]
    // }
    // reversed := string(runes)
    // store.Add(engine.NewAtom("reversed", engine.String(text), engine.String(reversed)))
    
    Decl reversed(Original.Type<string>, Reversed.Type<string>).
    
    # Or implement recursively (for learning, not production):
    Decl reverse_chars(Chars.Type<list>, Result.Type<list>).
    
    reverse_chars([], []).
    reverse_chars(List, Reversed) :-
        :match_cons(List, Head, Tail),
        reverse_chars(Tail, ReversedTail),
        fn:list:append(ReversedTail, [Head], Reversed).
    ```
    
    ---
    
    ## Anti-Pattern 12: String Length
    
    ### Wrong Approach
    ```python
    length = len(text)
    ```
    
    Attempting:
    ```mangle
    # WRONG - may not have length function
    string_length(Text, Len) :-
        data(Text),
        Len = len(Text).
    ```
    
    ### Why It Fails (Partially)
    This might actually work if `fn:length` exists, but check the builtin package.
    
    ### Correct Mangle Way
    ```mangle
    # If fn:length exists:
    string_length(Text, Len) :-
        data(Text),
        Len = fn:length(Text).
    
    # Or compute in Go:
    // length := len(text)
    // store.Add(engine.NewAtom("text_length", engine.String(text), engine.Number(length)))
    ```
    
    ---
    
    ## Anti-Pattern 13: String Building in Loops
    
    ### Wrong Approach
    ```python
    result = ""
    for item in items:
        result += str(item) + ", "
    ```
    
    Attempting:
    ```mangle
    # WRONG - no loops or mutable strings
    build_string(Result) :-
        Result = "",
        item(I),
        Result = Result + str(I) + ", ".
    ```
    
    ### Why It Fails
    No mutation, no loops. Use aggregation or do in Go.
    
    ### Correct Mangle Way
    ```mangle
    # Option 1: Aggregate with fn:string_concat
    all_items(Result) :-
        item(I)
        |> do fn:group_by()
        |> let Parts = fn:List(I)
        |> let Result = fn:string:join(Parts, ", ").  # If exists
    
    # Option 2: Build in Go
    // var parts []string
    // results := store.Query("item", i)
    // for _, r := range results {
    //     parts = append(parts, fmt.Sprintf("%v", r.I))
    // }
    // result := strings.Join(parts, ", ")
    // store.Add(engine.NewAtom("all_items", engine.String(result)))
    ```
    
    ---
    
    ## Anti-Pattern 14: Escape Sequences
    
    ### Wrong Approach
    ```python
    path = "C:\\Users\\Name\\file.txt"
    tab_separated = "col1\tcol2\tcol3"
    ```
    
    Attempting:
    ```mangle
    # WRONG - escape sequence handling varies
    windows_path(Path) :-
        Path = "C:\\Users\\Name\\file.txt".
    
    tsv(Line) :-
        Line = "col1\tcol2\tcol3".
    ```
    
    ### Why It Fails
    Escape sequence handling may differ from expectations.
    
    ### Correct Mangle Way
    ```mangle
    # Use raw strings or load from Go:
    // path := `C:\Users\Name\file.txt`
    // store.Add(engine.NewAtom("windows_path", engine.String(path)))
    
    // tsv := "col1\tcol2\tcol3"
    // store.Add(engine.NewAtom("tsv_line", engine.String(tsv)))
    
    Decl windows_path(Path.Type<string>).
    Decl tsv_line(Line.Type<string>).
    
    # Or use atoms for paths:
    Decl file_path(Path.Type</atom>).
    file_path(/c_users_name_file_txt).
    ```
    
    ---
    
    ## Pattern: String Processing Workflow
    
    ### General Approach
    
    1. **Simple operations**: Use `fn:string_concat` and available built-ins
    2. **Complex operations**: Process in Go, load results as facts
    3. **Parsing**: Always do in Go (regex, split, custom parsers)
    4. **Formatting**: Always do in Go (printf, templates)
    5. **Validation**: Check in Go, load as boolean facts
    
    ### Example: Processing CSV
    
    ```mangle
    # Don't parse CSV in Mangle!
    
    # Instead, load parsed data:
    Decl csv_row(RowId.Type<int>, Col1.Type<string>, Col2.Type<string>, Col3.Type<string>).
    
    # In Go:
    // csvReader := csv.NewReader(file)
    // for rowId, record := range csvReader.ReadAll() {
    //     store.Add(engine.NewAtom("csv_row",
    //         engine.Number(rowId),
    //         engine.String(record[0]),
    //         engine.String(record[1]),
    //         engine.String(record[2])))
    // }
    
    # Then derive in Mangle:
    valid_row(RowId) :-
        csv_row(RowId, Col1, _, _),
        fn:length(Col1) > 0.
    ```
    
    ---
    
    ## Available String Functions (Check Your Mangle Version)
    
    Common built-ins that MAY exist:
    
    - `fn:string_concat(Parts.Type<list>, Result.Type<string>)` - Concatenate strings
    - `fn:length(Str.Type<string>)` - String length
    - `fn:string:upper(Str, Upper)` - To uppercase
    - `fn:string:lower(Str, Lower)` - To lowercase
    - `fn:string:trim(Str, Trimmed)` - Remove whitespace
    - `fn:string:contains(Haystack, Needle)` - Check substring
    - `fn:string:split(Str, Delim, Parts)` - Split string
    - `fn:string:join(Parts, Delim, Result)` - Join strings
    - `fn:to_string(Value)` - Convert to string
    
    **Always check** the `builtin` package documentation for your Mangle version!
    
    ---
    
    ## Key Principle: Mangle is Not a String Processor
    
    | String-Heavy Language | Mangle |
    |-----------------------|--------|
    | String interpolation | `fn:string_concat` |
    | `split()`, `join()` | May exist, or do in Go |
    | Regular expressions | Always do in Go |
    | Substring/slicing | May exist, or do in Go |
    | Format strings | Always do in Go |
    | Case conversion | May exist, or do in Go |
    | Trim, replace | May exist, or do in Go |
    | Contains, index | May exist, or do in Go |
    | Multi-line strings | Usually not supported |
    | String builder loops | Aggregation or Go |
    
    ---
    
    ## Migration Checklist
    
    When translating string-heavy code to Mangle:
    
    - [ ] Replace string interpolation with `fn:string_concat`
    - [ ] Move split/parse operations to Go
    - [ ] Move all regex to Go
    - [ ] Move substring/slicing to Go (unless built-in exists)
    - [ ] Move formatting to Go
    - [ ] Check if case conversion built-ins exist
    - [ ] Check if trim/replace built-ins exist
    - [ ] Move contains/index to Go (unless built-in exists)
    - [ ] Avoid multi-line string literals
    - [ ] Replace string building loops with Go
    - [ ] Handle escape sequences in Go
    - [ ] Load processed strings as facts
    - [ ] Use Mangle for string-based logic, not processing
    - [ ] Remember: Mangle reasons about strings, Go manipulates them
    
    ---
    
    ## Pro Tip: Strings as Atoms
    
    For many use cases, use **atoms** instead of strings:
    
    ```mangle
    # Instead of:
    Decl status(Id.Type<int>, Status.Type<string>).
    status(1, "active").
    status(2, "inactive").
    
    # Use atoms:
    Decl status(Id.Type<int>, Status.Type</atom>).
    status(1, /active).
    status(2, /inactive).
    ```
    
    **Benefits:**
    - More efficient (atoms are interned)
    - Type-safe (can't typo `/active` as `/activ`)
    - No string manipulation needed
    - Better for pattern matching
    
    Use **strings** only when you have truly arbitrary text data.
