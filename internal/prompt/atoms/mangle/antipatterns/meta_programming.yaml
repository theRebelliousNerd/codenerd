# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: antipatterns/meta_programming.md

- id: "language/mangle/docs/antipatterns/meta_programming"
  category: "language"
  subcategory: "mangle"
  description: "Anti-Pattern: Meta-Programming"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Anti-Pattern: Meta-Programming
    
    ## Category
    Meta-Programming Limitations
    
    ## Description
    Expecting meta-programming capabilities like code generation, macros, template expansion, or runtime schema modification when Mangle has minimal meta-programming support.
    
    ---
    
    ## Anti-Pattern 1: Macros / Code Generation
    
    ### Wrong Approach
    ```c
    // C preprocessor macros
    #define DOUBLE(x) ((x) * 2)
    int result = DOUBLE(5);  // Expands to ((5) * 2)
    ```
    
    Attempting:
    ```mangle
    # WRONG - no macros
    #define double(X, R) :- R = fn:times(X, 2).
    
    result(R) :- double(5, R).
    ```
    
    ### Why It Fails
    No macro system or code generation facilities.
    
    ### Correct Mangle Way
    ```mangle
    # Just define predicates normally:
    Decl double(X.Type<int>, Result.Type<int>).
    
    double(X, R) :- R = fn:times(X, 2).
    
    result(R) :- double(5, R).
    
    # For code reuse, use regular predicates
    # For complex generation, generate .gl files in Go:
    // template := `
    // Decl %s(X.Type<int>, Result.Type<int>).
    // %s(X, R) :- R = fn:times(X, %d).
    // `
    // code := fmt.Sprintf(template, name, name, multiplier)
    // os.WriteFile("generated.gl", []byte(code), 0644)
    ```
    
    ---
    
    ## Anti-Pattern 2: Template Expansion
    
    ### Wrong Approach
    ```cpp
    // C++ templates
    template<typename T>
    T max(T a, T b) {
        return a > b ? a : b;
    }
    
    int maxInt = max<int>(5, 3);
    float maxFloat = max<float>(5.5, 3.3);
    ```
    
    Attempting:
    ```mangle
    # WRONG - no templates
    template<T>
    max(A.Type<T>, B.Type<T>, Result.Type<T>) :-
        A > B, Result = A;
        Result = B.
    ```
    
    ### Why It Fails
    No template or generic system.
    
    ### Correct Mangle Way
    ```mangle
    # Define separate predicates for each type:
    Decl max_int(A.Type<int>, B.Type<int>, Result.Type<int>).
    Decl max_float(A.Type<float>, B.Type<float>, Result.Type<float>).
    
    max_int(A, B, A) :- A > B.
    max_int(A, B, B) :- B >= A.
    
    max_float(A, B, A) :- A > B.
    max_float(A, B, B) :- B >= A.
    
    # Or generate code in Go:
    // for _, typ := range []string{"int", "float", "string"} {
    //     generateMaxPredicate(typ)
    // }
    ```
    
    ---
    
    ## Anti-Pattern 3: Compile-Time Computation
    
    ### Wrong Approach
    ```rust
    // Rust const fn
    const fn factorial(n: u32) -> u32 {
        match n {
            0 => 1,
            _ => n * factorial(n - 1),
        }
    }
    
    const FACT_5: u32 = factorial(5);  // Computed at compile time
    ```
    
    Attempting:
    ```mangle
    # WRONG - no compile-time computation
    const FACT_5 = factorial(5).  # Not a thing
    ```
    
    ### Why It Fails
    No compile-time evaluation. Everything is runtime (fixed-point evaluation).
    
    ### Correct Mangle Way
    ```mangle
    # Just compute at runtime:
    Decl factorial(N.Type<int>, Result.Type<int>).
    
    factorial(0, 1).
    factorial(N, Result) :-
        N > 0,
        N < 20,  # Safety limit
        N1 = fn:minus(N, 1),
        factorial(N1, R1),
        Result = fn:times(N, R1).
    
    # Or pre-compute in Go and load:
    // fact5 := factorial(5)
    // store.Add(engine.NewAtom("constant", engine.Atom("/FACT_5"), engine.Number(fact5)))
    
    Decl constant(Name.Type</atom>, Value.Type<int>).
    
    use_constant(V) :- constant(/FACT_5, V).
    ```
    
    ---
    
    ## Anti-Pattern 4: Code as Data (Homoiconicity)
    
    ### Wrong Approach
    ```lisp
    ; Lisp - code is data
    (defmacro when (condition &rest body)
      `(if ,condition (progn ,@body)))
    
    ; Code can be manipulated as lists
    ```
    
    Attempting:
    ```mangle
    # WRONG - code is not data
    Decl code(Expr.Type<code>).
    
    code(rule(head(X), body(pred(X)))).  # Not possible
    
    generate_rule(Code) :-
        code(Code),
        execute(Code).  # Can't execute code
    ```
    
    ### Why It Fails
    Mangle code is not first-class data. Can't manipulate or execute code at runtime.
    
    ### Correct Mangle Way
    ```mangle
    # Represent AST as data:
    Decl rule(Id.Type</atom>).
    Decl rule_head(RuleId.Type</atom>, Predicate.Type</atom>).
    Decl rule_body(RuleId.Type</atom>, Index.Type<int>, Predicate.Type</atom>).
    
    # Example: result(X) :- input(X).
    rule(/r1).
    rule_head(/r1, /result).
    rule_body(/r1, 0, /input).
    
    # Build an interpreter to "execute" rules
    # But this is complex - better to generate .gl files in Go
    ```
    
    ---
    
    ## Anti-Pattern 5: Aspect-Oriented Programming
    
    ### Wrong Approach
    ```java
    // AOP - inject behavior
    @Before("execution(* com.example.*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Method called: " + joinPoint.getSignature());
    }
    ```
    
    Attempting:
    ```mangle
    # WRONG - no aspect weaving
    @before(all_predicates)
    log_call(Pred) :-
        print("Calling", Pred).
    ```
    
    ### Why It Fails
    No AOP or aspect weaving. Can't inject behavior into other predicates.
    
    ### Correct Mangle Way
    ```mangle
    # Manually wrap predicates:
    Decl business_logic(X.Type<int>, Y.Type<int>).
    
    business_logic(X, Y) :- # ... actual logic ...
    
    # Wrapper with logging:
    Decl logged_business_logic(X.Type<int>, Y.Type<int>).
    
    logged_business_logic(X, Y) :-
        log_entry(/info, "Calling business_logic"),
        business_logic(X, Y),
        log_entry(/info, "Completed business_logic").
    
    # Or log in Go before/after evaluation:
    // log.Println("Before evaluation")
    // engine.EvalProgram(program)
    // log.Println("After evaluation")
    ```
    
    ---
    
    ## Anti-Pattern 6: Self-Modifying Code
    
    ### Wrong Approach
    ```python
    # Self-modifying code
    def modify_self():
        global process
        def process(x):
            return x * 3  # Change behavior
    ```
    
    Attempting:
    ```mangle
    # WRONG - can't modify rules at runtime
    modify_predicate() :-
        # Replace rule definition
        update_rule(process, new_body).  # Not possible
    ```
    
    ### Why It Fails
    Rules are immutable. Can't modify predicate definitions at runtime.
    
    ### Correct Mangle Way
    ```mangle
    # Use versioned predicates:
    Decl process(Version.Type<int>, X.Type<int>, Result.Type<int>).
    
    process(1, X, R) :- R = fn:times(X, 2).
    process(2, X, R) :- R = fn:times(X, 3).
    
    Decl active_version(V.Type<int>).
    
    active_version(1).  # Initially version 1
    
    current_process(X, R) :-
        active_version(V),
        process(V, X, R).
    
    # "Modify" by retracting active_version(1) and adding active_version(2) in Go
    ```
    
    ---
    
    ## Anti-Pattern 7: Decorators / Annotations
    
    ### Wrong Approach
    ```python
    @cache
    @validate_input
    def expensive_function(x):
        return x * 2
    ```
    
    Attempting:
    ```mangle
    # WRONG - no decorators
    @cache
    @validate
    expensive(X, Y) :- Y = fn:times(X, 2).
    ```
    
    ### Why It Fails
    No decorator or annotation system.
    
    ### Correct Mangle Way
    ```mangle
    # Manually compose:
    Decl expensive_core(X.Type<int>, Y.Type<int>).
    expensive_core(X, Y) :- Y = fn:times(X, 2).
    
    # Validation wrapper:
    Decl validated_expensive(X.Type<int>, Y.Type<int>).
    validated_expensive(X, Y) :-
        validate_input(X),
        expensive_core(X, Y).
    
    # Cache wrapper (simulate with memoization facts):
    Decl cached_expensive(X.Type<int>, Y.Type<int>).
    
    cached_expensive(X, Y) :- cache_entry(/expensive, X, Y).
    
    cached_expensive(X, Y) :-
        not cache_entry(/expensive, X, _),
        validated_expensive(X, Y).
        # In Go: store the result as cache_entry
    ```
    
    ---
    
    ## Anti-Pattern 8: Reflection on Types
    
    ### Wrong Approach
    ```java
    // Java reflection
    Class<?> clazz = obj.getClass();
    Field[] fields = clazz.getDeclaredFields();
    ```
    
    Attempting:
    ```mangle
    # WRONG - no type reflection
    get_type(X, Type) :-
        Type = typeof(X).  # Not available
    ```
    
    ### Why It Fails
    No runtime type information or reflection.
    
    ### Correct Mangle Way
    ```mangle
    # Tag values with types manually:
    Decl typed_value(Type.Type</atom>, Value).
    
    typed_value(/int, 42).
    typed_value(/string, "hello").
    typed_value(/atom, /example).
    
    # Query by type:
    int_values(V) :- typed_value(/int, V).
    
    # Or use separate predicates per type:
    Decl int_value(V.Type<int>).
    Decl string_value(V.Type<string>).
    
    int_value(42).
    string_value("hello").
    ```
    
    ---
    
    ## Anti-Pattern 9: Dynamic Schema Evolution
    
    ### Wrong Approach
    ```sql
    -- SQL ALTER TABLE
    ALTER TABLE users ADD COLUMN email VARCHAR(255);
    ```
    
    Attempting:
    ```mangle
    # WRONG - can't alter schema at runtime
    alter_schema() :-
        add_field(user, /email, Type<string>).  # Not possible
    ```
    
    ### Why It Fails
    Schema (Decl statements) is static. Can't add predicates or fields at runtime.
    
    ### Correct Mangle Way
    ```mangle
    # Pre-declare all possible fields:
    Decl user(Id.Type</atom>, Name.Type<string>).
    Decl user_email(Id.Type</atom>, Email.Type<string>).  # Optional field
    Decl user_phone(Id.Type</atom>, Phone.Type<string>).  # Optional field
    
    # Use them as needed:
    user(/u1, "Alice").
    user_email(/u1, "alice@example.com").  # Email present
    # No user_phone for u1 = phone absent
    
    # For truly dynamic schemas, generate .gl files in Go:
    // if config.EnableEmail {
    //     schema += "Decl user_email(Id.Type</atom>, Email.Type<string>).\n"
    // }
    // os.WriteFile("schema.gl", []byte(schema), 0644)
    ```
    
    ---
    
    ## Anti-Pattern 10: Quasiquotation
    
    ### Wrong Approach
    ```lisp
    ; Lisp quasiquotation
    `(+ 1 ,(* 2 3))  ; => (+ 1 6)
    ```
    
    Attempting:
    ```mangle
    # WRONG - no quasiquotation
    template(Expr) :-
        Expr = `add(1, ~{multiply(2, 3)})`.  # Not possible
    ```
    
    ### Why It Fails
    No quasiquotation or template syntax.
    
    ### Correct Mangle Way
    ```mangle
    # Build expressions as data structures:
    Decl expr(Id.Type</atom>, Op.Type</atom>).
    Decl expr_arg(ExprId.Type</atom>, Index.Type<int>, ArgId.Type</atom>).
    Decl expr_const(Id.Type</atom>, Value.Type<int>).
    
    # Build: add(1, multiply(2, 3))
    expr(/e1, /add).
    expr_arg(/e1, 0, /c1).
    expr_const(/c1, 1).
    expr_arg(/e1, 1, /e2).
    expr(/e2, /multiply).
    expr_arg(/e2, 0, /c2).
    expr_const(/c2, 2).
    expr_arg(/e2, 1, /c3).
    expr_const(/c3, 3).
    
    # Evaluate the expression tree
    ```
    
    ---
    
    ## Anti-Pattern 11: Multiple Dispatch
    
    ### Wrong Approach
    ```julia
    # Julia multiple dispatch
    function process(x::Int, y::Int)
        return x + y
    end
    
    function process(x::String, y::String)
        return x * y  # String concatenation
    end
    ```
    
    Attempting:
    ```mangle
    # WRONG - no multiple dispatch
    Decl process(X, Y, Result).
    
    process(X.Type<int>, Y.Type<int>, Result) :- # Can't specialize in head
        Result = fn:plus(X, Y).
    ```
    
    ### Why It Fails
    No multiple dispatch or pattern matching on types in predicate heads.
    
    ### Correct Mangle Way
    ```mangle
    # Use separate predicate names:
    Decl process_int(X.Type<int>, Y.Type<int>, Result.Type<int>).
    Decl process_string(X.Type<string>, Y.Type<string>, Result.Type<string>).
    
    process_int(X, Y, Result) :- Result = fn:plus(X, Y).
    process_string(X, Y, Result) :- fn:string_concat([X, Y], Result).
    
    # Or use tagged unions:
    Decl process(XType.Type</atom>, X, YType.Type</atom>, Y, Result).
    
    process(/int, X, /int, Y, Result) :-
        Result = fn:plus(X, Y).
    
    process(/string, X, /string, Y, Result) :-
        fn:string_concat([X, Y], Result).
    ```
    
    ---
    
    ## Anti-Pattern 12: Lazy Evaluation Control
    
    ### Wrong Approach
    ```haskell
    -- Haskell lazy evaluation
    let expensive = veryExpensiveComputation x
    in if condition
       then expensive  -- Only computed if condition is true
       else 0
    ```
    
    Attempting:
    ```mangle
    # WRONG - no lazy evaluation control
    result(R) :-
        lazy Expensive = expensive_computation(X),  # Not lazy
        condition(true),
        R = Expensive.
    ```
    
    ### Why It Fails
    No lazy evaluation primitives. Everything is eagerly evaluated (fixed-point).
    
    ### Correct Mangle Way
    ```mangle
    # Mangle evaluates everything to fixed-point
    # To avoid expensive computation, filter first:
    result(R) :-
        condition(true),  # Check condition first
        specific_case(X),  # Narrow down inputs
        expensive_computation(X, R).  # Only computed for matching X
    
    # Or compute lazily in Go:
    // if condition {
    //     result := expensiveComputation(x)
    //     store.Add(engine.NewAtom("result", engine.Number(result)))
    // }
    ```
    
    ---
    
    ## Pattern: Code Generation Workflow
    
    For meta-programming needs, use **Go to generate Mangle code**:
    
    ### Example: Generate Predicates from Schema
    
    ```go
    type Field struct {
        Name string
        Type string
    }
    
    type Table struct {
        Name   string
        Fields []Field
    }
    
    func generateMangleSchema(tables []Table) string {
        var sb strings.Builder
    
        for _, table := range tables {
            // Generate Decl
            sb.WriteString(fmt.Sprintf("Decl %s(", table.Name))
            for i, field := range table.Fields {
                if i > 0 {
                    sb.WriteString(", ")
                }
                sb.WriteString(fmt.Sprintf("%s.Type<%s>", field.Name, field.Type))
            }
            sb.WriteString(").\n\n")
        }
    
        return sb.String()
    }
    
    // Usage:
    tables := []Table{
        {Name: "user", Fields: []Field{
            {Name: "Id", Type: "</atom>"},
            {Name: "Name", Type: "<string>"},
        }},
    }
    
    schema := generateMangleSchema(tables)
    os.WriteFile("generated_schema.gl", []byte(schema), 0644)
    ```
    
    ---
    
    ## Key Principle: No Runtime Meta-Programming
    
    | Meta-Programming Feature | Mangle Alternative |
    |--------------------------|-------------------|
    | Macros | Generate .gl files in Go |
    | Templates | Generate .gl files in Go |
    | Compile-time computation | Pre-compute in Go |
    | Code as data | Represent AST as facts |
    | Aspect-oriented programming | Manual wrappers |
    | Self-modifying code | Versioned predicates |
    | Decorators | Manual composition |
    | Type reflection | Manual type tags |
    | Dynamic schema | Pre-declare all, or generate .gl |
    | Quasiquotation | Explicit AST construction |
    | Multiple dispatch | Separate predicates or tags |
    | Lazy evaluation control | Filter early, or compute in Go |
    
    ---
    
    ## Migration Checklist
    
    When translating meta-programming to Mangle:
    
    - [ ] Replace macros with Go code generation
    - [ ] Replace templates with Go code generation
    - [ ] Move compile-time computation to Go
    - [ ] Represent code as AST facts if needed
    - [ ] Replace AOP with manual wrappers
    - [ ] Replace self-modifying code with versioned predicates
    - [ ] Replace decorators with explicit composition
    - [ ] Add manual type tags for reflection
    - [ ] Pre-declare all schema, or generate .gl files
    - [ ] Build AST explicitly, no quasiquotation
    - [ ] Use separate predicates for dispatch
    - [ ] Control evaluation order through filtering
    - [ ] Remember: Mangle schema is static, data is dynamic
    
    ---
    
    ## Pro Tip: Mangle + Go = Powerful Meta-Programming
    
    While Mangle lacks runtime meta-programming, the combination of **Go for code generation** and **Mangle for logic** is powerful:
    
    ```go
    // Go generates Mangle code
    func generateRules(config Config) string {
        var rules strings.Builder
    
        // Generate predicates based on config
        for _, entity := range config.Entities {
            rules.WriteString(generatePredicateFor(entity))
        }
    
        return rules.String()
    }
    
    // Write generated code
    generated := generateRules(loadConfig())
    os.WriteFile("generated.gl", []byte(generated), 0644)
    
    // Load and evaluate
    program := loadMangleProgram("schema.gl", "generated.gl", "rules.gl")
    engine.EvalProgram(program)
    ```
    
    This gives you:
    - **Static analysis** (Mangle schemas are checkable)
    - **Type safety** (Go generates well-typed predicates)
    - **Flexibility** (Generate whatever you need)
    - **Performance** (No runtime interpretation overhead)
    
    Think of Go as your meta-programming layer, and Mangle as your logic layer.
