# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: antipatterns/mutation.md

- id: "language/mangle/docs/antipatterns/mutation"
  category: "language"
  subcategory: "mangle"
  description: "Anti-Pattern: Mutation"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Anti-Pattern: Mutation
    
    ## Category
    Paradigm Mismatch (Immutable Logic vs Mutable State)
    
    ## Description
    Trying to mutate facts, update values in place, or modify state when Mangle is purely functional and immutable. Facts are eternal truths that derive from other facts.
    
    ---
    
    ## Anti-Pattern 1: In-Place Update
    
    ### Wrong Approach
    ```python
    user.age = 26  # Mutate age field
    counter += 1   # Increment counter
    ```
    
    Attempting:
    ```mangle
    # WRONG - trying to update in place
    update_age(User) :-
        user(User, Name, 25),
        user(User, Name, 26).  # Can't change existing fact!
    ```
    
    ### Why It Fails
    Facts are **immutable**. Once `user(/u1, "Alice", 25)` is asserted, it stays true.
    
    ### Correct Mangle Way
    ```mangle
    # Option 1: Retract old fact and add new one (in Go)
    // old := store.Query("user", userId, name, 25)
    // store.Retract(old)
    // store.Add(engine.NewAtom("user", userId, name, 26))
    
    # Option 2: Model state transitions with time/version
    Decl user(Id.Type</atom>, Name.Type<string>, Age.Type<int>, Version.Type<int>).
    
    user(/u1, "Alice", 25, 1).  # Version 1
    user(/u1, "Alice", 26, 2).  # Version 2 (new fact, old still exists)
    
    # Get current state (latest version):
    current_user(Id, Name, Age) :-
        user(Id, Name, Age, Ver)
        |> do fn:group_by(Id)
        |> let MaxVer = fn:Max(Ver)
        |> where Ver = MaxVer.
    
    # Option 3: Derive new state from change requests
    Decl user(Id.Type</atom>, Name.Type<string>, Age.Type<int>).
    Decl age_change(Id.Type</atom>, NewAge.Type<int>).
    
    user(/u1, "Alice", 25).
    age_change(/u1, 26).
    
    # Derive updated state:
    updated_user(Id, Name, NewAge) :-
        user(Id, Name, _),
        age_change(Id, NewAge).
    ```
    
    **Key Insight:** Don't mutate facts; create new facts representing the new state.
    
    ---
    
    ## Anti-Pattern 2: Incrementing Counters
    
    ### Wrong Approach
    ```c
    int counter = 0;
    counter++;
    counter++;
    // counter = 2
    ```
    
    Attempting:
    ```mangle
    # WRONG - trying to increment
    increment(Counter) :-
        counter(Counter),
        Counter = Counter + 1.  # Counter can't equal two values!
    ```
    
    ### Why It Fails
    A variable can't be bound to two different values. `Counter = N` and `Counter = N + 1` is a contradiction.
    
    ### Correct Mangle Way
    ```mangle
    # Option 1: Model counter history with step indices
    Decl counter(Step.Type<int>, Value.Type<int>).
    
    counter(0, 0).  # Initial state
    
    counter(Step, Value) :-
        counter(PrevStep, PrevValue),
        PrevStep < 100,  # Safety limit!
        Step = fn:plus(PrevStep, 1),
        Value = fn:plus(PrevValue, 1).
    
    # Option 2: Derive total from increment events
    Decl increment_event(Id.Type</atom>).
    
    # Load events:
    increment_event(/e1).
    increment_event(/e2).
    
    total_increments(Count) :-
        increment_event(_)
        |> do fn:group_by()
        |> let Count = fn:Count(/e1).  # Dummy grouping variable
    
    # Option 3: Mutate in Go
    // counter := store.Query("counter", value)
    // store.Retract(counter)
    // store.Add(engine.NewAtom("counter", value + 1))
    ```
    
    ---
    
    ## Anti-Pattern 3: Array/List Mutation
    
    ### Wrong Approach
    ```javascript
    let arr = [1, 2, 3];
    arr.push(4);      // Mutate array
    arr[0] = 10;      // Update element
    ```
    
    Attempting:
    ```mangle
    # WRONG - trying to mutate list
    update_list(List) :-
        list(List),
        List.push(4).  # No push method!
    ```
    
    ### Why It Fails
    Lists are immutable. No `push`, `pop`, or index assignment.
    
    ### Correct Mangle Way
    ```mangle
    # Option 1: Create new list with modifications
    Decl my_list(Items.Type<list>).
    
    my_list([1, 2, 3]).
    
    # "Add" element = derive new list
    extended_list(NewList) :-
        my_list(OldList),
        :match_cons(OldList, Head, Tail),  # Decompose
        NewList = [Head, Tail, 4].  # Construct new list (if supported)
    
    # Or use fn:list:append (if available):
    extended_list(NewList) :-
        my_list(OldList),
        fn:list:append(OldList, 4, NewList).
    
    # Option 2: Model list elements as separate facts
    Decl list_element(Index.Type<int>, Value.Type<int>).
    
    list_element(0, 1).
    list_element(1, 2).
    list_element(2, 3).
    
    # "Add" element:
    list_element(3, 4).
    
    # Option 3: Retract and replace in Go
    // old := store.Query("my_list", oldList)
    // newList := append(oldList, 4)
    // store.Retract(old)
    // store.Add(engine.NewAtom("my_list", newList))
    ```
    
    ---
    
    ## Anti-Pattern 4: Field Assignment
    
    ### Wrong Approach
    ```java
    user.name = "Bob";
    user.status = "active";
    ```
    
    Attempting:
    ```mangle
    # WRONG - trying to assign fields
    update_user(User) :-
        User.name = "Bob",
        User.status = /active.
    ```
    
    ### Why It Fails
    No field assignment syntax. Facts are immutable tuples.
    
    ### Correct Mangle Way
    ```mangle
    # Option 1: Separate predicates for each field
    Decl user(Id.Type</atom>).
    Decl user_name(Id.Type</atom>, Name.Type<string>).
    Decl user_status(Id.Type</atom>, Status.Type</atom>).
    
    user(/u1).
    user_name(/u1, "Alice").
    user_status(/u1, /inactive).
    
    # "Update" by retracting and adding in Go:
    // store.Retract(engine.NewAtom("user_name", /u1, "Alice"))
    // store.Add(engine.NewAtom("user_name", /u1, "Bob"))
    
    # Option 2: Derive updated state
    Decl name_change(Id.Type</atom>, NewName.Type<string>).
    
    name_change(/u1, "Bob").
    
    updated_name(Id, NewName) :-
        user_name(Id, _),
        name_change(Id, NewName).
    
    # Option 3: Versioned facts
    Decl user(Id.Type</atom>, Name.Type<string>, Status.Type</atom>, Ver.Type<int>).
    
    user(/u1, "Alice", /inactive, 1).
    user(/u1, "Bob", /active, 2).
    
    current_user(Id, Name, Status) :-
        user(Id, Name, Status, Ver)
        |> do fn:group_by(Id)
        |> let MaxVer = fn:Max(Ver)
        |> where Ver = MaxVer.
    ```
    
    ---
    
    ## Anti-Pattern 5: Deleting Items
    
    ### Wrong Approach
    ```python
    users.remove(user)
    del array[index]
    ```
    
    Attempting:
    ```mangle
    # WRONG - no delete operation
    delete_user(User) :-
        user(User),
        delete user(User).  # Not a thing!
    ```
    
    ### Why It Fails
    No `delete` keyword. Facts are eternal (within a session).
    
    ### Correct Mangle Way
    ```mangle
    # Option 1: Retract in Go
    // fact := store.Query("user", userId)
    // store.Retract(fact)
    
    # Option 2: Mark as deleted (soft delete)
    Decl user(Id.Type</atom>, Name.Type<string>).
    Decl deleted_user(Id.Type</atom>).
    
    user(/u1, "Alice").
    user(/u2, "Bob").
    
    deleted_user(/u2).  # Mark as deleted
    
    # Query only active users:
    active_user(Id, Name) :-
        user(Id, Name),
        not deleted_user(Id).
    
    # Option 3: Versioned with tombstone
    Decl user(Id.Type</atom>, Name.Type<string>, Ver.Type<int>).
    Decl user_tombstone(Id.Type</atom>, Ver.Type<int>).
    
    user(/u1, "Alice", 1).
    user_tombstone(/u1, 2).  # Deleted at version 2
    
    current_user(Id, Name) :-
        user(Id, Name, Ver),
        not user_tombstone(Id, TombVer),
        Ver > TombVer.  # User created after tombstone (if resurrected)
    ```
    
    ---
    
    ## Anti-Pattern 6: Accumulator Pattern
    
    ### Wrong Approach
    ```python
    total = 0
    for item in items:
        total += item.value
    ```
    
    Attempting:
    ```mangle
    # WRONG - trying to accumulate
    accumulate(Total) :-
        Total = 0,
        item(Value),
        Total = Total + Value.  # Total can't change!
    ```
    
    ### Why It Fails
    Variables are bindings, not storage. `Total` can't be 0 and then 0 + Value.
    
    ### Correct Mangle Way
    ```mangle
    # Use aggregation:
    total(Sum) :-
        item(Value)
        |> do fn:group_by()
        |> let Sum = fn:Sum(Value).
    
    # Or recursive accumulation (for learning):
    Decl item_list(Items.Type<list>).
    item_list([10, 20, 30]).
    
    total(Sum) :-
        item_list(Items),
        sum_list(Items, Sum).
    
    Decl sum_list(List.Type<list>, Sum.Type<int>).
    
    sum_list([], 0).
    
    sum_list(List, Sum) :-
        :match_cons(List, Head, Tail),
        sum_list(Tail, TailSum),
        Sum = fn:plus(Head, TailSum).
    ```
    
    ---
    
    ## Anti-Pattern 7: Clearing Collections
    
    ### Wrong Approach
    ```python
    cache.clear()
    items = []
    ```
    
    Attempting:
    ```mangle
    # WRONG - trying to clear
    clear_cache() :-
        cache(Items),
        Items = [].  # Can't reassign!
    ```
    
    ### Why It Fails
    Can't clear or empty a collection. Facts are immutable.
    
    ### Correct Mangle Way
    ```mangle
    # Option 1: Retract all facts in Go
    // results := store.Query("cache", X)
    // for _, r := range results {
    //     store.Retract(r)
    // }
    
    # Option 2: Versioned cache
    Decl cache(Key.Type<string>, Value.Type<int>, Ver.Type<int>).
    
    cache("a", 1, 1).
    cache("b", 2, 1).
    
    # "Clear" = new empty version
    # (No cache facts with Ver=2)
    
    # "Add to new cache":
    cache("c", 3, 2).
    
    active_cache(Key, Value) :-
        cache(Key, Value, Ver),
        current_version(Ver).
    
    # Option 3: Invalidation predicate
    Decl cache_invalidated(Version.Type<int>).
    
    cache_invalidated(1).  # Version 1 is invalid
    
    valid_cache(Key, Value) :-
        cache(Key, Value, Ver),
        not cache_invalidated(Ver).
    ```
    
    ---
    
    ## Anti-Pattern 8: Swapping Values
    
    ### Wrong Approach
    ```python
    a, b = b, a  # Swap
    temp = a
    a = b
    b = temp
    ```
    
    Attempting:
    ```mangle
    # WRONG - trying to swap
    swap(A, B) :-
        value(/a, A),
        value(/b, B),
        value(/a, B),  # Contradiction!
        value(/b, A).
    ```
    
    ### Why It Fails
    Can't reassign values. Facts are immutable.
    
    ### Correct Mangle Way
    ```mangle
    # Option 1: Derive swapped state
    Decl value(Key.Type</atom>, Val.Type<int>).
    
    value(/a, 10).
    value(/b, 20).
    
    swapped_value(/a, B) :- value(/b, B).
    swapped_value(/b, A) :- value(/a, A).
    
    # Option 2: Retract and re-add in Go
    // valA := store.Query("value", /a, x)
    // valB := store.Query("value", /b, y)
    // store.Retract(valA)
    // store.Retract(valB)
    // store.Add(engine.NewAtom("value", /a, y))
    // store.Add(engine.NewAtom("value", /b, x))
    
    # Option 3: Versioned swap
    Decl value(Key.Type</atom>, Val.Type<int>, Ver.Type<int>).
    
    value(/a, 10, 1).
    value(/b, 20, 1).
    
    # Swapped state:
    value(/a, 20, 2).
    value(/b, 10, 2).
    ```
    
    ---
    
    ## Anti-Pattern 9: Resetting State
    
    ### Wrong Approach
    ```python
    state = "initial"
    # ... do work ...
    state = "initial"  # Reset
    ```
    
    Attempting:
    ```mangle
    # WRONG - trying to reset
    reset() :-
        state(/current, /processing),
        state(/current, /initial).  # Can't have both!
    ```
    
    ### Why It Fails
    Can't reset by reassignment. Both facts would exist.
    
    ### Correct Mangle Way
    ```mangle
    # Option 1: Versioned state
    Decl state(Name.Type</atom>, Value.Type</atom>, Ver.Type<int>).
    
    state(/current, /initial, 0).
    state(/current, /processing, 1).
    state(/current, /initial, 2).  # Reset
    
    current_state(Name, Value) :-
        state(Name, Value, Ver)
        |> do fn:group_by(Name)
        |> let MaxVer = fn:Max(Ver)
        |> where Ver = MaxVer.
    
    # Option 2: Retract in Go
    // old := store.Query("state", /current, /processing)
    // store.Retract(old)
    // store.Add(engine.NewAtom("state", /current, /initial))
    
    # Option 3: State transition cycle
    Decl state(Value.Type</atom>).
    Decl transition(From.Type</atom>, To.Type</atom>).
    
    transition(/initial, /processing).
    transition(/processing, /complete).
    transition(/complete, /initial).  # Reset transition
    
    # Derive next state:
    next_state(To) :-
        state(From),
        transition(From, To).
    ```
    
    ---
    
    ## Anti-Pattern 10: Toggling Boolean
    
    ### Wrong Approach
    ```python
    enabled = not enabled  # Toggle
    flag = !flag
    ```
    
    Attempting:
    ```mangle
    # WRONG - trying to toggle
    toggle(Flag) :-
        Flag = not Flag.  # Contradiction!
    ```
    
    ### Why It Fails
    A variable can't be both `X` and `not X`.
    
    ### Correct Mangle Way
    ```mangle
    # Option 1: Separate on/off predicates
    Decl feature_on(Name.Type</atom>).
    Decl feature_off(Name.Type</atom>).
    
    feature_on(/dark_mode).
    
    # Toggle by retracting one and adding the other (in Go):
    // if store.Query("feature_on", /dark_mode) exists:
    //     store.Retract(...)
    //     store.Add(engine.NewAtom("feature_off", /dark_mode))
    
    # Option 2: Versioned boolean
    Decl feature(Name.Type</atom>, Enabled.Type<bool>, Ver.Type<int>).
    
    feature(/dark_mode, true, 1).
    feature(/dark_mode, false, 2).  # Toggled
    feature(/dark_mode, true, 3).   # Toggled again
    
    current_feature(Name, Enabled) :-
        feature(Name, Enabled, Ver)
        |> do fn:group_by(Name)
        |> let MaxVer = fn:Max(Ver)
        |> where Ver = MaxVer.
    
    # Option 3: Toggle event stream
    Decl toggle_event(Name.Type</atom>, EventId.Type<int>).
    
    toggle_event(/dark_mode, 1).
    toggle_event(/dark_mode, 2).
    toggle_event(/dark_mode, 3).
    
    # Odd count = on, even = off
    feature_enabled(Name) :-
        toggle_event(Name, _)
        |> do fn:group_by(Name)
        |> let Count = fn:Count(Name),
        fn:mod(Count, 2) = 1.
    ```
    
    ---
    
    ## Pattern: Modeling Mutable State in Immutable Logic
    
    ### 1. Event Sourcing
    
    Store events, derive current state:
    
    ```mangle
    Decl balance_change(AccountId.Type</atom>, Amount.Type<int>, EventId.Type<int>).
    
    balance_change(/acc1, 100, 1).   # Deposit
    balance_change(/acc1, -50, 2).   # Withdrawal
    balance_change(/acc1, 200, 3).   # Deposit
    
    current_balance(AccountId, Balance) :-
        balance_change(AccountId, Amount, _)
        |> do fn:group_by(AccountId)
        |> let Balance = fn:Sum(Amount).
    ```
    
    ### 2. Versioned Facts
    
    Include version/timestamp in facts:
    
    ```mangle
    Decl user(Id.Type</atom>, Name.Type<string>, Email.Type<string>, Ver.Type<int>).
    
    user(/u1, "Alice", "alice@old.com", 1).
    user(/u1, "Alice", "alice@new.com", 2).
    
    latest_user(Id, Name, Email) :-
        user(Id, Name, Email, Ver)
        |> do fn:group_by(Id)
        |> let MaxVer = fn:Max(Ver)
        |> where Ver = MaxVer.
    ```
    
    ### 3. Soft Deletes / Tombstones
    
    Mark as deleted instead of removing:
    
    ```mangle
    Decl item(Id.Type</atom>, Name.Type<string>).
    Decl deleted(Id.Type</atom>).
    
    item(/i1, "Widget").
    item(/i2, "Gadget").
    
    deleted(/i2).
    
    active_item(Id, Name) :-
        item(Id, Name),
        not deleted(Id).
    ```
    
    ### 4. Retract-and-Replace (Go API)
    
    For true mutation, use Go:
    
    ```go
    // Fetch current fact
    results := store.Query("user", userId, name, age)
    if len(results) > 0 {
        old := results[0]
        // Retract old fact
        store.Retract(old)
        // Add new fact
        store.Add(engine.NewAtom("user", userId, newName, newAge))
    }
    ```
    
    ---
    
    ## Key Principle: Immutability
    
    | Mutable Thinking | Immutable Thinking (Mangle) |
    |------------------|----------------------------|
    | Update in place | Create new fact, optionally retract old |
    | Increment counter | Derive next value from previous |
    | Mutate array | Create new array with changes |
    | Assign field | Retract old tuple, add new tuple |
    | Delete item | Retract fact or mark as deleted |
    | Accumulate value | Use aggregation |
    | Clear collection | Retract all or use version invalidation |
    | Swap values | Derive swapped facts |
    | Reset state | Add new versioned fact |
    | Toggle boolean | Derive from event count or version |
    
    ---
    
    ## Migration Checklist
    
    When translating mutable code to Mangle:
    
    - [ ] Replace in-place updates with new facts
    - [ ] Replace counter increments with versioned values or aggregation
    - [ ] Replace array mutation with new arrays or element facts
    - [ ] Replace field assignments with retract-and-replace
    - [ ] Replace deletes with soft deletes or Go API retraction
    - [ ] Replace accumulators with aggregation functions
    - [ ] Replace collection clearing with version invalidation
    - [ ] Replace swaps with derived swapped facts
    - [ ] Replace resets with new versioned facts
    - [ ] Replace toggles with version-based or event-count derivation
    - [ ] Consider event sourcing for complex state
    - [ ] Remember: facts are eternal (until retracted in Go)
    
    ---
    
    ## Pro Tip: Embrace Immutability
    
    Don't fight immutability - use it as a feature:
    
    - **Audit trail**: All versions exist, automatic history
    - **Time travel**: Query "What was the state at version 5?"
    - **Reproducibility**: Same facts always derive same results
    - **Debugging**: No hidden state changes to track down
    
    Think of Mangle as a database with automatic versioning, not a mutable program.
