# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: errors/analysis_errors.md

- id: "language/mangle/docs/errors/analysis_errors"
  category: "language"
  subcategory: "mangle"
  description: "Mangle Analysis Errors Reference"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle Analysis Errors Reference
    
    Complete catalog of static analysis errors (safety, stratification, variable binding).
    
    ---
    
    ## 1. Stratification Violations
    
    ### 1.1 Program Cannot Be Stratified
    
    **Error Pattern:**
    ```
    stratification: program cannot be stratified
    ```
    
    **What Causes It:**
    - Cyclic dependency through negation
    - A predicate depends on its own negation (directly or indirectly)
    - Violates the stratification requirement for safe negation
    
    **Exact Message:**
    ```
    stratification: program cannot be stratified
    ```
    
    **Reproducing Example:**
    ```mangle
    # WRONG - mutual negation cycle
    winning(X) :- position(X), !losing(X).
    losing(X) :- position(X), !winning(X).
    
    # Creates cycle: winning → ¬losing → ¬winning
    ```
    
    **Why It's Unsafe:**
    This creates logical paradox:
    - If `winning(a)` is true, then `losing(a)` must be false
    - If `losing(a)` is false, then `winning(a)` must be true
    - Circular dependency with no base case
    
    **How to Fix:**
    
    **Option 1:** Add base cases
    ```mangle
    # CORRECT - break cycle with base case
    losing(X) :- position(X), !has_move(X).
    winning(X) :- move(X, Y), losing(Y).
    ```
    
    **Option 2:** Restructure logic into layers (strata)
    ```mangle
    # CORRECT - stratified into layers
    # Stratum 0: Base facts
    terminal(X) :- position(X), !has_move(X).
    
    # Stratum 1: Derive losing positions
    losing(X) :- terminal(X).
    losing(X) :- position(X), all_moves_losing(X).
    
    # Stratum 2: Check all moves (no negation of stratum 1)
    all_moves_losing(X) :- move(X, Y), losing(Y).
    ```
    
    **Option 3:** Use positive formulation
    ```mangle
    # CORRECT - avoid negation cycle
    has_winning_move(X) :- move(X, Y), !has_winning_move(Y).
    losing(X) :- !has_winning_move(X).
    ```
    
    **Related Errors:**
    - Unsafe variable errors (often co-occur)
    - Infinite recursion
    
    ---
    
    ## 2. Unsafe Variable Errors
    
    ### 2.1 Variable Not Bound in Rule
    
    **Error Pattern:**
    ```
    variable <Var> is not bound in <clause>
    ```
    
    **Exact Message:**
    ```
    variable Y is not bound in result(X, Y) :- source(X)
    ```
    
    **What Causes It:**
    - Variable appears in head but not in any positive body predicate
    - The variable has no source to bind its value
    
    **Reproducing Example:**
    ```mangle
    # WRONG - Y appears in head but not body
    result(X, Y) :- source(X).
    ```
    
    **Why It's Unsafe:**
    The rule would need to generate infinite facts:
    - `result(a, 1).`
    - `result(a, 2).`
    - `result(a, 3).`
    - ... (Y can be anything)
    
    **How to Fix:**
    
    **Option 1:** Add binding predicate
    ```mangle
    # CORRECT - bind Y from another predicate
    result(X, Y) :- source(X), target(Y).
    ```
    
    **Option 2:** Remove unbounded variable
    ```mangle
    # CORRECT - remove Y if not needed
    result(X) :- source(X).
    ```
    
    **Option 3:** Use constant or computation
    ```mangle
    # CORRECT - compute Y from X
    result(X, Y) :- source(X), Y = fn:plus(X, 1).
    ```
    
    ---
    
    ### 2.2 Variable Will Not Have Value Yet
    
    **Error Pattern:**
    ```
    variable <Var> in <predicate> will not have a value yet; move the subgoal to the right
    ```
    
    **Exact Message:**
    ```
    variable X in compute(X, Y) will not have a value yet; move the subgoal to the right
    ```
    
    **What Causes It:**
    - Variable used before it's bound
    - Order of predicates matters in Mangle body evaluation
    
    **Reproducing Example:**
    ```mangle
    # WRONG - X used before bound
    result(Y) :- Y = fn:plus(X, 1), source(X).
                  # ^^^^^^^^^^^^^^ X not bound yet!
    ```
    
    **How to Fix:**
    ```mangle
    # CORRECT - bind X first, then use it
    result(Y) :- source(X), Y = fn:plus(X, 1).
    ```
    
    **Important:** Mangle evaluates body predicates **left to right**. Bind variables before using them.
    
    ---
    
    ### 2.3 Variable Not Bound in Apply Expression
    
    **Error Pattern:**
    ```
    variable <Var> in apply expression <expr> not bound
    ```
    
    **Exact Message:**
    ```
    variable X in apply expression fn:plus(X, 1) not bound
    ```
    
    **What Causes It:**
    - Function call uses unbound variable
    - Variable must be bound before function application
    
    **Reproducing Example:**
    ```mangle
    # WRONG - X unbound in function
    result(Y) :- Y = fn:plus(X, 1).
    ```
    
    **How to Fix:**
    ```mangle
    # CORRECT - bind X first
    result(Y) :- source(X), Y = fn:plus(X, 1).
    ```
    
    ---
    
    ### 2.4 Variable in Negation Not Bound
    
    **Error Pattern:**
    ```
    variable <Var> in negated predicate must be bound by positive predicate
    ```
    
    **What Causes It:**
    - Variable appears only in negated predicate
    - Safety rule: all variables in negation must be bound elsewhere
    
    **Reproducing Example:**
    ```mangle
    # WRONG - X only appears in negation
    blocked(Y) :- category(Y), !permitted(X).
                  # X has no binding!
    ```
    
    **Why It's Unsafe:**
    This would require checking `!permitted(X)` for ALL possible X values (infinite).
    
    **How to Fix:**
    
    **Option 1:** Bind variable positively first
    ```mangle
    # CORRECT - bind X from positive predicate
    blocked(Y) :- category(Y), action(X), !permitted(X).
    ```
    
    **Option 2:** Use bound variables only
    ```mangle
    # CORRECT - use Y which is bound
    blocked(Y) :- category(Y), !permitted(Y).
    ```
    
    **Option 3:** Remove unneeded variable
    ```mangle
    # CORRECT - if X isn't needed, remove it
    blocked(Y) :- category(Y), !has_permission.
    ```
    
    ---
    
    ## 3. Variable Binding in Transforms
    
    ### 3.1 Transform Redefines Variable
    
    **Error Pattern:**
    ```
    the transform of clause <clause> redefines variable <Var> from rule body
    ```
    
    **What Causes It:**
    - Transform (aggregation/let) tries to rebind a variable from the body
    - Each variable can only be bound once
    
    **Reproducing Example:**
    ```mangle
    # WRONG - X redefined in transform
    result(X) :- source(X, Y) |> do fn:group_by(Y), let X = fn:Count().
                                  # ^^^^^ X already bound!
    ```
    
    **How to Fix:**
    ```mangle
    # CORRECT - use a different variable name
    result(Count) :- source(X, Y) |> do fn:group_by(Y), let Count = fn:Count().
    ```
    
    ---
    
    ### 3.2 Variable Used in Transform Not in Clause
    
    **Error Pattern:**
    ```
    variable <Var> used in transform <transform> does not appear in clause <clause>
    ```
    
    **What Causes It:**
    - Transform references variable not in the body
    - All transform variables must be from the body
    
    **Reproducing Example:**
    ```mangle
    # WRONG - Z not in body
    result(Total) :- source(X) |> do fn:group_by(Y), let Total = fn:Sum(Z).
                                  # Y and Z never appear in body!
    ```
    
    **How to Fix:**
    ```mangle
    # CORRECT - all variables in transform are in body
    result(Total) :- source(X, Y) |> do fn:group_by(Y), let Total = fn:Sum(X).
    ```
    
    ---
    
    ### 3.3 Do-Transforms Cannot Have Variable
    
    **Error Pattern:**
    ```
    do-transforms cannot have a variable <clause>
    ```
    
    **What Causes It:**
    - Using variable as function in `do` transform
    - `do` expects a function call, not a variable
    
    **Reproducing Example:**
    ```mangle
    # WRONG - Fn is a variable
    result(X) :- source(X) |> do Fn.
    ```
    
    **How to Fix:**
    ```mangle
    # CORRECT - use actual function
    result(X) :- source(X) |> do fn:group_by(X).
    ```
    
    ---
    
    ### 3.4 Variable Must Be Part of Group By or Aggregated
    
    **Error Pattern:**
    ```
    in <clause>, variable <Var> in function <fn> must be either part of group_by or defined in the transform
    ```
    
    **What Causes It:**
    - Using variable in aggregation that isn't grouped or being aggregated
    - Variables in transform must be either grouped by or in an aggregation function
    
    **Reproducing Example:**
    ```mangle
    # WRONG - X not grouped, Y used outside aggregation
    result(X, Y, Total) :-
        source(X, Y, Z) |>
        do fn:group_by(X),
        let Total = fn:Sum(Z).
        # Y is neither grouped nor aggregated!
    ```
    
    **How to Fix:**
    
    **Option 1:** Add to group_by
    ```mangle
    # CORRECT - group by both X and Y
    result(X, Y, Total) :-
        source(X, Y, Z) |>
        do fn:group_by(X, Y),
        let Total = fn:Sum(Z).
    ```
    
    **Option 2:** Remove ungrouped variable
    ```mangle
    # CORRECT - only use grouped variable
    result(X, Total) :-
        source(X, Y, Z) |>
        do fn:group_by(X),
        let Total = fn:Sum(Z).
    ```
    
    **Option 3:** Aggregate it
    ```mangle
    # CORRECT - aggregate Y
    result(X, YList, Total) :-
        source(X, Y, Z) |>
        do fn:group_by(X),
        let YList = fn:Collect(Y),
        let Total = fn:Sum(Z).
    ```
    
    ---
    
    ### 3.5 Group By Arguments Must Be Distinct Variables
    
    **Error Pattern:**
    ```
    each argument of group_by must be a distinct variable, got: <groupby>
    ```
    
    **What Causes It:**
    - Duplicate variables in group_by
    - Using non-variable in group_by
    
    **Reproducing Example:**
    ```mangle
    # WRONG - X appears twice
    result(X) :- source(X, Y) |> do fn:group_by(X, X).
    
    # WRONG - using constant
    result(X) :- source(X, Y) |> do fn:group_by(X, /constant).
    ```
    
    **How to Fix:**
    ```mangle
    # CORRECT - distinct variables only
    result(X, Y) :- source(X, Y, Z) |> do fn:group_by(X, Y).
    ```
    
    ---
    
    ### 3.6 Head Variable Neither Grouped Nor Aggregated
    
    **Error Pattern:**
    ```
    head variable <Var> is neither part of group_by nor aggregated: <transform>
    ```
    
    **What Causes It:**
    - Variable in rule head but not in group_by or aggregation
    - In aggregation rules, head variables must be accounted for
    
    **Reproducing Example:**
    ```mangle
    # WRONG - Z in head but not grouped or aggregated
    result(X, Z) :-
        source(X, Y, Z) |>
        do fn:group_by(X),
        let Total = fn:Sum(Y).
        # Z appears in head but not in transform!
    ```
    
    **How to Fix:**
    
    **Option 1:** Add to group_by
    ```mangle
    result(X, Z) :-
        source(X, Y, Z) |>
        do fn:group_by(X, Z),
        let Total = fn:Sum(Y).
    ```
    
    **Option 2:** Remove from head
    ```mangle
    result(X) :-
        source(X, Y, Z) |>
        do fn:group_by(X),
        let Total = fn:Sum(Y).
    ```
    
    **Option 3:** Aggregate it
    ```mangle
    result(X, ZFirst) :-
        source(X, Y, Z) |>
        do fn:group_by(X),
        let ZFirst = fn:Pick(Z).  # Pick first Z
    ```
    
    ---
    
    ## 4. Declaration and Arity Errors
    
    ### 4.1 Predicate Declared More Than Once
    
    **Error Pattern:**
    ```
    predicate <pred> declared more than once, previous was <decl>
    ```
    
    **What Causes It:**
    - Same predicate declared multiple times with different signatures
    - Only one Decl per predicate allowed
    
    **Reproducing Example:**
    ```mangle
    # WRONG - duplicate declarations
    Decl parent(X.Type<string>, Y.Type<string>).
    Decl parent(A.Type<int>, B.Type<int>).
    ```
    
    **How to Fix:**
    
    **Option 1:** Remove duplicate
    ```mangle
    # CORRECT - single declaration
    Decl parent(X.Type<string>, Y.Type<string>).
    ```
    
    **Option 2:** Use different predicate names
    ```mangle
    # CORRECT - different predicates
    Decl parent_string(X.Type<string>, Y.Type<string>).
    Decl parent_int(A.Type<int>, B.Type<int>).
    ```
    
    ---
    
    ### 4.2 Arity Mismatch
    
    **Error Pattern:**
    ```
    <atom> does not match arity of <decl>
    ```
    
    **Exact Message:**
    ```
    parent(X, Y, Z) does not match arity of Decl parent(X, Y)
    ```
    
    **What Causes It:**
    - Predicate used with different number of arguments than declared
    - Arity must match exactly
    
    **Reproducing Example:**
    ```mangle
    Decl parent(X.Type<string>, Y.Type<string>).
    
    # WRONG - using 3 args when declared with 2
    parent(X, Y, Z) :- person(X), person(Y), person(Z).
    ```
    
    **How to Fix:**
    
    **Option 1:** Match the declaration
    ```mangle
    # CORRECT - use 2 args as declared
    parent(X, Y) :- person(X), person(Y), related(X, Y).
    ```
    
    **Option 2:** Update declaration
    ```mangle
    # CORRECT - declare with 3 args
    Decl parent(X.Type<string>, Y.Type<string>, Z.Type<string>).
    parent(X, Y, Z) :- person(X), person(Y), person(Z).
    ```
    
    ---
    
    ### 4.3 Predicate Defined Previously
    
    **Error Pattern:**
    ```
    predicate <pred> was defined previously <decl>
    ```
    
    **What Causes It:**
    - Attempting to redeclare an already declared predicate
    - Conflicting declarations
    
    **How to Fix:**
    - Remove duplicate Decl
    - Ensure each predicate has exactly one declaration
    
    ---
    
    ## 5. Transform Validation Errors
    
    ### 5.1 All Statements Following Group By Must Be Let
    
    **Error Pattern:**
    ```
    all statements following group_by have to be let-statements <clause>
    ```
    
    **What Causes It:**
    - Non-let statement after group_by in transform
    - After group_by, only let-statements are allowed
    
    **Reproducing Example:**
    ```mangle
    # WRONG - do statement after group_by
    result(X, Total) :-
        source(X, Y) |>
        do fn:group_by(X),
        do fn:filter(Y > 0).  # Can't have another do!
    ```
    
    **How to Fix:**
    ```mangle
    # CORRECT - filter before group_by, let after
    result(X, Total) :-
        source(X, Y),
        Y > 0 |>  # Filter in body, not transform
        do fn:group_by(X),
        let Total = fn:Sum(Y).
    ```
    
    ---
    
    ### 5.2 Composing Multiple Transforms Not Implemented
    
    **Error Pattern:**
    ```
    composing multiple transforms not implemented yet <clause>
    ```
    
    **What Causes It:**
    - Attempting to chain multiple transform blocks
    - Only one transform per rule currently supported
    
    **Reproducing Example:**
    ```mangle
    # WRONG - multiple |> transforms
    result(X) :-
        source(X, Y) |>
        do fn:group_by(X) |>  # Second transform not supported
        do fn:filter(Y > 0).
    ```
    
    **How to Fix:**
    ```mangle
    # CORRECT - single transform, filtering in body
    result(X) :-
        source(X, Y),
        Y > 0 |>
        do fn:group_by(X),
        let Total = fn:Sum(Y).
    ```
    
    ---
    
    ### 5.3 Cannot Have Transform Without Body
    
    **Error Pattern:**
    ```
    cannot have a transform without a body <clause>
    ```
    
    **What Causes It:**
    - Transform used without any body predicates
    - Need at least one predicate before `|>`
    
    **Reproducing Example:**
    ```mangle
    # WRONG - no body before transform
    result(Count) :- |> do fn:group_by(X), let Count = fn:Count().
    ```
    
    **How to Fix:**
    ```mangle
    # CORRECT - body before transform
    result(Count) :- source(X) |> do fn:group_by(X), let Count = fn:Count().
    ```
    
    ---
    
    ## 6. Type Context Errors
    
    ### 6.1 Variable Has Empty Type
    
    **Error Pattern:**
    ```
    variable <Var> has empty type
    ```
    
    **What Causes It:**
    - Type inference failed to determine variable type
    - Usually indicates a logic error in the rule
    
    **How to Fix:**
    - Ensure variable is bound from a predicate with declared types
    - Check that all predicates in the rule are properly declared
    
    ---
    
    ### 6.2 Variable Type Conflict
    
    **Error Pattern:**
    ```
    variable <Var> cannot have both <type1> and <type2>
    ```
    
    **What Causes It:**
    - Variable inferred to have conflicting types from different predicates
    - Type system detected inconsistency
    
    **Reproducing Example:**
    ```mangle
    Decl name_str(X.Type<string>).
    Decl age_int(X.Type<int>).
    
    # WRONG - X can't be both string and int
    result(X) :- name_str(X), age_int(X).
    ```
    
    **How to Fix:**
    ```mangle
    # CORRECT - use different variables
    result(Name, Age) :- name_str(Name), age_int(Age).
    ```
    
    ---
    
    ## Quick Diagnosis Guide
    
    | Symptom | Likely Cause | Fix |
    |---------|-------------|-----|
    | "cannot be stratified" | Negation cycle | Add base case or restructure |
    | "variable X is not bound" | Variable in head but not body | Add predicate binding X |
    | "will not have value yet" | Variable used before bound | Reorder predicates |
    | "variable in negation" | Negation without binding | Bind variable before negation |
    | "redefines variable" | Same name in body and transform | Rename transform variable |
    | "arity mismatch" | Wrong number of args | Match declaration arity |
    | "neither grouped nor aggregated" | Missing from transform | Add to group_by or aggregate |
    | "distinct variables" | Duplicate in group_by | Use each variable once |
    
    ---
    
    ## Safety Rules Summary
    
    1. **Head Safety:** Every variable in the head must appear in a positive body predicate
    2. **Negation Safety:** Every variable in a negated predicate must be bound elsewhere
    3. **Order Safety:** Variables must be bound before use (left-to-right evaluation)
    4. **Transform Safety:** Variables in transforms must be from body
    5. **Aggregation Safety:** Head variables must be grouped or aggregated
    6. **Stratification:** No predicate can depend on its own negation (directly or indirectly)
    
    ---
    
    ## Related Documentation
    
    - [parse_errors.md](./parse_errors.md) - Syntax errors
    - [type_errors.md](./type_errors.md) - Type system errors
    - [negation_safety.md](../negation_safety.md) - Negation patterns
    - [stratification.md](../stratification.md) - Stratification explained
