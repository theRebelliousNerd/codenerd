# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: errors/gas_errors.md

- id: "language/mangle/docs/errors/gas_errors"
  category: "language"
  subcategory: "mangle"
  description: "Mangle Gas/Resource Limit Errors Reference"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle Gas/Resource Limit Errors Reference
    
    Complete catalog of resource exhaustion and limit errors.
    
    ---
    
    ## Overview
    
    Mangle engines enforce resource limits to prevent runaway computations:
    - **Fact Limits:** Maximum facts in store
    - **Derived Facts Limit:** Maximum facts created by inference (gas limit)
    - **Query Timeout:** Maximum time for query execution
    - **Created Fact Limit (per rule):** Maximum facts created by single rule
    
    ---
    
    ## 1. Fact Store Limits
    
    ### 1.1 Fact Limit Exceeded
    
    **Error Pattern (codeNERD):**
    ```
    fact limit exceeded: <N>
    ```
    
    **Exact Message:**
    ```
    fact limit exceeded: 100000
    ```
    
    **What Causes It:**
    - Total facts in store exceeds configured `FactLimit`
    - Attempting to insert fact when at capacity
    - Configuration default: 100,000 facts
    
    **Reproducing Example:**
    ```go
    config := mangle.DefaultConfig()
    config.FactLimit = 1000  // Low limit for testing
    
    engine, _ := mangle.NewEngine(config, nil)
    engine.LoadSchema("schemas.mg")
    
    // Add 1001 facts
    for i := 0; i < 1001; i++ {
        err := engine.AddFact("item", i)
        if err != nil {
            // ERROR: fact limit exceeded: 1000
        }
    }
    ```
    
    **How to Fix:**
    
    **Option 1:** Increase limit
    ```go
    config := mangle.DefaultConfig()
    config.FactLimit = 500000  // Increase capacity
    
    engine, _ := mangle.NewEngine(config, nil)
    ```
    
    **Option 2:** Set unlimited
    ```go
    config := mangle.DefaultConfig()
    config.FactLimit = 0  // 0 = unlimited
    
    engine, _ := mangle.NewEngine(config, nil)
    ```
    
    **Option 3:** Remove old facts
    ```go
    // Clean up old facts before adding new ones
    engine.ReplaceFactsForFile("old_file.go", []mangle.Fact{})
    
    // Now add new facts
    engine.AddFacts(newFacts)
    ```
    
    **Option 4:** Use selective fact loading
    ```go
    // Don't load everything at once
    // Load facts on-demand per file/query
    engine.ReplaceFactsForFile(currentFile, facts)
    ```
    
    **Warning Threshold:**
    codeNERD warns at 85% capacity:
    ```
    warning: fact store is 85.0% of configured capacity (85000 / 100000)
    ```
    
    ---
    
    ### 1.2 Fact Limit Warning (codeNERD)
    
    **Pattern:**
    ```
    warning: fact store is <X>% of configured capacity (<current> / <limit>)
    ```
    
    **What It Means:**
    - Approaching fact limit (85%+ capacity)
    - Not an error yet, but warning of impending limit
    - Logged to stderr
    
    **How to Respond:**
    
    **Option 1:** Increase limit preemptively
    ```go
    config.FactLimit = 200000  // Double capacity
    ```
    
    **Option 2:** Clean up unused facts
    ```go
    // Remove facts for files no longer in project
    for _, oldFile := range removedFiles {
        engine.ReplaceFactsForFile(oldFile, []mangle.Fact{})
    }
    ```
    
    **Option 3:** Monitor and react
    ```go
    stats := engine.GetStats()
    utilization := float64(stats.TotalFacts) / float64(config.FactLimit)
    
    if utilization > 0.9 {
        // Take action before hitting limit
        cleanupOldestFacts()
    }
    ```
    
    ---
    
    ## 2. Derived Facts Limit (Gas Limit)
    
    ### 2.1 Derived Facts Limit Exceeded
    
    **Error Pattern (codeNERD):**
    ```
    derived facts limit exceeded (inference gas limit): <derived> derived facts exceeds limit of <limit>
    ```
    
    **Exact Message:**
    ```
    derived facts limit exceeded (inference gas limit): 150000 derived facts exceeds limit of 100000
    ```
    
    **What Causes It:**
    - Inference (rule evaluation) creates too many new facts
    - Gas limit prevents runaway inference
    - Default: 100,000 derived facts per session
    
    **Reproducing Example:**
    ```mangle
    # WRONG - exponential explosion
    derived(X, Y) :- base(X), base(Y).
    # If base has 1000 facts, this creates 1,000,000 derived facts!
    
    derived2(X, Y, Z) :- derived(X, Y), base(Z).
    # This creates 1,000,000,000 facts - hits gas limit!
    ```
    
    **Why It's Important:**
    - Protects against infinite inference
    - Prevents memory exhaustion
    - Detects logic errors early
    
    **How to Fix:**
    
    **Option 1:** Fix logic to reduce derivations
    ```mangle
    # CORRECT - add selectivity
    derived(X, Y) :-
        base(X),
        base(Y),
        X != Y,           # Avoid duplicates
        relevant(X, Y).   # Add filter
    
    # Now derives far fewer facts
    ```
    
    **Option 2:** Increase gas limit
    ```go
    config := mangle.DefaultConfig()
    config.DerivedFactsLimit = 500000  // More headroom
    
    engine, _ := mangle.NewEngine(config, nil)
    ```
    
    **Option 3:** Set unlimited (dangerous!)
    ```go
    config.DerivedFactsLimit = 0  // 0 = unlimited
    // WARNING: Can cause OOM if logic has infinite derivation!
    ```
    
    **Option 4:** Reset counter periodically
    ```go
    // At session boundaries, reset counter
    engine.ResetDerivedFactCount()
    
    // Useful for long-running sessions with distinct phases
    ```
    
    **Monitoring:**
    ```go
    // Check gas usage
    derivedCount := engine.GetDerivedFactCount()
    log.Printf("Derived facts so far: %d / %d",
        derivedCount, config.DerivedFactsLimit)
    
    // Warn before hitting limit
    if float64(derivedCount) / float64(config.DerivedFactsLimit) > 0.8 {
        log.Warn("Approaching gas limit!")
    }
    ```
    
    ---
    
    ### 2.2 Fact Size Limit Reached (Mangle Engine)
    
    **Error Pattern:**
    ```
    fact size limit reached evaluating "<rule>": <count> > <limit>
    fact size limit reached <count> > <limit>
    ```
    
    **Exact Message:**
    ```
    fact size limit reached evaluating "result(X, Y) :- source(X), target(Y)": 250000 > 100000
    ```
    
    **What Causes It:**
    - Semi-naive evaluation option `createdFactLimit`
    - Limit on facts created by single rule evaluation
    - Limit on total facts during evaluation
    
    **When It Occurs:**
    - Using `EvalProgram` or `EvalProgramWithStats`
    - Engine configured with fact limits
    - Cartesian product or large join creates too many facts
    
    **Reproducing Example:**
    ```mangle
    # WRONG - Cartesian product
    all_pairs(X, Y) :- item(X), item(Y).
    # If item has 10,000 facts, creates 100,000,000 pairs!
    ```
    
    **How to Fix:**
    
    **Option 1:** Add selectivity
    ```mangle
    # CORRECT - filter to reduce results
    related_pairs(X, Y) :-
        item(X),
        item(Y),
        X < Y,              # Half the pairs
        compatible(X, Y).   # Further filter
    ```
    
    **Option 2:** Configure engine limits (Go code)
    ```go
    // When using Mangle directly (not codeNERD wrapper)
    options := engine.EvalOptions{
        CreatedFactLimit: 500000,  // Per-rule limit
        TotalFactLimit:   1000000, // Overall limit
    }
    
    stats, err := engine.EvalProgramWithOptions(programInfo, store, options)
    ```
    
    **Option 3:** Split into smaller rules
    ```mangle
    # CORRECT - process in stages
    stage1(X) :- item(X), condition1(X).
    stage2(X, Y) :- stage1(X), related(X, Y).
    result(X, Y) :- stage2(X, Y), final_filter(Y).
    ```
    
    ---
    
    ## 3. Query Timeouts
    
    ### 3.1 Query Execution Timeout
    
    **Error Pattern (codeNERD):**
    ```
    query execution timed out after <duration>: context deadline exceeded
    ```
    
    **Exact Message:**
    ```
    query execution timed out after 30s: context deadline exceeded
    ```
    
    **What Causes It:**
    - Query takes longer than configured timeout
    - Default: 30 seconds (codeNERD)
    - Can be infinite loop, expensive join, or large result
    
    **Reproducing Example:**
    ```mangle
    # WRONG - infinite recursion
    infinite(X) :- infinite(X).
    
    # Query:
    ? infinite(X)
    # Runs forever until timeout
    ```
    
    **How to Fix:**
    
    **Option 1:** Fix query logic
    ```mangle
    # CORRECT - add base case
    count(0).
    count(N) :- count(M), M < 1000, N = fn:plus(M, 1).
    
    # Query:
    ? count(N)
    # Terminates with 1001 results
    ```
    
    **Option 2:** Increase timeout in config
    ```go
    config := mangle.DefaultConfig()
    config.QueryTimeout = 120  // 2 minutes
    
    engine, _ := mangle.NewEngine(config, nil)
    ```
    
    **Option 3:** Use context with custom timeout
    ```go
    // Override config timeout for specific query
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
    defer cancel()
    
    result, err := engine.Query(ctx, "expensive_query(X)")
    ```
    
    **Option 4:** Optimize query
    ```mangle
    # Add selectivity - bind variables early
    # SLOW:
    result(X, Y) :- large_table(X, Y), X = /specific.
    
    # FAST:
    result(X, Y) :- X = /specific, large_table(X, Y).
    ```
    
    ---
    
    ### 3.2 Per-Attempt Timeout (Feedback Loop)
    
    **Error Pattern (codeNERD Feedback System):**
    ```
    attempt timed out after <duration>
    ```
    
    **What Causes It:**
    - LLM call timeout during retry loop
    - Default: 60s per attempt
    
    **Configuration:**
    ```go
    config := feedback.DefaultConfig()
    config.PerAttemptTimeout = 90 * time.Second  // Longer per-attempt
    config.TotalTimeout = 300 * time.Second      // Overall budget
    ```
    
    ---
    
    ### 3.3 Total Timeout (Feedback Loop)
    
    **Error Pattern (codeNERD Feedback System):**
    ```
    total retry time budget exhausted
    ```
    
    **What Causes It:**
    - All retries combined exceed total timeout
    - Default: 180s (3 minutes) total
    
    **Configuration:**
    ```go
    config := feedback.DefaultConfig()
    config.TotalTimeout = 600 * time.Second  // 10 minutes total
    ```
    
    ---
    
    ## 4. Session Budget Limits (Feedback Loop)
    
    ### 4.1 Session Validation Budget Exhausted
    
    **Error Pattern (codeNERD):**
    ```
    session validation budget exhausted
    ```
    
    **What Causes It:**
    - Too many retry attempts in single session
    - Default: 20 retries per session
    - Prevents infinite retry loops
    
    **Configuration:**
    ```go
    config := feedback.DefaultConfig()
    config.SessionBudget = 50  // More retries allowed
    
    budget := feedback.NewValidationBudget(config)
    ```
    
    **Monitoring:**
    ```go
    used, total := budget.Stats()
    log.Printf("Validation budget: %d / %d used", used, total)
    
    if budget.IsSessionExhausted() {
        log.Warn("Session budget exhausted, consider reset")
    }
    ```
    
    **Reset:**
    ```go
    // At session boundaries
    budget.Reset()
    ```
    
    ---
    
    ### 4.2 Max Retries Exceeded for Rule
    
    **Error Pattern (codeNERD):**
    ```
    max retries exceeded for this rule
    ```
    
    **What Causes It:**
    - Single rule failed too many times
    - Default: 3 retries per rule
    - Prevents stuck on one bad rule
    
    **Configuration:**
    ```go
    config := feedback.DefaultConfig()
    config.MaxRetries = 5  // More retries per rule
    ```
    
    ---
    
    ## 5. Memory Limits (Implicit)
    
    ### 5.1 Out of Memory (OOM)
    
    **Symptom:**
    - Process crashes or panic
    - No graceful error message
    - System reports OOM
    
    **What Causes It:**
    - Fact store grows too large
    - Derived facts explosion
    - No gas limit configured
    
    **Prevention:**
    
    **Always set limits:**
    ```go
    config := mangle.DefaultConfig()
    config.FactLimit = 100000           // Hard cap on facts
    config.DerivedFactsLimit = 100000   // Gas limit
    ```
    
    **Monitor memory:**
    ```go
    import "runtime"
    
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    log.Printf("Alloc = %v MiB", m.Alloc / 1024 / 1024)
    log.Printf("TotalAlloc = %v MiB", m.TotalAlloc / 1024 / 1024)
    
    // Alert if too high
    if m.Alloc > 1000*1024*1024 {  // 1GB
        log.Warn("High memory usage!")
        // Consider clearing facts
    }
    ```
    
    **Periodic cleanup:**
    ```go
    // For long-running sessions
    if stats.TotalFacts > warningThreshold {
        // Remove old/unused facts
        cleanupStaleData()
    }
    ```
    
    ---
    
    ## 6. Diagnostic Strategies
    
    ### Strategy 1: Profile Before Hitting Limit
    
    ```go
    // Enable detailed logging
    logging.SetLevel(logging.LevelDebug)
    
    // Monitor fact growth
    stats := engine.GetStats()
    log.Printf("Predicate counts: %+v", stats.PredicateCounts)
    
    // Identify problematic predicates
    for pred, count := range stats.PredicateCounts {
        if count > 10000 {
            log.Warn("Large predicate: %s has %d facts", pred, count)
        }
    }
    ```
    
    ### Strategy 2: Incremental Testing
    
    ```go
    // Test with small data first
    testEngine := newEngineWithLimits(1000, 1000)
    testEngine.LoadSchema(schema)
    testEngine.AddFacts(sampleFacts[:10])  // Small subset
    
    stats, err := testEngine.RecomputeRules()
    if err == nil {
        log.Printf("Small test passed: %+v", stats)
        // Now try with full data
    }
    ```
    
    ### Strategy 3: Measure Derivation Rate
    
    ```go
    before := engine.GetDerivedFactCount()
    engine.AddFacts(newFacts)
    after := engine.GetDerivedFactCount()
    
    derivedPerInput := float64(after - before) / float64(len(newFacts))
    log.Printf("Derivation rate: %.2f derived per input fact", derivedPerInput)
    
    if derivedPerInput > 100 {
        log.Warn("High derivation rate - check for cartesian products!")
    }
    ```
    
    ---
    
    ## 7. Configuration Best Practices
    
    ### Development Config (Permissive)
    ```go
    func DevelopmentConfig() mangle.Config {
        return mangle.Config{
            FactLimit:         500000,  // Higher for testing
            DerivedFactsLimit: 500000,  // More headroom
            QueryTimeout:      300,     // 5 minutes
            AutoEval:          true,
        }
    }
    ```
    
    ### Production Config (Strict)
    ```go
    func ProductionConfig() mangle.Config {
        return mangle.Config{
            FactLimit:         100000,  // Reasonable cap
            DerivedFactsLimit: 100000,  // Prevent runaway
            QueryTimeout:      30,      // Fast failure
            AutoEval:          true,
        }
    }
    ```
    
    ### Testing Config (Very Strict)
    ```go
    func TestingConfig() mangle.Config {
        return mangle.Config{
            FactLimit:         1000,   // Catch issues early
            DerivedFactsLimit: 1000,   // Low gas limit
            QueryTimeout:      5,      // Fast timeout
            AutoEval:          true,
        }
    }
    ```
    
    ---
    
    ## 8. Error Recovery Patterns
    
    ### Pattern 1: Catch and Retry with Higher Limit
    ```go
    result, err := engine.Query(ctx, query)
    if err != nil && strings.Contains(err.Error(), "timeout") {
        // Retry with longer timeout
        ctx2, cancel2 := context.WithTimeout(context.Background(), 2*time.Minute)
        defer cancel2()
        result, err = engine.Query(ctx2, query)
    }
    ```
    
    ### Pattern 2: Progressive Limit Increase
    ```go
    limits := []int{1000, 5000, 10000, 50000}
    for _, limit := range limits {
        config.DerivedFactsLimit = limit
        engine.ResetDerivedFactCount()
    
        _, err := engine.RecomputeRules()
        if err == nil {
            log.Printf("Succeeded with limit %d", limit)
            break
        }
        if !strings.Contains(err.Error(), "gas limit") {
            return err  // Different error, don't retry
        }
    }
    ```
    
    ### Pattern 3: Fail Fast and Report
    ```go
    _, err := engine.RecomputeRules()
    if err != nil {
        if errors.Is(err, mangle.ErrDerivedFactsLimitExceeded) {
            // Log diagnostic info
            stats := engine.GetStats()
            log.Error("Gas limit hit. Predicate counts: %+v", stats.PredicateCounts)
            log.Error("Derived count: %d", engine.GetDerivedFactCount())
    
            // Fail loudly
            return fmt.Errorf("inference explosion detected: %w", err)
        }
    }
    ```
    
    ---
    
    ## Quick Reference Table
    
    | Error | Config Field | Default | Fix |
    |-------|-------------|---------|-----|
    | Fact limit exceeded | `FactLimit` | 100,000 | Increase limit or clean old facts |
    | Gas limit exceeded | `DerivedFactsLimit` | 100,000 | Fix logic or increase limit |
    | Query timeout | `QueryTimeout` | 30s | Optimize query or increase timeout |
    | Session budget exhausted | `SessionBudget` | 20 | Increase budget or reset |
    | Max retries per rule | `MaxRetries` | 3 | Increase retries or fix logic |
    
    ---
    
    ## Related Documentation
    
    - [runtime_errors.md](./runtime_errors.md) - Evaluation errors
    - [analysis_errors.md](./analysis_errors.md) - Logic errors causing explosions
    - [patterns_comprehensive.md](../patterns_comprehensive.md) - Efficient patterns
