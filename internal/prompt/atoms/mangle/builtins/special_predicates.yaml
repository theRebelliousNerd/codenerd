# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: builtins/special_predicates.md

- id: "language/mangle/docs/builtins/special_predicates"
  category: "language"
  subcategory: "mangle"
  description: "Mangle Special Predicates"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle Special Predicates
    
    Complete reference for special-purpose built-in predicates in Mangle.
    
    ## Filter Predicate
    
    ### :filter
    
    **Signature:** `:filter(Bool)`
    
    **Mode:** `(Input)` - argument must be bound
    
    **Description:** Succeeds if the argument is the boolean constant `true`, fails if `false`. Used to filter based on boolean conditions.
    
    **Parameters:**
    - Single arg: must evaluate to `true` or `false` constant
    
    **Examples:**
    
    ```mangle
    # Basic filtering
    valid(X) :-
      value(X),
      Check = fn:list:contains(fn:list(1, 2, 3), X),
      :filter(Check).
    # Only succeeds if X is in the list
    
    # With comparison result
    positive(X) :-
      number(X),
      :filter(:gt(X, 0)).
    # Wait, this won't work - :gt is a predicate, not a function
    
    # CORRECT: Use :gt directly
    positive(X) :-
      number(X),
      :gt(X, 0).  # No :filter needed
    
    # WHERE :filter IS USEFUL - with function results
    has_item(List, Item) :-
      Result = fn:list:contains(List, Item),
      :filter(Result).
    
    # Checking flags
    is_active(Entity) :-
      flag(Entity, Active),
      :filter(Active).  # Active must be true/false constant
    ```
    
    **Use Cases:**
    - Filtering based on boolean-returning functions (`fn:list:contains`, etc.)
    - Checking boolean flags stored as `true`/`false` constants
    - Conditional logic based on computed boolean values
    
    **Common Mistakes:**
    - ❌ Using with predicates: `:filter(:gt(X, 5))` - predicates don't return booleans
    - ❌ Using with non-boolean: `:filter(42)` - type error
    - ✓ Use predicates directly: `value(X), :gt(X, 5)` not `value(X), :filter(:gt(X, 5))`
    
    **When to Use:**
    - When you have a FUNCTION that returns a boolean (`true`/`false` constant)
    - When checking stored boolean values
    
    **When NOT to Use:**
    - With comparison predicates - use them directly
    - With other predicates - they already succeed/fail
    
    ---
    
    ## List Membership Predicate
    
    ### :list:member
    
    **Signature:** `:list:member(Element, List)`
    
    **Mode:** `(Output, Input)` or `(Input, Input)`
    
    **Description:** Succeeds if Element is a member of List. Can generate all members or check membership.
    
    **Parameters:**
    - First arg: element (can be unbound to generate, or bound to check)
    - Second arg: `Type<list<T>>` (must be bound)
    
    **Modes:**
    
    **Mode 1: Generation (Element unbound)**
    ```mangle
    # Generate all members
    member(X) :- :list:member(X, fn:list(1, 2, 3)).
    # Derives: member(1), member(2), member(3)
    
    # Iterate over list
    process(X) :-
      data(List),
      :list:member(X, List),
      # ... process X ...
    ```
    
    **Mode 2: Checking (Element bound)**
    ```mangle
    # Check membership
    is_member(X) :-
      :list:member(X, fn:list(/a, /b, /c)).
    # Succeeds if X is /a, /b, or /c
    
    # Filter items that are in a set
    valid_item(Item) :-
      item(Item),
      allowed(AllowedList),
      :list:member(Item, AllowedList).
    ```
    
    **Examples:**
    
    ```mangle
    # Cartesian product
    pair(X, Y) :-
      :list:member(X, fn:list(1, 2, 3)),
      :list:member(Y, fn:list(/a, /b)).
    # Generates: (1,/a), (1,/b), (2,/a), (2,/b), (3,/a), (3,/b)
    
    # Check if value is in whitelist
    whitelisted(Val) :-
      whitelist(List),
      :list:member(Val, List).
    
    # Expand list into individual facts
    expanded(Item) :-
      items(fn:list(/foo, /bar, /baz)),
      :list:member(Item, fn:list(/foo, /bar, /baz)).
    
    # Find common elements
    in_both(X) :-
      list1(L1),
      list2(L2),
      :list:member(X, L1),
      :list:member(X, L2).
    ```
    
    **vs fn:list:contains:**
    
    | Feature | `:list:member` | `fn:list:contains` |
    |---------|---------------|-------------------|
    | Type | Predicate | Function |
    | Can generate | Yes (if element unbound) | No |
    | Can check | Yes | Yes |
    | Returns | Success/failure | Boolean constant |
    | Use in :filter | No | Yes |
    
    ```mangle
    # These are equivalent for checking:
    check1(X, L) :- :list:member(X, L).
    check2(X, L) :- :filter(fn:list:contains(L, X)).
    
    # But :list:member can also generate:
    generate(X) :- :list:member(X, fn:list(1, 2, 3)).
    # fn:list:contains can't do this
    ```
    
    ---
    
    ## Distance Predicate
    
    ### :within_distance
    
    **Signature:** `:within_distance(Number1, Number2, Distance)`
    
    **Mode:** `(Input, Input, Input)` - all arguments must be bound
    
    **Description:** Succeeds if the absolute difference between Number1 and Number2 is less than Distance.
    
    **Formula:** `abs(Number1 - Number2) < Distance`
    
    **Parameters:**
    - First arg: `Type<int>` or `Type<float64>`
    - Second arg: `Type<int>` or `Type<float64>`
    - Third arg: `Type<int>` or `Type<float64>` (distance threshold)
    
    **Examples:**
    
    ```mangle
    # Basic usage
    :within_distance(10, 12, 3).                     # Succeeds (|10-12| = 2 < 3)
    :within_distance(10, 15, 3).                     # Fails (|10-15| = 5 >= 3)
    
    # Symmetric
    :within_distance(12, 10, 3).                     # Succeeds (same as above)
    
    # Zero distance
    :within_distance(5, 5, 1).                       # Succeeds (|5-5| = 0 < 1)
    
    # Exact boundary (fails - must be strictly less)
    :within_distance(10, 13, 3).                     # Fails (|10-13| = 3, not < 3)
    
    # Find nearby values
    nearby(X, Y) :-
      value(X),
      value(Y),
      :within_distance(X, Y, 5).
    
    # Temperature similarity
    similar_temp(City1, City2) :-
      temperature(City1, T1),
      temperature(City2, T2),
      :within_distance(T1, T2, 2).
    
    # With negative numbers
    :within_distance(-10, -8, 3).                    # Succeeds (|-10-(-8)| = 2 < 3)
    :within_distance(-10, 8, 20).                    # Succeeds (|-10-8| = 18 < 20)
    ```
    
    **Use Cases:**
    - Finding approximate matches
    - Clustering similar values
    - Range queries with symmetric bounds
    - Similarity detection
    
    **Common Mistakes:**
    - ❌ Expecting "less than or equal": it's strictly less than
    - ❌ Unbound variables: all three arguments must be bound
    - ❌ Negative distance: distance should be positive (behavior undefined otherwise)
    
    **Comparison with Manual Check:**
    ```mangle
    # :within_distance(X, Y, D) is equivalent to:
    # Diff = fn:minus(X, Y),
    # AbsDiff = fn:abs(Diff),  # (no fn:abs in Mangle!)
    # :lt(AbsDiff, D).
    
    # Since there's no fn:abs, :within_distance is more convenient
    ```
    
    ---
    
    ## Pattern Matching Predicates (Summary)
    
    These are covered in detail in other files, but listed here for completeness:
    
    ### List Pattern Matching
    - **:match_nil(List)** - Check if list is empty (see `list_functions.md`)
    - **:match_cons(List, Head, Tail)** - Deconstruct list (see `list_functions.md`)
    
    ### String Pattern Matching
    - **:string:starts_with(String, Prefix)** - String prefix check (see `string_functions.md`)
    - **:string:ends_with(String, Suffix)** - String suffix check (see `string_functions.md`)
    - **:string:contains(String, Substring)** - Substring search (see `string_functions.md`)
    
    ### Name Pattern Matching
    - **:match_prefix(Name, Prefix)** - Name prefix check (see `string_functions.md`)
    
    ### Struct/Map Pattern Matching
    - **:match_field(Struct, Field, Value)** - Extract struct field (see `struct_functions.md`)
    - **:match_entry(Map, Key, Value)** - Extract map entry (see `struct_functions.md`)
    - **:match_pair(Pair, First, Second)** - Deconstruct pair (see `struct_functions.md`)
    
    ---
    
    ## Complete Examples
    
    ### Example 1: Filtering with Boolean Functions
    
    ```mangle
    # Whitelist checking
    allowed_user(User) :-
      user(User),
      whitelist(List),
      Contains = fn:list:contains(List, User),
      :filter(Contains).
    
    # Alternative using :list:member (cleaner)
    allowed_user_v2(User) :-
      user(User),
      whitelist(List),
      :list:member(User, List).
    ```
    
    ### Example 2: Finding Nearby Points
    
    ```mangle
    # Facts: locations with coordinates
    location(/home, 10, 20).
    location(/work, 12, 23).
    location(/store, 50, 60).
    location(/park, 11, 21).
    
    # Find locations within distance 5 of a point
    nearby_location(Loc, RefX, RefY) :-
      location(Loc, X, Y),
      :within_distance(X, RefX, 5),
      :within_distance(Y, RefY, 5).
    
    # Find nearby pairs
    near_each_other(Loc1, Loc2) :-
      location(Loc1, X1, Y1),
      location(Loc2, X2, Y2),
      Loc1 != Loc2,
      :within_distance(X1, X2, 5),
      :within_distance(Y1, Y2, 5).
    ```
    
    ### Example 3: List Expansion and Filtering
    
    ```mangle
    # Expand tags and filter by priority
    priority_tags(Item, Tag) :-
      item_tags(Item, TagList),
      :list:member(Tag, TagList),
      priority_tag(Tag).
    
    priority_tag(/urgent).
    priority_tag(/critical).
    priority_tag(/security).
    
    item_tags(/issue1, fn:list(/bug, /urgent, /frontend)).
    item_tags(/issue2, fn:list(/enhancement, /backend)).
    
    # Result: priority_tags(/issue1, /urgent).
    ```
    
    ### Example 4: Approximate Matching
    
    ```mangle
    # Find scores within 10 points of each other
    similar_scores(Player1, Player2) :-
      score(Player1, S1),
      score(Player2, S2),
      Player1 != Player2,
      :within_distance(S1, S2, 10).
    
    score(/alice, 100).
    score(/bob, 95).
    score(/charlie, 105).
    score(/dave, 50).
    
    # Results:
    # similar_scores(/alice, /bob).       # |100-95| = 5 < 10
    # similar_scores(/alice, /charlie).   # |100-105| = 5 < 10
    # similar_scores(/bob, /charlie).     # |95-105| = 10, fails (not < 10)
    ```
    
    ---
    
    ## Common Patterns
    
    ### Whitelist Pattern
    ```mangle
    in_whitelist(Item) :-
      whitelist(List),
      :list:member(Item, List).
    ```
    
    ### Blacklist Pattern
    ```mangle
    not_in_blacklist(Item) :-
      blacklist(List),
      not :list:member(Item, List).
    ```
    
    ### Range Check with Distance
    ```mangle
    # Check if value is within distance D of center
    in_range(Value, Center, D) :-
      :within_distance(Value, Center, D).
    ```
    
    ### Boolean Flag Check
    ```mangle
    is_enabled(Feature) :-
      feature_flag(Feature, Enabled),
      :filter(Enabled).
    ```
    
    ### Set Operations via Lists
    
    **Union:**
    ```mangle
    in_either(X) :-
      (list1(L1), :list:member(X, L1));
      (list2(L2), :list:member(X, L2)).
    ```
    
    **Intersection:**
    ```mangle
    in_both(X) :-
      list1(L1),
      list2(L2),
      :list:member(X, L1),
      :list:member(X, L2).
    ```
    
    **Difference:**
    ```mangle
    in_first_not_second(X) :-
      list1(L1),
      list2(L2),
      :list:member(X, L1),
      not :list:member(X, L2).
    ```
    
    ---
    
    ## Performance Notes
    
    ### :filter
    - Very fast (constant time boolean check)
    - No performance overhead
    
    ### :list:member
    - O(n) per element (linear scan)
    - Generates all members when unbound (can be expensive for large lists)
    - Use early in rule for better selectivity
    
    ### :within_distance
    - O(1) arithmetic operations
    - Fast computation
    
    **Optimization Tips:**
    
    ```mangle
    # BETTER - filter by predicate first
    result(X) :-
      rare_value(X),           # Selective predicate
      :list:member(X, List).   # Then check membership
    
    # WORSE - generate all list members first
    result(X) :-
      :list:member(X, List),   # Generates many values
      rare_value(X).           # Then filters
    ```
    
    ---
    
    ## Error Conditions
    
    ### :filter
    - Type error if argument is not boolean constant
    - Fails (doesn't error) on `false`
    
    ### :list:member
    - Type error if second argument is not a list
    - Fails (doesn't error) if element not found
    
    ### :within_distance
    - Type error if arguments are not numeric
    - Unbound variables will fail (all must be bound)
    
    ---
    
    ## Summary Table
    
    | Predicate | Purpose | Mode | Performance |
    |-----------|---------|------|-------------|
    | `:filter(Bool)` | Filter by boolean | (Input) | O(1) |
    | `:list:member(E, L)` | Membership/generation | (Out, In) or (In, In) | O(n) |
    | `:within_distance(X, Y, D)` | Approximate equality | (In, In, In) | O(1) |
    | `:match_nil(L)` | Empty list check | (In) | O(1) |
    | `:match_cons(L, H, T)` | List deconstruction | (In, Out, Out) | O(1) |
    | `:string:starts_with(S, P)` | String prefix | (In, In) | O(m) |
    | `:string:contains(S, P)` | Substring search | (In, In) | O(n*m) |
    | `:match_field(S, F, V)` | Struct field access | (In, In, Out) | O(n) |
    | `:match_entry(M, K, V)` | Map entry access | (In, In, Out) | O(n) |
    
    Where:
    - n = collection size
    - m = pattern/string length
    
    ---
    
    ## Best Practices
    
    1. **Use predicates directly instead of :filter when possible:**
       ```mangle
       # BETTER
       valid(X) :- value(X), :gt(X, 0).
    
       # WORSE
       valid(X) :- value(X), :filter(:gt(X, 0)).  # Won't work anyway
       ```
    
    2. **Use :list:member for iteration, fn:list:contains for checking:**
       ```mangle
       # Generate all members
       each(X) :- :list:member(X, List).
    
       # Check if specific item exists
       has_item(Item, List) :- :filter(fn:list:contains(List, Item)).
       ```
    
    3. **Place selective predicates before :list:member:**
       ```mangle
       # BETTER
       result(X) :- rare(X), :list:member(X, BigList).
    
       # WORSE
       result(X) :- :list:member(X, BigList), rare(X).
       ```
    
    4. **Use :within_distance for approximate comparisons:**
       ```mangle
       # BETTER
       similar(X, Y) :- value(X), value(Y), :within_distance(X, Y, 5).
    
       # WORSE (and doesn't exist)
       similar(X, Y) :- value(X), value(Y), Diff = fn:abs(fn:minus(X, Y)), :lt(Diff, 5).
       ```
