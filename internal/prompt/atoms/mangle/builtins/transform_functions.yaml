# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: builtins/transform_functions.md

- id: "language/mangle/docs/builtins/transform_functions"
  category: "language"
  subcategory: "mangle"
  description: "Mangle Transform Pipeline Reference"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle Transform Pipeline Reference
    
    Complete reference for Mangle's transform pipeline syntax (`|>`, `do`, `fn:group_by`, `let`).
    
    ## Transform Pipeline Overview
    
    Transform pipelines allow you to perform aggregations and transformations on query results. The syntax uses the pipe operator `|>` followed by `do` and reducer functions.
    
    **Basic Structure:**
    ```mangle
    result(GroupVars, AggregatedValues) :-
      base_predicate(Variables)
      |> do fn:group_by(GroupVars),
         let Agg1 = fn:AggFunction1(Var1),
         let Agg2 = fn:AggFunction2(Var2).
    ```
    
    ---
    
    ## Pipeline Operator: `|>`
    
    **Syntax:** `predicate(args) |> transform`
    
    **Description:** The pipe operator takes the result set from a query and passes it to a transform operation.
    
    **Examples:**
    
    ```mangle
    # Simple pipeline
    result(Sum) :-
      value(X)
      |> do fn:group_by(), let Sum = fn:Sum(X).
    
    # Multiple predicates before pipeline
    result(Cat, Avg) :-
      item(Item, Cat),
      measurement(Item, Val),
      :gt(Val, 0)
      |> do fn:group_by(Cat), let Avg = fn:Avg(Val).
    ```
    
    **Rules:**
    - The `|>` comes after ALL predicates in the rule body
    - Only ONE pipeline per rule
    - Everything before `|>` generates the input rows
    - Everything after `|>` is the transform operation
    
    ---
    
    ## Transform Keyword: `do`
    
    **Syntax:** `|> do fn:group_by(...), let ...`
    
    **Description:** Introduces a transform block. Must be followed by `fn:group_by`.
    
    **Structure:**
    ```mangle
    |> do fn:group_by(GroupVariables),
       let Result1 = fn:Aggregation1(...),
       let Result2 = fn:Aggregation2(...).
    ```
    
    **Rules:**
    - `do` must come immediately after `|>`
    - `fn:group_by` must come first after `do`
    - Multiple `let` bindings can follow (comma-separated)
    
    ---
    
    ## Grouping Function: `fn:group_by`
    
    **Syntax:** `fn:group_by(Var1, Var2, ...)`
    
    **Description:** Specifies which variables to group by. Similar to SQL's GROUP BY.
    
    **Parameters:**
    - Zero or more variables that appear in the rule body
    - Variables must be bound before the pipeline
    
    **Behavior:**
    - **Empty group_by**: `fn:group_by()` - aggregates ALL rows into one group
    - **Single variable**: `fn:group_by(X)` - group by X values
    - **Multiple variables**: `fn:group_by(X, Y)` - group by combinations of X and Y
    
    **Examples:**
    
    ```mangle
    # No grouping - aggregate everything
    global_sum(Total) :-
      value(X)
      |> do fn:group_by(), let Total = fn:Sum(X).
    
    # Group by one variable
    sum_per_category(Cat, Total) :-
      item(Item, Cat, Amount)
      |> do fn:group_by(Cat), let Total = fn:Sum(Amount).
    
    # Group by multiple variables
    sum_per_category_and_type(Cat, Type, Total) :-
      item(Item, Cat, Type, Amount)
      |> do fn:group_by(Cat, Type), let Total = fn:Sum(Amount).
    
    # From aggregation example
    aggregated(Subject, Verb, Topic, Sum)
      :- observed(Subject, Verb, Topic, Weight, _)
      |> do fn:group_by(Subject, Verb, Topic), let Sum = fn:Sum(Weight).
    ```
    
    **Common Mistakes:**
    - ❌ Grouping by unbound variables - variables must appear before `|>`
    - ❌ Using variables in `let` that aren't in group_by or aggregations
    - ❌ Forgetting `fn:` prefix: `group_by(X)` should be `fn:group_by(X)`
    
    ---
    
    ## Binding Keyword: `let`
    
    **Syntax:** `let Variable = fn:AggFunction(...)`
    
    **Description:** Binds aggregation results to variables.
    
    **Rules:**
    - Must come after `fn:group_by`
    - Multiple `let` clauses separated by commas
    - Variables bound by `let` can be used in rule head or further computation
    
    **Examples:**
    
    ```mangle
    # Single let
    result(Sum) :-
      value(X)
      |> do fn:group_by(), let Sum = fn:Sum(X).
    
    # Multiple let bindings
    stats(Cat, Count, Sum, Avg) :-
      value(Cat, X)
      |> do fn:group_by(Cat),
         let Count = fn:Count(X),
         let Sum = fn:Sum(X),
         let Avg = fn:Avg(X).
    
    # Using let result in rule head
    category_info(Cat, fn:string_concat("Count: ", Count)) :-
      item(Cat, _)
      |> do fn:group_by(Cat), let Count = fn:Count(Cat).
    ```
    
    **Common Mistakes:**
    - ❌ Missing `=` sign: `let Sum fn:Sum(X)` should be `let Sum = fn:Sum(X)`
    - ❌ Using `let` outside transform: only works inside `|> do` blocks
    - ❌ Separating with semicolons: use commas between `let` clauses
    
    ---
    
    ## Complete Examples
    
    ### Example 1: Simple Aggregation (From Examples)
    
    ```mangle
    # From aggregation.mg
    aggregated(Subject, Verb, Topic, Sum)
      :- observed(Subject, Verb, Topic, Weight, _)
      |> do fn:group_by(Subject, Verb, Topic), let Sum = fn:Sum(Weight).
    
    # Explanation:
    # - Input: observed(Subject, Verb, Topic, Weight, Description)
    # - Group by: Subject, Verb, Topic (three-column grouping)
    # - Aggregate: Sum of Weight values
    # - Output: One row per unique (Subject, Verb, Topic) with summed Weight
    ```
    
    ### Example 2: Global Aggregation
    
    ```mangle
    # Count all items
    total_count(Count) :-
      item(_)
      |> do fn:group_by(), let Count = fn:Count(_).
    
    # Explanation:
    # - Empty fn:group_by() means "aggregate everything"
    # - Results in single row with total count
    ```
    
    ### Example 3: Multiple Aggregations
    
    ```mangle
    # Statistics per category
    category_stats(Cat, Count, Sum, Min, Max, Avg) :-
      measurement(Cat, Value)
      |> do fn:group_by(Cat),
         let Count = fn:Count(Value),
         let Sum = fn:Sum(Value),
         let Min = fn:Min(Value),
         let Max = fn:Max(Value),
         let Avg = fn:Avg(Value).
    ```
    
    ### Example 4: Filtering Before Aggregation
    
    ```mangle
    # Sum only positive values per category
    positive_sum(Cat, Sum) :-
      value(Cat, Val),
      :gt(Val, 0)  # Filter before pipeline
      |> do fn:group_by(Cat), let Sum = fn:Sum(Val).
    ```
    
    ### Example 5: Collecting to List
    
    ```mangle
    # From map_aggregation.mg
    user_languages_list(User, Languages)
      :- user_language(User, Language)
      |> do fn:group_by(User), let Languages = fn:Collect(Language).
    
    # Explanation:
    # - Group by User
    # - Collect all Language values into a list
    # - Each user gets one row with list of their languages
    ```
    
    ### Example 6: Collecting to Map
    
    ```mangle
    # From map_aggregation.mg
    user_language_scores(User, LanguageScoreMap)
      :- user_language(User, Language),
         language_popularity(Language, Score)
      |> do fn:group_by(User), let LanguageScoreMap = fn:CollectToMap(Language, Score).
    
    # Explanation:
    # - Join user_language with language_popularity
    # - Group by User
    # - Build map: Language -> Score for each user
    ```
    
    ### Example 7: Nested Computations
    
    ```mangle
    # Average of averages (careful!)
    category_avg_of_averages(Cat, AvgOfAvg) :-
      item(Cat, SubCat, Value)
      |> do fn:group_by(Cat, SubCat), let SubAvg = fn:Avg(Value),
      # Now we have Cat, SubCat, SubAvg
      |> do fn:group_by(Cat), let AvgOfAvg = fn:Avg(SubAvg).
    
    # NOTE: This requires TWO separate rules in Mangle:
    # Rule 1: Compute subcategory averages
    subcat_avg(Cat, SubCat, SubAvg) :-
      item(Cat, SubCat, Value)
      |> do fn:group_by(Cat, SubCat), let SubAvg = fn:Avg(Value).
    
    # Rule 2: Average the averages
    category_avg_of_averages(Cat, AvgOfAvg) :-
      subcat_avg(Cat, SubCat, SubAvg)
      |> do fn:group_by(Cat), let AvgOfAvg = fn:Avg(SubAvg).
    ```
    
    ---
    
    ## Variable Scoping Rules
    
    **Before Pipeline (`|>`):**
    - All variables in predicates are visible
    - Variables must be bound by predicates
    
    **In Group By:**
    - Only variables from before pipeline can be used
    - These become grouping keys
    
    **In Let Bindings:**
    - Can reference variables from group_by
    - Can reference variables being aggregated
    - Cannot reference other let-bound variables in same transform
    
    **In Rule Head:**
    - Can use group_by variables
    - Can use let-bound variables
    - Cannot use aggregated variables directly
    
    **Examples:**
    
    ```mangle
    # ✓ CORRECT
    result(Cat, Sum) :-
      item(Cat, Val)          # Cat and Val bound here
      |> do fn:group_by(Cat), # Cat used in grouping
         let Sum = fn:Sum(Val). # Val used in aggregation
    
    # ✗ WRONG - X not bound before pipeline
    result(X, Sum) :-
      item(Val)
      |> do fn:group_by(X), let Sum = fn:Sum(Val).
    
    # ✗ WRONG - Can't use Val in head (it's aggregated away)
    result(Cat, Val, Sum) :-
      item(Cat, Val)
      |> do fn:group_by(Cat), let Sum = fn:Sum(Val).
    
    # ✓ CORRECT - Only Cat and Sum in head
    result(Cat, Sum) :-
      item(Cat, Val)
      |> do fn:group_by(Cat), let Sum = fn:Sum(Val).
    ```
    
    ---
    
    ## Execution Model
    
    1. **Base Query Evaluation:**
       - All predicates before `|>` are evaluated
       - Generates a set of variable bindings (rows)
    
    2. **Grouping:**
       - Rows are partitioned by `fn:group_by` variables
       - Each unique combination of group_by values forms one group
    
    3. **Aggregation:**
       - For each group, aggregation functions are evaluated
       - Each `let` binding computes an aggregation over the group
    
    4. **Result Construction:**
       - One output row per group
       - Contains group_by variables + let-bound variables
    
    **Example Execution:**
    
    ```mangle
    # Input facts:
    value(/a, 1).
    value(/a, 2).
    value(/b, 3).
    
    # Query:
    sum_per_category(Cat, Sum) :-
      value(Cat, Val)
      |> do fn:group_by(Cat), let Sum = fn:Sum(Val).
    
    # Step 1: Base query generates rows:
    # {Cat=/a, Val=1}
    # {Cat=/a, Val=2}
    # {Cat=/b, Val=3}
    
    # Step 2: Group by Cat:
    # Group 1: {Cat=/a, Val=1}, {Cat=/a, Val=2}
    # Group 2: {Cat=/b, Val=3}
    
    # Step 3: Aggregate each group:
    # Group 1: Sum = 1 + 2 = 3
    # Group 2: Sum = 3
    
    # Step 4: Output:
    # sum_per_category(/a, 3).
    # sum_per_category(/b, 3).
    ```
    
    ---
    
    ## Comparison with SQL
    
    | Mangle | SQL | Notes |
    |--------|-----|-------|
    | `\|>` | - | Pipeline operator (no SQL equivalent) |
    | `do fn:group_by(X)` | `GROUP BY X` | Similar concept |
    | `let Sum = fn:Sum(V)` | `SUM(V) AS Sum` | Aggregation |
    | Empty group_by | `SELECT SUM(...) FROM ...` | No GROUP BY = aggregate all |
    
    **SQL Example:**
    ```sql
    SELECT Category, SUM(Amount) AS Total
    FROM Items
    GROUP BY Category
    ```
    
    **Mangle Equivalent:**
    ```mangle
    category_total(Category, Total) :-
      items(_, Category, Amount)
      |> do fn:group_by(Category), let Total = fn:Sum(Amount).
    ```
    
    ---
    
    ## Limitations
    
    ### No Nested Pipelines
    ```mangle
    # ✗ WRONG - Can't nest pipelines
    result(X) :-
      (inner(Y) |> do fn:group_by(), let Sum = fn:Sum(Y))
      |> do fn:group_by(), let Count = fn:Count(Sum).
    ```
    
    **Solution:** Use multiple rules:
    ```mangle
    # ✓ CORRECT
    inner_sum(Sum) :-
      inner(Y)
      |> do fn:group_by(), let Sum = fn:Sum(Y).
    
    result(Count) :-
      inner_sum(Sum)
      |> do fn:group_by(), let Count = fn:Count(Sum).
    ```
    
    ### No Having Clause
    Mangle doesn't have SQL's HAVING. Filter after aggregation using a second rule:
    
    ```mangle
    # SQL: SELECT Cat, SUM(Val) AS Total FROM ... GROUP BY Cat HAVING SUM(Val) > 100
    
    # Mangle - two rules:
    category_sum(Cat, Total) :-
      item(Cat, Val)
      |> do fn:group_by(Cat), let Total = fn:Sum(Val).
    
    large_categories(Cat, Total) :-
      category_sum(Cat, Total),
      :gt(Total, 100).
    ```
    
    ### One Pipeline Per Rule
    ```mangle
    # ✗ WRONG - Multiple pipelines
    result(X, Y) :-
      data1(A) |> do fn:group_by(), let X = fn:Sum(A),
      data2(B) |> do fn:group_by(), let Y = fn:Sum(B).
    ```
    
    **Solution:** Use separate rules:
    ```mangle
    # ✓ CORRECT
    sum1(X) :- data1(A) |> do fn:group_by(), let X = fn:Sum(A).
    sum2(Y) :- data2(B) |> do fn:group_by(), let Y = fn:Sum(B).
    result(X, Y) :- sum1(X), sum2(Y).
    ```
    
    ---
    
    ## Performance Considerations
    
    - Grouping is efficient (hash-based)
    - Multiple aggregations in one pipeline are cheaper than separate queries
    - Large groups (many rows per group) can be memory-intensive
    - `fn:Collect` and `fn:CollectToMap` store all values in memory
    
    **Optimization Tips:**
    1. Filter before the pipeline (reduce input rows)
    2. Combine multiple aggregations in one pipeline
    3. Use `fn:Count` instead of `fn:Collect` + `fn:list:len` when possible
    
    ---
    
    ## Common Patterns
    
    ### Count Per Group
    ```mangle
    count_by_category(Cat, Count) :-
      item(Cat, _)
      |> do fn:group_by(Cat), let Count = fn:Count(Cat).
    ```
    
    ### Top N Per Group
    ```mangle
    # Find max score per player
    top_score(Player, MaxScore) :-
      score(Player, Points)
      |> do fn:group_by(Player), let MaxScore = fn:Max(Points).
    ```
    
    ### Distinct Count
    ```mangle
    distinct_values(Cat, Count) :-
      item(Cat, Val)
      |> do fn:group_by(Cat), let Distinct = fn:CollectDistinct(Val),
      Count = fn:list:len(Distinct).
    ```
    
    ### Percentage Calculation
    ```mangle
    # Part 1: Category totals
    cat_total(Cat, Total) :-
      item(Cat, Amount)
      |> do fn:group_by(Cat), let Total = fn:Sum(Amount).
    
    # Part 2: Grand total
    grand_total(GTotal) :-
      item(_, Amount)
      |> do fn:group_by(), let GTotal = fn:Sum(Amount).
    
    # Part 3: Calculate percentage
    category_percentage(Cat, Pct) :-
      cat_total(Cat, Total),
      grand_total(GTotal),
      Pct = fn:float:div(fn:float:mult(Total, 100.0), GTotal).
    ```
    
    ---
    
    ## Error Messages
    
    Common errors and what they mean:
    
    - **"reducer function outside of transform"**: Trying to use `fn:Sum`, `fn:Count`, etc. without `|> do`
    - **"variable not bound in group_by"**: Using a variable in `let` that isn't in group_by or being aggregated
    - **"group_by variable not bound"**: Grouping by a variable that doesn't appear before `|>`
    
    ---
    
    ## Summary Checklist
    
    When writing transform pipelines, ensure:
    
    - [ ] All predicates come before `|>`
    - [ ] Pipeline starts with `|> do fn:group_by(...)`
    - [ ] Group variables are bound before pipeline
    - [ ] Aggregations use correct casing (e.g., `fn:Sum` not `fn:sum`)
    - [ ] Rule head only uses group_by variables and let-bound variables
    - [ ] Only one pipeline per rule
    - [ ] Commas separate multiple `let` bindings
