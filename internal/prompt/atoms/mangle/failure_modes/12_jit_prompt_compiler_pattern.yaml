# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: failure_modes/12_jit_prompt_compiler_pattern.md

- id: "language/mangle/docs/failure_modes/12_jit_prompt_compiler_pattern"
  category: "language"
  subcategory: "mangle"
  description: "Failure Mode 12: JIT Prompt Compiler Pattern (Correct Usage)"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Failure Mode 12: JIT Prompt Compiler Pattern (Correct Usage)
    
    ## Category
    Architectural Pattern (Correct Neuro-Symbolic Usage)
    
    ## Severity
    N/A - This is a CORRECT pattern, not a failure mode
    
    ## Pattern Description
    Using Mangle as a "linker" for dynamic prompt compilation. This demonstrates the CORRECT neuro-symbolic architecture where Vector DB handles semantic search and Mangle handles deductive reasoning.
    
    ## Context
    This is included in failure modes as a **counter-example** showing the correct way to use Mangle in combination with other systems. It contrasts with Failure Mode 11 (Mangle as HashMap).
    
    ## Architecture
    ```text
    Task Context
        ↓
    VECTOR DB (Search Engine)
        → Find relevant atomic prompts by semantic similarity
        ↓
    MANGLE KERNEL (Linker)
        → Resolve dependencies
        → Enforce conflicts
        → Apply phase gating
        → Determine priority ordering
        ↓
    GO RUNTIME (Assembler)
        → Concatenate selected atoms
        → Output final prompt string
    ```
    
    ## Correct Code
    
    ### Hybrid Prompt File Format
    ```text
    # File: prompts.mg
    # --- DATA SECTION (Parsed by Go Loader) ---
    PROMPT: /role_coder [role] -> "You are a Senior Go Engineer..."
    PROMPT: /cap_sql [tool] -> "You can access a PostgreSQL database..."
    PROMPT: /safe_no_delete [safety] -> "CRITICAL: Do NOT generate DROP..."
    PROMPT: /phase_coding [phase] -> "During CODING: Write clean code..."
    
    # --- LOGIC SECTION (Mangle Rules) ---
    # Dependency: SQL tool requires safety constraint
    requires(/cap_sql, /safe_no_delete).
    
    # Conflict: verbose and concise are mutually exclusive
    conflicts(/fmt_verbose, /fmt_concise).
    
    # Phase-specific requirements
    phase_requires(/coding, /role_coder).
    phase_requires(/planning, /role_architect).
    ```
    
    ### Mangle Compiler Logic
    ```mangle
    # =============================================================================
    # PROMPT COMPILER LOGIC - CORRECT USAGE OF MANGLE
    # =============================================================================
    
    # Schema declarations
    Decl vector_hit(AtomID.Type<n>, Score.Type<float>).
    Decl current_phase(Phase.Type<n>).
    Decl category(AtomID.Type<n>, Category.Type<n>).
    Decl requires(AtomID.Type<n>, Dependency.Type<n>).
    Decl conflicts(AtomID.Type<n>, OtherID.Type<n>).
    
    Decl selected(AtomID.Type<n>).
    Decl excluded(AtomID.Type<n>).
    Decl suppressed(AtomID.Type<n>).
    Decl final_atom(AtomID.Type<n>).
    Decl ordered_result(AtomID.Type<n>, Rank.Type<int>).
    
    # 1. SELECTION: High-confidence vector hits
    selected(P) :- vector_hit(P, Score), Score > 0.85.
    
    # 2. DEPENDENCY RESOLUTION: Auto-include required atoms
    selected(Dep) :- selected(P), requires(P, Dep).
    
    # Transitive dependencies
    selected(TransDep) :-
        selected(P),
        requires(P, Dep),
        requires(Dep, TransDep).
    
    # 3. PHASE GATING: Force appropriate role for current phase
    selected(/role_coder) :- current_phase(/coding).
    selected(/role_architect) :- current_phase(/planning).
    selected(/role_tester) :- current_phase(/testing).
    selected(/role_reviewer) :- current_phase(/review).
    
    # Exclude formatting atoms during planning
    excluded(P) :-
        current_phase(/planning),
        category(P, /fmt).
    
    # 4. CONFLICT RESOLUTION: If conflicting atoms selected, suppress loser
    suppressed(P_Loser) :-
        selected(P_Winner),
        selected(P_Loser),
        conflicts(P_Winner, P_Loser),
        priority(P_Winner, Pw),
        priority(P_Loser, Pl),
        Pw > Pl.  # Higher priority wins
    
    # Special case: During coding phase, coder role wins
    suppressed(P_Other) :-
        current_phase(/coding),
        selected(/role_coder),
        selected(P_Other),
        category(P_Other, /role),
        P_Other != /role_coder.
    
    # 5. FINAL ASSEMBLY: Combine selected, minus excluded and suppressed
    final_atom(P) :-
        selected(P),
        not excluded(P),
        not suppressed(P).
    
    # 6. ORDERING: Safety first, then role, tool, format
    Decl priority(Category.Type<n>, Rank.Type<int>).
    
    # Base priorities (lower number = higher priority)
    priority(/safety, 1).
    priority(/role, 2).
    priority(/tool, 3).
    priority(/phase, 4).
    priority(/fmt, 5).
    
    # Derive ordered results
    ordered_result(P, Rank) :-
        final_atom(P),
        category(P, Cat),
        priority(Cat, Rank).
    ```
    
    ### Go Implementation
    ```go
    // Step 1: Vector search for relevant prompts
    func SelectPrompts(taskContext string, vectorDB VectorStore) []PromptMatch {
        embedding := Embed(taskContext)
        matches := vectorDB.Search(embedding, topK: 10)
        // Returns: [
        //   {atomID: "/cap_sql", score: 0.92},
        //   {atomID: "/role_coder", score: 0.88},
        // ]
        return matches
    }
    
    // Step 2: Inject into Mangle
    func InjectVectorHits(matches []PromptMatch, store FactStore) {
        for _, m := range matches {
            fact := MakeFact("vector_hit",
                Atom(m.AtomID),
                Float(m.Score),
            )
            store.Add(fact)
        }
    }
    
    // Step 3: Inject current phase
    func SetPhase(phase string, store FactStore) {
        fact := MakeFact("current_phase", Atom(phase))
        store.Add(fact)
    }
    
    // Step 4: Load metadata (categories, dependencies, conflicts)
    func LoadMetadata(store FactStore) {
        // Categories
        store.Add(MakeFact("category", Atom("/role_coder"), Atom("/role")))
        store.Add(MakeFact("category", Atom("/cap_sql"), Atom("/tool")))
        store.Add(MakeFact("category", Atom("/safe_no_delete"), Atom("/safety")))
    
        // Dependencies
        store.Add(MakeFact("requires", Atom("/cap_sql"), Atom("/safe_no_delete")))
    
        // Conflicts
        store.Add(MakeFact("conflicts", Atom("/fmt_verbose"), Atom("/fmt_concise")))
    }
    
    // Step 5: Run Mangle compiler
    func CompilePrompt(store FactStore, rules string) ([]string, error) {
        program, _ := parse.Parse("compiler.mg", rules)
        analyzed, _ := analysis.AnalyzeOneUnit(program)
        result, _ := engine.EvalProgramNaive(analyzed, store)
    
        // Query ordered results
        query := parse.MustParse("query", "?ordered_result(P, R)")
        facts, _ := engine.Query(result, query)
    
        // Sort by rank
        sort.Slice(facts, func(i, j int) bool {
            rankI := facts[i].Args[1].(engine.Number)
            rankJ := facts[j].Args[1].(engine.Number)
            return rankI < rankJ
        })
    
        // Extract atom IDs
        var atomIDs []string
        for _, fact := range facts {
            atomID := string(fact.Args[0].(engine.Atom))
            atomIDs = append(atomIDs, atomID)
        }
    
        return atomIDs, nil
    }
    
    // Step 6: Assemble final prompt
    func AssemblePrompt(atomIDs []string, promptDB map[string]string) string {
        var parts []string
        for _, id := range atomIDs {
            if text, ok := promptDB[id]; ok {
                parts = append(parts, text)
            }
        }
        return strings.Join(parts, "\n\n")
    }
    ```
    
    ## Why This Pattern Works
    
    ### Mangle's Role: Deductive Linker
    Mangle handles what it excels at:
    - **Dependency resolution**: Recursive `requires/2` auto-includes safety constraints
    - **Conflict detection**: `conflicts/2` prevents contradictory instructions
    - **Phase gating**: Rules change behavior based on `current_phase/1`
    - **Priority ordering**: Aggregation derives assembly order
    - **Negation**: `not excluded(P)` cleanly filters unwanted atoms
    
    ### What Mangle Does NOT Do
    - **Semantic search**: Vector DB finds similar prompts (not Mangle)
    - **Store prompt text**: Go map/DB holds actual text (not Mangle facts)
    - **String matching**: No fuzzy/substring matching needed
    
    ## Benefits Over Static Prompts
    
    | Aspect | Static Prompt | JIT Compiled (This Pattern) |
    |--------|---------------|----------------------------|
    | **Maintenance** | Edit 20K char file | Edit single atom |
    | **Safety** | Manual inclusion | Auto-injected with tools |
    | **Context-Awareness** | One-size-fits-all | Phase-gated behavior |
    | **Token Efficiency** | Full prompt always | Only relevant atoms |
    | **Conflict Prevention** | Hope you noticed | Mangle enforces |
    
    ## What Mangle Stores (Metadata Only)
    
    ```mangle
    # CORRECT - Mangle stores METADATA about prompts
    category(/role_coder, /role).
    requires(/cap_sql, /safe_no_delete).
    conflicts(/fmt_verbose, /fmt_concise).
    priority(/safety, 1).
    
    # WRONG - Don't store prompt TEXT in Mangle
    # prompt_text(/role_coder, "You are a Senior Go Engineer...").  # NO!
    ```
    
    ## Complete Example: Safety-Critical Compilation
    
    ```mangle
    # Schema
    Decl vector_hit(AtomID.Type<n>, Score.Type<float>).
    Decl category(AtomID.Type<n>, Cat.Type<n>).
    Decl requires(AtomID.Type<n>, Dep.Type<n>).
    Decl safety_critical(Tool.Type<n>).
    
    # Facts (from Go)
    category(/cap_database, /tool).
    category(/cap_filesystem, /tool).
    category(/safe_no_delete, /safety).
    category(/safe_validate_paths, /safety).
    
    requires(/cap_database, /safe_no_delete).
    requires(/cap_filesystem, /safe_validate_paths).
    
    safety_critical(/cap_database).
    safety_critical(/cap_filesystem).
    
    # Vector hits (injected)
    vector_hit(/cap_database, 0.92).
    vector_hit(/role_coder, 0.88).
    
    # COMPILATION RULES
    selected(P) :- vector_hit(P, Score), Score > 0.85.
    
    # Critical: Auto-include safety constraints
    selected(Safety) :-
        selected(Tool),
        requires(Tool, Safety).
    
    # Critical: Reject if safety missing for critical tool
    missing_safety(Tool) :-
        selected(Tool),
        safety_critical(Tool),
        requires(Tool, Safety),
        not selected(Safety).
    
    error_missing_safety :-
        missing_safety(_).
    
    # Final selection (only if no errors)
    final_atom(P) :-
        selected(P),
        not error_missing_safety.
    
    # Query: ?final_atom(P)
    # Result: [/cap_database, /role_coder, /safe_no_delete]
    # Note: /safe_no_delete was AUTO-INCLUDED by requires/2
    ```
    
    ## Comparison: Wrong vs Right
    
    ### WRONG: Storing Prompt Text in Mangle
    ```mangle
    # DON'T DO THIS
    prompt_text(/role_coder, "You are a Senior Go Engineer with expertise in...").
    prompt_text(/cap_sql, "You can access a PostgreSQL database using...").
    # This is data storage, not logic!
    ```
    
    ### RIGHT: Storing Metadata in Mangle
    ```mangle
    # DO THIS
    category(/role_coder, /role).
    category(/cap_sql, /tool).
    requires(/cap_sql, /safe_no_delete).
    # This is logic about relationships!
    ```
    
    ## Detection (Is This Pattern Used Correctly?)
    - ✓ Vector DB used for semantic search
    - ✓ Mangle stores only metadata (categories, dependencies, conflicts)
    - ✓ Mangle rules handle deduction (selection, ordering, gating)
    - ✓ Go assembles final output from atom IDs
    - ✓ Prompt text stored in separate system (map, DB, files)
    
    ## Prevention (Avoiding Misuse)
    1. **Never store prompt text in Mangle facts**
    2. **Always use Vector DB for similarity search**
    3. **Use Mangle only for logical relationships**
    4. **Keep prompt assembly in Go (not Mangle)**
    5. **Mangle outputs atom IDs, not text**
    
    ## Why This is a Counter-Example
    This pattern is included in "failure modes" to show the **correct architecture**:
    
    | Feature | Failure Mode 11 | This Pattern (Correct) |
    |---------|----------------|------------------------|
    | Semantic search | Tries to use Mangle | Uses Vector DB |
    | Prompt text | Stored in Mangle facts | Stored in Go map/DB |
    | Mangle role | Pattern matching (wrong!) | Deductive reasoning (right!) |
    | String functions | Hallucinates `fn:contains` | None needed |
    | Results | Empty (no exact match) | Comprehensive (logic-driven) |
    
    ## Training Aid: Checklist
    
    Before implementing JIT prompt compilation:
    
    - [ ] Vector DB configured for semantic search
    - [ ] Prompt atoms stored as separate text (not in Mangle)
    - [ ] Mangle schema has metadata predicates only
    - [ ] Dependency rules use transitive closure
    - [ ] Conflict rules with priority resolution
    - [ ] Phase gating rules for context awareness
    - [ ] Ordering by category priority
    - [ ] Go assembler concatenates final output
    - [ ] No `fn:string_*` functions in Mangle code
    - [ ] No prompt text literals in Mangle facts
    
    ## Quick Reference: Division of Labor
    
    ```text
    ┌─────────────────────────────────────────────────┐
    │ VECTOR DB                                       │
    │ - Store prompt atom embeddings                  │
    │ - Semantic search for relevant atoms            │
    │ - Return: [(atomID, score), ...]               │
    └─────────────────────────────────────────────────┘
                        ↓
    ┌─────────────────────────────────────────────────┐
    │ MANGLE                                          │
    │ - Store metadata (categories, deps, conflicts) │
    │ - Deductive reasoning (selection, ordering)    │
    │ - Return: [atomID1, atomID2, ...]              │
    └─────────────────────────────────────────────────┘
                        ↓
    ┌─────────────────────────────────────────────────┐
    │ GO RUNTIME                                      │
    │ - Map atom IDs to text                          │
    │ - Concatenate in order                          │
    │ - Return: final prompt string                   │
    └─────────────────────────────────────────────────┘
    ```
    
    ## Summary: Correct Neuro-Symbolic Pattern
    
    This pattern demonstrates the **correct way** to combine:
    1. **Neural** (Vector DB): Fuzzy matching, semantic similarity
    2. **Symbolic** (Mangle): Exact reasoning, dependency resolution
    3. **Imperative** (Go): Assembly, I/O, orchestration
    
    Each system does what it excels at, creating a robust architecture.
