# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: failure_modes/09_go_integration_errors.md

- id: "language/mangle/docs/failure_modes/09_go_integration_errors"
  category: "language"
  subcategory: "mangle"
  description: "Failure Mode 9: Go Integration Errors"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Failure Mode 9: Go Integration Errors
    
    ## Category
    Go Integration (API Gaps)
    
    ## Severity
    HIGH - Runtime errors, type mismatches, program crashes
    
    ## Error Pattern
    Incorrect usage of the Mangle Go API when embedding the engine in Go programs. Common issues include wrong type construction, missing parse steps, and incorrect external predicate signatures.
    
    ## Wrong Code
    
    ### Error 1: String-Based Fact Construction
    ```go
    // WRONG - AI assumes string-based API
    store.Add("parent", "alice", "bob")
    store.Add("edge", 1, 2)
    
    // WRONG - Missing type wrappers
    f := engine.Fact{
        Predicate: "parent",
        Args: []interface{}{"alice", "bob"},
    }
    ```
    
    ### Error 2: Direct String Execution
    ```go
    // WRONG - Assumes direct execution
    result := engine.Run("ancestor(X, Y) :- parent(X, Y).")
    
    // WRONG - Missing parse step
    engine.EvalProgramNaive(ruleString, store)
    ```
    
    ### Error 3: Incorrect External Predicate
    ```go
    // WRONG - Returns interface{} instead of calling callback
    func myPredicate(query engine.Query) (interface{}, error) {
        return "result", nil
    }
    
    // WRONG - Ignores binding pattern
    func myPredicate(query engine.Query, cb func(engine.Fact)) error {
        // Always returns same results regardless of which args are bound
        cb(engine.MakeFact("result", engine.Atom("value")))
        return nil
    }
    ```
    
    ## Correct Code
    
    ### Correct Fact Construction
    ```go
    import (
        "github.com/google/mangle/engine"
        "github.com/google/mangle/factstore"
    )
    
    // CORRECT - Proper type construction
    f, err := factstore.MakeFact("/parent", []engine.Value{
        engine.Atom("alice"),
        engine.Atom("bob"),
    })
    if err != nil {
        return err
    }
    store.Add(f)
    
    // CORRECT - Integer facts
    edgeFact, _ := factstore.MakeFact("/edge", []engine.Value{
        engine.Number(1),
        engine.Number(2),
    })
    store.Add(edgeFact)
    
    // CORRECT - Mixed types
    mixedFact, _ := factstore.MakeFact("/data", []engine.Value{
        engine.Atom("key"),
        engine.String("value"),
        engine.Number(42),
    })
    store.Add(mixedFact)
    ```
    
    ### Correct Program Execution
    ```go
    import (
        "github.com/google/mangle/parse"
        "github.com/google/mangle/analysis"
    )
    
    // CORRECT - Parse, analyze, then evaluate
    ruleString := `
    ancestor(X, Y) :- parent(X, Y).
    ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).
    `
    
    // Step 1: Parse
    program, err := parse.Parse("rules.mg", ruleString)
    if err != nil {
        return fmt.Errorf("parse error: %w", err)
    }
    
    // Step 2: Analyze (checks safety, stratification)
    analyzed, err := analysis.AnalyzeOneUnit(program)
    if err != nil {
        return fmt.Errorf("analysis error: %w", err)
    }
    
    // Step 3: Evaluate
    result, err := engine.EvalProgramNaive(analyzed, store)
    if err != nil {
        return fmt.Errorf("evaluation error: %w", err)
    }
    ```
    
    ### Correct External Predicate
    ```go
    // CORRECT - Proper signature with callback
    func fileExists(query engine.Query, cb func(engine.Fact)) error {
        // Check binding pattern
        if len(query.Args) != 1 {
            return fmt.Errorf("file_exists/1 expects 1 argument")
        }
    
        arg := query.Args[0]
    
        switch arg.Type() {
        case engine.TypeConstant:
            // Argument is BOUND - check specific file
            if atom, ok := arg.(engine.Atom); ok {
                path := string(atom)
                if _, err := os.Stat(path); err == nil {
                    // File exists - return fact
                    fact, _ := factstore.MakeFact(":file_exists", []engine.Value{atom})
                    cb(fact)
                }
            }
    
        case engine.TypeVariable:
            // Argument is FREE - enumerate all known files
            files, _ := filepath.Glob("*.go")
            for _, file := range files {
                fact, _ := factstore.MakeFact(":file_exists", []engine.Value{
                    engine.String(file),
                })
                cb(fact)
            }
        }
    
        return nil
    }
    
    // Register the external predicate
    externalPredicates := map[string]engine.ExternalPredicate{
        "file_exists": fileExists,
    }
    ```
    
    ## Detection
    - **Symptom**: Type assertion errors at runtime
    - **Symptom**: "Unknown predicate" errors for external functions
    - **Symptom**: Parse errors not caught until evaluation
    - **Pattern**: Direct string manipulation instead of typed constructors
    - **Pattern**: Missing import of `parse` or `analysis` packages
    - **Test**: Check if external predicates handle both bound and free arguments
    
    ## Prevention
    
    ### Go API Checklist
    
    1. **Always use typed constructors:**
       - `engine.Atom(string)` for atoms (`/value`)
       - `engine.String(string)` for strings (`"value"`)
       - `engine.Number(int64)` for integers
       - `engine.Float(float64)` for floats
    
    2. **Always parse before evaluation:**
       - `parse.Parse(name, source)` → AST
       - `analysis.AnalyzeOneUnit(ast)` → Analyzed program
       - `engine.EvalProgramNaive(analyzed, store)` → Results
    
    3. **External predicates must:**
       - Accept `(query engine.Query, cb func(engine.Fact)) error`
       - Check argument binding patterns
       - Handle both bound (filter) and free (enumerate) cases
       - Call callback for each result
       - Return error only for failures, not empty results
    
    ## Type Construction Reference
    
    ### Basic Types
    ```go
    // Atoms (identifiers, enums)
    atomVal := engine.Atom("active")           // Represents /active
    userID := engine.Atom("user123")           // Represents /user123
    
    // Strings (text data)
    textVal := engine.String("Hello, World!")
    pathVal := engine.String("/path/to/file")
    
    // Numbers
    intVal := engine.Number(42)
    negVal := engine.Number(-17)
    floatVal := engine.Float(3.14)
    ```
    
    ### Fact Construction
    ```go
    // Create fact: parent(/alice, /bob)
    fact, err := factstore.MakeFact("/parent", []engine.Value{
        engine.Atom("alice"),
        engine.Atom("bob"),
    })
    if err != nil {
        // Handle error
    }
    store.Add(fact)
    
    // Create fact with mixed types: data(/key, "value", 42)
    fact2, _ := factstore.MakeFact("/data", []engine.Value{
        engine.Atom("key"),
        engine.String("value"),
        engine.Number(42),
    })
    store.Add(fact2)
    ```
    
    ### Struct/Map Construction
    ```go
    // Build map: {/host: "localhost", /port: 8080}
    mapVal := engine.Map(map[engine.Atom]engine.Value{
        engine.Atom("host"): engine.String("localhost"),
        engine.Atom("port"): engine.Number(8080),
    })
    
    fact, _ := factstore.MakeFact("/config", []engine.Value{mapVal})
    store.Add(fact)
    ```
    
    ### List Construction
    ```go
    // Build list: [1, 2, 3]
    listVal := engine.List([]engine.Value{
        engine.Number(1),
        engine.Number(2),
        engine.Number(3),
    })
    
    fact, _ := factstore.MakeFact("/numbers", []engine.Value{listVal})
    store.Add(fact)
    ```
    
    ## External Predicate Patterns
    
    ### Pattern 1: Bound Argument (Filter)
    ```go
    func envVar(query engine.Query, cb func(engine.Fact)) error {
        if len(query.Args) != 2 {
            return fmt.Errorf("env_var/2 expects 2 arguments")
        }
    
        keyArg := query.Args[0]
    
        if keyArg.Type() == engine.TypeConstant {
            // Key is BOUND - lookup specific env var
            if str, ok := keyArg.(engine.String); ok {
                if val, exists := os.LookupEnv(string(str)); exists {
                    fact, _ := factstore.MakeFact(":env_var", []engine.Value{
                        str,
                        engine.String(val),
                    })
                    cb(fact)
                }
            }
        }
    
        return nil
    }
    ```
    
    ### Pattern 2: Free Argument (Enumerate)
    ```go
    func listFiles(query engine.Query, cb func(engine.Fact)) error {
        if len(query.Args) != 1 {
            return fmt.Errorf("list_files/1 expects 1 argument")
        }
    
        arg := query.Args[0]
    
        if arg.Type() == engine.TypeVariable {
            // Argument is FREE - enumerate all files
            files, err := filepath.Glob("*.go")
            if err != nil {
                return err
            }
    
            for _, file := range files {
                fact, _ := factstore.MakeFact(":list_files", []engine.Value{
                    engine.String(file),
                })
                cb(fact)
            }
        } else if arg.Type() == engine.TypeConstant {
            // Argument is BOUND - check if file exists
            if str, ok := arg.(engine.String); ok {
                if _, err := os.Stat(string(str)); err == nil {
                    fact, _ := factstore.MakeFact(":list_files", []engine.Value{str})
                    cb(fact)
                }
            }
        }
    
        return nil
    }
    ```
    
    ### Pattern 3: Mixed Bound/Free Arguments
    ```go
    func readFile(query engine.Query, cb func(engine.Fact)) error {
        // read_file(Path, Content)
        if len(query.Args) != 2 {
            return fmt.Errorf("read_file/2 expects 2 arguments")
        }
    
        pathArg := query.Args[0]
        contentArg := query.Args[1]
    
        // Path must be bound
        if pathArg.Type() != engine.TypeConstant {
            return fmt.Errorf("read_file/2 requires bound path")
        }
    
        path, ok := pathArg.(engine.String)
        if !ok {
            return fmt.Errorf("path must be string")
        }
    
        // Read file
        content, err := os.ReadFile(string(path))
        if err != nil {
            return nil  // Not an error - file just doesn't exist
        }
    
        contentVal := engine.String(string(content))
    
        // If content is bound, check it matches
        if contentArg.Type() == engine.TypeConstant {
            if contentArg == contentVal {
                fact, _ := factstore.MakeFact(":read_file", []engine.Value{path, contentVal})
                cb(fact)
            }
        } else {
            // Content is free - return actual content
            fact, _ := factstore.MakeFact(":read_file", []engine.Value{path, contentVal})
            cb(fact)
        }
    
        return nil
    }
    ```
    
    ## Complete Integration Example
    
    ```go
    package main
    
    import (
        "fmt"
        "github.com/google/mangle/engine"
        "github.com/google/mangle/factstore"
        "github.com/google/mangle/parse"
        "github.com/google/mangle/analysis"
    )
    
    func main() {
        // 1. Create fact store
        store := factstore.NewSimpleStore()
    
        // 2. Add base facts
        addFact(store, "/parent", "alice", "bob")
        addFact(store, "/parent", "bob", "charlie")
    
        // 3. Parse rules
        program, err := parse.Parse("rules.mg", `
            ancestor(X, Y) :- parent(X, Y).
            ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).
        `)
        if err != nil {
            panic(err)
        }
    
        // 4. Analyze
        analyzed, err := analysis.AnalyzeOneUnit(program)
        if err != nil {
            panic(err)
        }
    
        // 5. Evaluate
        result, err := engine.EvalProgramNaive(analyzed, store)
        if err != nil {
            panic(err)
        }
    
        // 6. Query results
        query := parse.MustParse("query.mg", "?ancestor(X, Y)")
        facts, err := engine.Query(result, query)
        if err != nil {
            panic(err)
        }
    
        // 7. Process facts
        for _, fact := range facts {
            fmt.Printf("ancestor(%v, %v)\n", fact.Args[0], fact.Args[1])
        }
    }
    
    func addFact(store factstore.FactStore, pred string, args ...string) {
        values := make([]engine.Value, len(args))
        for i, arg := range args {
            values[i] = engine.Atom(arg)
        }
        fact, _ := factstore.MakeFact(pred, values)
        store.Add(fact)
    }
    ```
    
    ## Training Bias Origins
    | Language | Pattern | Leads to Wrong Mangle Go Code |
    |----------|---------|------------------------------|
    | Python | `exec(code_string)` | Assuming direct string execution |
    | JavaScript | Dynamic typing | Passing raw strings/ints without wrappers |
    | SQL | `connection.execute(query)` | Missing parse/analyze steps |
    | Generic APIs | `func(args...)` variadic | Not using typed Value constructors |
    
    ## Quick Check
    Before writing Go integration code:
    1. Are facts constructed with `factstore.MakeFact` and typed values?
    2. Is code parsed with `parse.Parse` before evaluation?
    3. Is parsed code analyzed with `analysis.AnalyzeOneUnit`?
    4. Do external predicates use the callback pattern?
    5. Do external predicates check argument binding patterns?
    6. Are errors handled at each step (parse, analyze, eval)?
    
    ## Debugging Aid
    ```go
    // Add debug logging to trace fact construction
    func addFactDebug(store factstore.FactStore, pred string, args ...engine.Value) {
        fact, err := factstore.MakeFact(pred, args)
        if err != nil {
            fmt.Printf("ERROR creating fact %s: %v\n", pred, err)
            return
        }
        fmt.Printf("Adding fact: %v\n", fact)
        store.Add(fact)
    }
    
    // Debug external predicate calls
    func debugExternal(name string) engine.ExternalPredicate {
        return func(query engine.Query, cb func(engine.Fact)) error {
            fmt.Printf("External predicate %s called with args: %v\n", name, query.Args)
            return nil
        }
    }
    ```
