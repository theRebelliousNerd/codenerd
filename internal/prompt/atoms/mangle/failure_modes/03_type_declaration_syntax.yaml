# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: failure_modes/03_type_declaration_syntax.md

- id: "language/mangle/docs/failure_modes/03_type_declaration_syntax"
  category: "language"
  subcategory: "mangle"
  description: "Failure Mode 3: Type Declaration Syntax"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Failure Mode 3: Type Declaration Syntax
    
    ## Category
    Syntactic Hallucination (Souffle/TypeScript Bias)
    
    ## Severity
    HIGH - Parse errors preventing program load
    
    ## Error Pattern
    Using Souffle `.decl` syntax or other declaration styles instead of Mangle's unique `Decl ... Type<>` syntax.
    
    ## Wrong Code
    ```mangle
    # WRONG - Souffle syntax
    .decl direct_dep(app: string, lib: string)
    
    # WRONG - TypeScript style
    type DirectDep = { app: string, lib: string }
    
    # WRONG - SQL style
    CREATE TABLE direct_dep (app VARCHAR, lib VARCHAR)
    
    # WRONG - Missing Type<> wrapper
    Decl direct_dep(App.string, Lib.string).
    
    # WRONG - Lowercase 'decl'
    decl parent(X.Type<n>, Y.Type<n>).
    
    # WRONG - Using colon separator
    Decl status(Entity: Type<n>, State: Type<n>).
    
    # WRONG - Forgetting period at end
    Decl edge(X.Type<int>, Y.Type<int>)
    ```
    
    ## Correct Code
    ```mangle
    # CORRECT - Basic string types
    Decl direct_dep(App.Type<string>, Lib.Type<string>).
    
    # CORRECT - Atom/name types
    Decl status(Entity.Type<n>, State.Type<n>).
    
    # CORRECT - Integer types
    Decl edge(From.Type<int>, To.Type<int>).
    
    # CORRECT - Float types
    Decl temperature(Sensor.Type<n>, Value.Type<float>).
    
    # CORRECT - List type
    Decl tags(ID.Type<int>, Tags.Type<[string]>).
    
    # CORRECT - Nested list
    Decl matrix(ID.Type<int>, Data.Type<[[int]]>).
    
    # CORRECT - Map/struct type
    Decl config(
        ID.Type<int>,
        Data.Type<{/host: string, /port: int, /enabled: n}>
    ).
    
    # CORRECT - Any type (matches anything)
    Decl metadata(Key.Type<n>, Value.Type<Any>).
    
    # CORRECT - Mixed complex type
    Decl record(
        ID.Type<int>,
        Name.Type<string>,
        Status.Type<n>,
        Scores.Type<[float]>,
        Config.Type<{/timeout: int, /retries: int}>
    ).
    ```
    
    ## Detection
    - **Symptom**: Parse error on declaration line
    - **Pattern**: `.decl` prefix instead of `Decl`
    - **Pattern**: `: Type` instead of `.Type`
    - **Pattern**: Missing `Type<>` wrapper
    - **Pattern**: Lowercase `decl`
    - **Pattern**: Missing period at end
    - **Test**: `grep -E '^\s*\.decl' *.mg` to find Souffle-style declarations
    - **Test**: `grep -E 'Decl.*:\s*Type' *.mg` to find colon separators
    
    ## Prevention
    
    ### Type Code Reference
    | Mangle Type | Syntax | Example Values | Use For |
    |-------------|--------|----------------|---------|
    | **Integer** | `Type<int>` | `42`, `-17`, `0` | Counters, IDs, numeric data |
    | **Float** | `Type<float>` | `3.14`, `-2.5`, `0.0` | Measurements, scores |
    | **String** | `Type<string>` | `"hello"`, `"file.txt"` | Text, messages, paths |
    | **Name/Atom** | `Type<n>` | `/active`, `/user1` | Identifiers, enums, flags |
    | **List** | `Type<[T]>` | `[1, 2, 3]`, `[/a, /b]` | Collections |
    | **Map** | `Type<{/k: v, ...}>` | `{/x: 10, /y: 20}` | Structured data |
    | **Any** | `Type<Any>` | (any value) | Generic/dynamic |
    
    ### Declaration Syntax Rules
    1. **Always start with uppercase `Decl`** (not `.decl`, not lowercase)
    2. **Variable names UPPERCASE** (`App`, `Lib`, not `app`, `lib`)
    3. **Use dot separator** (`.Type<>`, not `: Type<>`)
    4. **Wrap type in `Type<>`** (not bare `string` or `int`)
    5. **End with period** (`.` is required)
    6. **Atom keys in maps use `/`** prefix (`/host`, not `host`)
    
    ### Complete Examples by Use Case
    
    #### Simple Predicates
    ```mangle
    # Binary relation
    Decl parent(Parent.Type<n>, Child.Type<n>).
    
    # Ternary with mixed types
    Decl sales(Region.Type<n>, Product.Type<string>, Amount.Type<float>).
    
    # Status tracking
    Decl task_status(TaskID.Type<int>, Status.Type<n>, Timestamp.Type<int>).
    ```
    
    #### Complex Data Structures
    ```mangle
    # List of tags
    Decl file_tags(Path.Type<string>, Tags.Type<[n]>).
    
    # Map configuration
    Decl server_config(
        Name.Type<n>,
        Config.Type<{
            /host: string,
            /port: int,
            /timeout: int,
            /retry: n
        }>
    ).
    
    # Nested structures
    Decl dependency_graph(
        Package.Type<n>,
        Deps.Type<[{/name: n, /version: string}]>
    ).
    ```
    
    #### Virtual Predicates (Go FFI)
    ```mangle
    # External predicate signature must match Go implementation
    Decl :file_exists(Path.Type<string>).
    Decl :read_file(Path.Type<string>, Content.Type<string>).
    Decl :env_var(Key.Type<string>, Value.Type<string>).
    ```
    
    ## Training Bias Origins
    | Language | Syntax | Leads to Wrong Mangle |
    |----------|--------|----------------------|
    | Souffle | `.decl parent(x: symbol, y: symbol)` | `.decl` prefix |
    | TypeScript | `type Parent = { x: string, y: string }` | `type` keyword |
    | SQL | `CREATE TABLE parent (x VARCHAR, y VARCHAR)` | SQL DDL |
    | Prolog | `parent(X, Y).` (no declarations) | Missing declaration entirely |
    
    ## Quick Check
    Before writing declarations:
    1. Does it start with uppercase `Decl`? (not `.decl`)
    2. Are variable names UPPERCASE? (`X`, `Y`, not `x`, `y`)
    3. Is `.Type<>` used for every parameter?
    4. Are atom map keys prefixed with `/`? (`/host`, not `host`)
    5. Does it end with a period `.`?
    
    ## Common Patterns to Memorize
    ```mangle
    # Pattern: EDB fact (external data)
    Decl fact_name(Arg1.Type<type1>, Arg2.Type<type2>).
    
    # Pattern: IDB rule head (derived predicate)
    # (Same declaration syntax, but defined via rules)
    Decl derived_name(Arg1.Type<type1>, Arg2.Type<type2>).
    
    # Pattern: Virtual predicate (Go implementation)
    Decl :external_name(Arg1.Type<type1>, Result.Type<type2>).
    ```
