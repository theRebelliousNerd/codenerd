# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: failure_modes/11_mangle_as_hashmap_antipattern.md

- id: "language/mangle/docs/failure_modes/11_mangle_as_hashmap_antipattern"
  category: "language"
  subcategory: "mangle"
  description: "Failure Mode 11: Mangle as HashMap Anti-Pattern"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Failure Mode 11: Mangle as HashMap Anti-Pattern
    
    ## Category
    Architectural Anti-Pattern (DSL Trap)
    
    ## Severity
    CRITICAL - Architectural misuse, performance disaster
    
    ## Error Pattern
    Storing hundreds of exact-match patterns in Mangle expecting fuzzy/semantic matching, when Mangle can only do **exact unification**. This is the "DSL Trap" - treating `.mg` files as design documents mixing taxonomy, intents, and rules.
    
    ## Wrong Code
    ```mangle
    # WRONG - Storing 400+ patterns expecting fuzzy matching
    intent_definition("review my code", /review, "file_types").
    intent_definition("check for bugs", /debug, "codebase").
    intent_definition("look at my code", /review, "file_types").
    intent_definition("Review my code", /review, "file_types").  # Case variation!
    intent_definition("examine my code", /review, "file_types").
    intent_definition("inspect my code", /review, "file_types").
    # ... 400 more variations
    
    # WRONG - Trying to match user input directly
    matched_intent(Verb) :-
        user_input(Input),
        intent_definition(Input, Verb, _).  # Only works for EXACT matches!
    
    # WRONG - Mixing taxonomy pseudocode with Mangle
    # TAXONOMY: /vehicle > /car > /sedan  # PARSE ERROR!
    # INTENT: "my car won't start" -> /breakdown_support  # PARSE ERROR!
    
    # WRONG - Using hallucinated string functions
    matched_intent(Verb) :-
        user_input(Input),
        intent_definition(Pattern, Verb, _),
        fn:string_contains(Input, Pattern).  # DOES NOT EXIST!
    
    # WRONG - Trying substring matching
    matched_intent(Verb) :-
        user_input(Input),
        intent_definition(Pattern, Verb, _),
        fn:substring(Input, Pattern).  # DOES NOT EXIST!
    ```
    
    ## Correct Code
    
    ### Architecture: Neuro-Symbolic Split
    ```text
    User Input: "check my code for security issues"
                    ↓
    ┌───────────────────────────────────────┐
    │ EMBEDDING LAYER (Go/Python)          │
    │ - Encode input as vector              │
    │ - Semantic search in vector DB        │
    │ - Returns: [(text, verb, score), ...]│
    └───────────────────────────────────────┘
                    ↓
    ┌───────────────────────────────────────┐
    │ INJECT AS MANGLE FACTS               │
    │ semantic_match(Input, Canon, Verb, Score)│
    └───────────────────────────────────────┘
                    ↓
    ┌───────────────────────────────────────┐
    │ MANGLE KERNEL (Deductive Reasoning)  │
    │ - Apply scoring rules                │
    │ - Handle verb composition             │
    │ - Enforce safety constraints          │
    │ - Derive final action                 │
    └───────────────────────────────────────┘
    ```
    
    ### Correct Mangle Usage
    ```mangle
    # Schema for semantic matches (injected by Go)
    Decl semantic_match(
        Input.Type<string>,
        Canonical.Type<string>,
        Verb.Type<n>,
        Score.Type<float>
    ).
    
    # Mangle handles DEDUCTION, not matching
    selected_verb(Verb) :-
        semantic_match(_, _, Verb, Score),
        Score >= 85.  # High-confidence threshold
    
    # Verb composition (multi-step intents)
    compound_action(V1, V2) :-
        semantic_match(_, _, V1, S1),
        semantic_match(_, _, V2, S2),
        S1 >= 70,
        S2 >= 70,
        verb_composition(V1, V2, /sequential).
    
    # Safety constraints
    permitted(ActionType, Target, Payload) :-
        selected_verb(ActionType),
        pending_action(_, ActionType, Target, Payload, _),
        not blocked_action(ActionType),
        not requires_approval(ActionType).
    
    # Conflict resolution
    suppressed(Verb) :-
        selected_verb(Verb),
        selected_verb(Higher),
        verb_priority(Higher, P1),
        verb_priority(Verb, P2),
        P1 > P2.
    
    final_action(Verb) :-
        selected_verb(Verb),
        permitted(Verb, _, _),
        not suppressed(Verb).
    ```
    
    ### Go Pre-Processor Pattern (Split-Brain Loader)
    ```go
    // Hybrid file format:
    // INTENT: "phrase" -> /verb    (routed to Vector DB)
    // TAXONOMY: /child > /parent   (routed to Mangle facts)
    // Real Mangle rules             (parsed normally)
    
    func LoadHybridFile(path string, vectorDB VectorStore, store factstore.FactStore) (string, error) {
        file, _ := os.Open(path)
        scanner := bufio.NewScanner(file)
        var mangleCode strings.Builder
    
        for scanner.Scan() {
            line := strings.TrimSpace(scanner.Text())
    
            // Route INTENT to Vector DB (fuzzy matching)
            if strings.HasPrefix(line, "INTENT:") {
                phrase, verbAtom := parseIntentLine(line)
                vectorDB.Add(phrase, verbAtom)
                continue // Don't send to Mangle parser!
            }
    
            // Route TAXONOMY to Mangle facts (graph structure)
            if strings.HasPrefix(line, "TAXONOMY:") {
                child, parent := parseTaxonomyLine(line)
                // Inject: subclass_of(/child, /parent)
                fact := makeFact("subclass_of", child, parent)
                store.Add(fact)
                continue
            }
    
            // Real Mangle logic - keep for compiler
            mangleCode.WriteString(line + "\n")
        }
    
        return mangleCode.String(), nil
    }
    ```
    
    ## Detection
    - **Symptom**: Hundreds of ground facts with string literals
    - **Symptom**: Duplicate facts with case/punctuation variations
    - **Symptom**: Predicates named `*_definition` or `*_pattern`
    - **Symptom**: Parse errors for `fn:string_contains`, `fn:substring`, etc.
    - **Symptom**: Empty results despite "obvious" matches
    - **Pattern**: Treating Mangle as lookup table instead of logic engine
    
    ## Prevention
    
    ### The Three Categories (DO NOT MIX)
    
    | Category | Example | Correct Home | Why |
    |----------|---------|--------------|-----|
    | **Taxonomy** | `/vehicle > /car > /sedan` | Mangle facts (via Go) | Graph reasoning |
    | **Intents** | `"I need help" -> /support` | Vector DB | Fuzzy matching |
    | **Rules** | `permitted(A, T, P) :- safe(A), pending_action(_, A, T, P, _).` | Mangle engine | Logic/deduction |
    
    ### Invalid String Functions (DO NOT EXIST)
    
    AI agents frequently hallucinate these functions that **DO NOT EXIST in Mangle**:
    
    ```mangle
    # ALL OF THESE WILL FAIL WITH PARSE ERRORS:
    fn:string_contains(Input, Keyword)   # DOES NOT EXIST
    fn:contains(Input, Keyword)          # DOES NOT EXIST
    fn:substring(S, Start, End)          # DOES NOT EXIST
    fn:match(S, Pattern)                 # DOES NOT EXIST
    fn:regex(S, Pattern)                 # DOES NOT EXIST
    fn:lower(S)                          # DOES NOT EXIST
    fn:upper(S)                          # DOES NOT EXIST
    fn:trim(S)                           # DOES NOT EXIST
    fn:split(S, Delim)                   # DOES NOT EXIST
    fn:startswith(S, Prefix)             # DOES NOT EXIST
    fn:endswith(S, Suffix)               # DOES NOT EXIST
    ```
    
    ### Valid Built-in Functions (Complete List)
    
    **Arithmetic**:
    - `fn:plus(X, Y)`, `fn:minus(X, Y)`, `fn:mult(X, Y)`, `fn:div(X, Y)`, `fn:mod(X, Y)`
    
    **Comparison** (use directly, not as functions):
    - `X = Y`, `X != Y`, `X < Y`, `X > Y`, `X <= Y`, `X >= Y`
    
    **Aggregation** (must use pipeline):
    - `fn:Count()`, `fn:Sum(X)`, `fn:Min(X)`, `fn:Max(X)`, `fn:group_by(X)`, `fn:collect(X)`
    
    **List/Data**:
    - `fn:list(A, B, C)`, `fn:len(L)`, `fn:concat(A, B)`, `fn:append(L, X)`, `fn:pair(K, V)`
    - `fn:map_get(M, K, Default)`
    
    **Struct Access** (use `:` prefix, not `fn:`):
    - `:match_field(Struct, /key, Value)`, `:match_entry(Map, /key, Value)`
    
    ## Use Mangle For (What It Excels At)
    
    ```mangle
    # ✓ Deductive reasoning based on facts
    selected_verb(Verb) :-
        semantic_match(_, _, Verb, Score),
        Score >= 85.
    
    # ✓ Transitive closure (recursive logic)
    all_deps(X, Y) :- direct_dep(X, Y).
    all_deps(X, Z) :- direct_dep(X, Y), all_deps(Y, Z).
    
    # ✓ Safety constraints
    permitted(ActionType, Target, Payload) :-
        selected_verb(ActionType),
        pending_action(_, ActionType, Target, Payload, _),
        not blocked_action(ActionType),
        user_has_permission(ActionType).
    
    # ✓ Conflict resolution
    winning_choice(A) :-
        candidate(A),
        not dominated(A).
    
    dominated(A) :-
        candidate(A),
        candidate(B),
        better(B, A).
    
    # ✓ Composition rules
    compound_action(V1, V2) :-
        semantic_match(_, _, V1, S1),
        semantic_match(_, _, V2, S2),
        S1 >= 70,
        S2 >= 70,
        compatible(V1, V2).
    ```
    
    ## Do NOT Use Mangle For
    
    ```mangle
    # ✗ Storing 400+ exact-match patterns
    # intent_definition("review code", /review).  # NO!
    
    # ✗ String/substring matching
    # relevant(P) :- fn:contains(Text, Query).  # NO!
    
    # ✗ Fuzzy text similarity
    # match(Input, Pattern) :- fn:similarity(Input, Pattern) > 0.8.  # NO!
    
    # ✗ Natural language understanding
    # intent(Input, /review) :- fn:parse_nl(Input).  # NO!
    ```
    
    ## Red Flags: Signs of Mangle Misuse
    
    1. **Hundreds of ground facts with string literals** - Data masquerading as logic
    2. **Duplicate facts with case/punctuation variations** - Compensating for no fuzzy matching
    3. **Predicates named `*_definition` or `*_pattern`** - Likely storing lookup data
    4. **Rules with `fn:string_*` or `fn:contains`** - Will fail with parse errors
    5. **Using Mangle to match user input directly** - Should use embeddings first
    
    ## Complex Example: Intent Recognition Architecture
    
    ### WRONG Approach
    ```mangle
    # BAD - Storing all patterns in Mangle
    intent("review my code", /review).
    intent("check my code", /review).
    intent("look at my code", /review).
    intent("examine my code", /review).
    # ... 100 more variations
    
    matched(Verb) :-
        user_said(Input),
        intent(Input, Verb).  # Only exact matches work!
    ```
    
    ### CORRECT Approach
    ```go
    // Step 1: Vector DB for fuzzy matching (Python/Go)
    func MatchIntent(userInput string, vectorDB VectorStore) []SemanticMatch {
        embedding := Embed(userInput)
        results := vectorDB.Search(embedding, topK: 5)
        // Returns: [
        //   {canonical: "review code", verb: "/review", score: 0.92},
        //   {canonical: "security scan", verb: "/security", score: 0.74},
        // ]
        return results
    }
    
    // Step 2: Inject as Mangle facts
    func InjectMatches(matches []SemanticMatch, store FactStore) {
        for _, m := range matches {
            fact := MakeFact("semantic_match",
                String(userInput),
                String(m.Canonical),
                Atom(m.Verb),
                Float(m.Score),
            )
            store.Add(fact)
        }
    }
    ```
    
    ```mangle
    # Step 3: Mangle for deductive reasoning
    Decl semantic_match(Input.Type<string>, Canon.Type<string>, Verb.Type<n>, Score.Type<float>).
    Decl verb_priority(Verb.Type<n>, Priority.Type<int>).
    Decl blocked_action(Action.Type<n>).
    
    # High-confidence matches
    high_confidence(Verb) :-
        semantic_match(_, _, Verb, Score),
        Score >= 0.85.
    
    # Priority-based selection
    top_choice(Verb) :-
        high_confidence(Verb),
        verb_priority(Verb, P),
        not higher_priority_exists(P).
    
    higher_priority_exists(P) :-
        high_confidence(OtherVerb),
        verb_priority(OtherVerb, P2),
        P2 > P.
    
    # Safety gate
    final_action(Verb) :-
        top_choice(Verb),
        not blocked_action(Verb).
    ```
    
    ## Why This Matters
    
    ### Exact Unification Only
    Mangle unification is **syntactic equality**:
    ```mangle
    # These will NEVER match:
    "review my code" ≠ "check my code"
    "Review" ≠ "review" (case-sensitive)
    "test" ≠ "testing" (no stemming)
    ```
    
    ### No String Operations
    Mangle has **no string manipulation**:
    - No `substring`, `contains`, `split`
    - No regex, pattern matching
    - No case conversion, trimming
    
    ### Performance Disaster
    Storing 400+ exact patterns:
    - Huge fact table (memory)
    - Slow matching (O(n) linear search)
    - Still returns nothing unless exact match
    - Should use indexed vector DB instead (O(log n))
    
    ## Training Bias Origins
    | Language | Pattern | Leads to Wrong Mangle |
    |----------|---------|----------------------|
    | SQL | `WHERE col LIKE '%pattern%'` | Assuming substring matching |
    | Elasticsearch | Full-text search | Thinking Mangle has text search |
    | Regex | Pattern matching | Hallucinating `fn:regex` |
    | Python | `if keyword in text:` | Expecting contains() |
    
    ## Quick Check
    Before storing data in Mangle:
    1. Is this **lookup data** (patterns, definitions)? → Use Vector DB
    2. Is this **fuzzy matching** (NL understanding)? → Use embeddings
    3. Is this **deductive rules** (logic, composition)? → Use Mangle
    4. Are you storing 100+ similar string facts? → Wrong approach!
    5. Do you need substring/contains/regex? → Mangle can't do this!
    
    ## Debugging Aid
    ```mangle
    # Count how many "definition" predicates you have:
    Decl intent_definition(Pattern.Type<string>, Verb.Type<n>).
    
    pattern_count(N) :-
        intent_definition(P, _) |>
        let N = fn:Count().
    
    # If N > 50 → You're probably misusing Mangle!
    # These should be in a Vector DB, not Mangle facts.
    ```
    
    ## Salvage Strategy: Migration Path
    
    If you have existing files mixing data and logic:
    
    ```text
    # Before (mixed file):
    INTENT: "review my code" -> /review
    INTENT: "check for bugs" -> /debug
    ancestor(X, Y) :- parent(X, Y).
    ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).
    
    # After (split):
    # 1. intents.jsonl (Vector DB)
    {"text": "review my code", "verb": "/review"}
    {"text": "check for bugs", "verb": "/debug"}
    
    # 2. rules.mg (Mangle)
    ancestor(X, Y) :- parent(X, Y).
    ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).
    ```
    
    ## Summary: Data vs Rules
    
    | Type | Belongs In | Example |
    |------|------------|---------|
    | **Exact-match patterns** | Vector DB | `intent_definition("review code", /review)` |
    | **Fuzzy matches** | Embedding search | "check my code" → similarity to "review code" |
    | **Composition rules** | Mangle | `compound_action(V1, V2) :- ...` |
    | **Safety constraints** | Mangle | `permitted(A, T, P) :- ..., not blocked(A).` |
    | **Transitive relations** | Mangle | `ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).` |
    | **Taxonomy graph** | Mangle facts | `subclass_of(/sedan, /car).` |
    | **Taxonomy reasoning** | Mangle rules | `is_a(X, Z) :- subclass_of(X, Y), is_a(Y, Z).` |
