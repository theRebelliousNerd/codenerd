# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: patterns/graph_traversal.md

- id: "language/mangle/docs/patterns/graph_traversal"
  category: "language"
  subcategory: "mangle"
  description: "Graph Traversal Patterns"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Graph Traversal Patterns
    
    ## Problem Description
    
    Graph traversal is fundamental to program analysis, dependency resolution, and reachability queries. Common needs:
    - Transitive closure (can X reach Y?)
    - Shortest paths
    - All paths between nodes
    - Connected components
    
    ## Core Pattern: Transitive Closure
    
    ### Template
    ```mangle
    # Direct edge
    reachable(X, Y) :- edge(X, Y).
    
    # Recursive step
    reachable(X, Z) :- reachable(X, Y), edge(Y, Z).
    ```
    
    ### Complete Working Example
    ```mangle
    # Schema
    Decl edge(From.Type<string>, To.Type<string>).
    Decl reachable(From.Type<string>, To.Type<string>).
    
    # Facts
    edge("a", "b").
    edge("b", "c").
    edge("c", "d").
    edge("a", "e").
    edge("e", "d").
    
    # Transitive Closure
    reachable(X, Y) :- edge(X, Y).
    reachable(X, Z) :- reachable(X, Y), edge(Y, Z).
    
    # Query: Can "a" reach "d"?
    # Answer: reachable("a", "d") - YES (two paths: a->b->c->d and a->e->d)
    ```
    
    ## Variation 1: Bidirectional Reachability
    
    ### Problem
    Need to traverse edges in both directions (undirected graph).
    
    ### Solution
    ```mangle
    # Schema
    Decl edge(From.Type<string>, To.Type<string>).
    Decl connected(A.Type<string>, B.Type<string>).
    
    # Create symmetric edges
    connected(X, Y) :- edge(X, Y).
    connected(X, Y) :- edge(Y, X).
    
    # Transitive closure on symmetric relation
    connected(X, Z) :- connected(X, Y), connected(Y, Z).
    ```
    
    ### Example
    ```mangle
    edge("a", "b").
    edge("b", "c").
    
    # Results in:
    # connected("a", "b"), connected("b", "a")
    # connected("b", "c"), connected("c", "b")
    # connected("a", "c"), connected("c", "a")
    ```
    
    ## Variation 2: Path Length (Distance)
    
    ### Problem
    Find shortest distance between nodes.
    
    ### Solution
    ```mangle
    # Schema
    Decl edge(From.Type<string>, To.Type<string>).
    Decl distance(From.Type<string>, To.Type<string>, Dist.Type<int>).
    
    # Direct edges have distance 1
    distance(X, Y, 1) :- edge(X, Y).
    
    # Recursive: extend path by 1
    distance(X, Z, D) :-
      distance(X, Y, D1),
      edge(Y, Z),
      D = fn:plus(D1, 1).
    
    # Shortest path (minimum distance)
    Decl shortest_path(From.Type<string>, To.Type<string>, MinDist.Type<int>).
    
    shortest_path(From, To, MinDist) :-
      distance(From, To, Dist)
      |> do fn:group_by(From, To),
         let MinDist = fn:Min(Dist).
    ```
    
    ### Example
    ```mangle
    edge("a", "b").
    edge("b", "c").
    edge("a", "c").
    
    # Results:
    # distance("a", "b", 1)
    # distance("a", "c", 1)  # direct
    # distance("a", "c", 2)  # via b
    # shortest_path("a", "c", 1)  # takes the direct route
    ```
    
    ## Variation 3: Cycle Detection
    
    ### Problem
    Detect if there are cycles in the graph.
    
    ### Solution
    ```mangle
    # Schema
    Decl edge(From.Type<string>, To.Type<string>).
    Decl has_cycle(Node.Type<string>).
    
    # A node is in a cycle if it can reach itself
    has_cycle(X) :- edge(X, Y), reachable(Y, X).
    
    # Or define reachable first:
    reachable(X, Y) :- edge(X, Y).
    reachable(X, Z) :- reachable(X, Y), edge(Y, Z).
    
    has_cycle(X) :- reachable(X, X).
    ```
    
    ### Example
    ```mangle
    edge("a", "b").
    edge("b", "c").
    edge("c", "a").  # Cycle!
    
    # Result: has_cycle("a"), has_cycle("b"), has_cycle("c")
    ```
    
    ## Variation 4: Bounded Depth Traversal
    
    ### Problem
    Limit traversal to N hops (prevent infinite expansion).
    
    ### Solution
    ```mangle
    # Schema
    Decl edge(From.Type<string>, To.Type<string>).
    Decl reachable_within(From.Type<string>, To.Type<string>, Depth.Type<int>).
    
    # Direct edges at depth 1
    reachable_within(X, Y, 1) :- edge(X, Y).
    
    # Recursive with depth limit
    reachable_within(X, Z, D) :-
      reachable_within(X, Y, D1),
      edge(Y, Z),
      D1 < 5,  # Max depth
      D = fn:plus(D1, 1).
    ```
    
    ### Example
    ```mangle
    edge("a", "b").
    edge("b", "c").
    edge("c", "d").
    edge("d", "e").
    edge("e", "f").
    edge("f", "g").
    
    # reachable_within("a", ?, ?) will stop at depth 5
    # Won't include reachable_within("a", "g", 6)
    ```
    
    ## Variation 5: All Nodes in Component
    
    ### Problem
    Find all nodes in the same connected component as a given node.
    
    ### Solution
    ```mangle
    # Schema
    Decl edge(From.Type<string>, To.Type<string>).
    Decl in_component(Seed.Type<string>, Member.Type<string>).
    
    # Bidirectional reachability from seed
    in_component(Seed, Seed).
    in_component(Seed, Y) :- in_component(Seed, X), edge(X, Y).
    in_component(Seed, Y) :- in_component(Seed, X), edge(Y, X).
    ```
    
    ### Example
    ```mangle
    edge("a", "b").
    edge("b", "c").
    edge("x", "y").  # Separate component
    
    # in_component("a", ?) gives: "a", "b", "c"
    # in_component("x", ?) gives: "x", "y"
    ```
    
    ## Anti-Patterns
    
    ### WRONG: Forgetting Base Case
    ```mangle
    # Missing direct edge case!
    reachable(X, Z) :- reachable(X, Y), edge(Y, Z).
    # Result: reachable will be empty (no base to build from)
    ```
    
    ### WRONG: Unbounded Recursion
    ```mangle
    # No termination condition
    all_paths(X, Y, N) :- all_paths(X, Y, M), N = fn:plus(M, 1).
    # Result: Infinite derivation
    ```
    
    ### WRONG: Creating Variables in Recursion
    ```mangle
    # Bad: generates infinite paths
    path(X, Y, [X, Y]) :- edge(X, Y).
    path(X, Z, NewPath) :- path(X, Y, OldPath), edge(Y, Z), NewPath = fn:append(OldPath, Z).
    # Lists in Mangle recursion require careful stratification
    ```
    
    ## Performance Tips
    
    1. **Selectivity First**: Place most restrictive predicates early
       ```mangle
       # Good
       reachable(X, "target") :- X = "source", reachable(X, "target").
    
       # Bad
       reachable(X, Y) :- reachable(X, Y), X = "source", Y = "target".
       ```
    
    2. **Avoid Cartesian Products**: Always join on common variables
       ```mangle
       # Good
       path(X, Z) :- path(X, Y), edge(Y, Z).
    
       # Bad
       path(X, Z) :- path(A, B), edge(C, D), ...  # No common vars!
       ```
    
    3. **Use Depth Limits**: For large graphs, bound recursion depth
    
    4. **Stratify When Possible**: Break complex traversals into stages
       ```mangle
       # Stage 1: Local reachability
       local_reach(X, Y) :- edge(X, Y), distance(X, Y) < 3.
    
       # Stage 2: Global from local
       global_reach(X, Z) :- local_reach(X, Y), local_reach(Y, Z).
       ```
