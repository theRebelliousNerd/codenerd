# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: patterns/default_values.md

- id: "language/mangle/docs/patterns/default_values"
  category: "language"
  subcategory: "mangle"
  description: "Default Values Patterns"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Default Values Patterns
    
    ## Problem Description
    
    Handling missing data and providing defaults is critical for robust queries. Common needs:
    - Provide default when data is missing
    - Fill gaps with fallback values
    - Cascade through multiple sources
    - Handle optional attributes
    - NULL coalescing
    
    ## Core Pattern: Basic Default
    
    ### Template
    ```mangle
    # Use actual value if it exists
    result(X, Value) :- data(X, Value).
    
    # Use default if no actual value
    result(X, DefaultValue) :-
      candidate(X),
      not data(X, _),
      DefaultValue = "default".
    ```
    
    ### Complete Working Example
    ```mangle
    # Schema
    Decl user(UserId.Type<string>).
    Decl email(UserId.Type<string>, Email.Type<string>).
    Decl user_email(UserId.Type<string>, Email.Type<string>).
    
    # Facts
    user("u1").
    user("u2").
    user("u3").
    
    email("u1", "u1@example.com").
    email("u3", "u3@example.com").
    # u2 has no email
    
    # Use actual email if it exists
    user_email(UserId, Email) :- email(UserId, Email).
    
    # Use default email if no actual email
    user_email(UserId, "no-email@example.com") :-
      user(UserId),
      not email(UserId, _).
    
    # Query: user_email(UserId, Email)
    # Results:
    # user_email("u1", "u1@example.com")
    # user_email("u2", "no-email@example.com")  # Default
    # user_email("u3", "u3@example.com")
    ```
    
    ## Variation 1: Cascading Defaults (Coalesce)
    
    ### Problem
    Try multiple sources in priority order, use first available.
    
    ### Solution
    ```mangle
    # Schema
    Decl entity(Id.Type<string>).
    Decl primary_value(Id.Type<string>, Value.Type<string>).
    Decl secondary_value(Id.Type<string>, Value.Type<string>).
    Decl tertiary_value(Id.Type<string>, Value.Type<string>).
    Decl final_value(Id.Type<string>, Value.Type<string>).
    
    # Priority 1: Use primary if available
    final_value(Id, Value) :- primary_value(Id, Value).
    
    # Priority 2: Use secondary if no primary
    final_value(Id, Value) :-
      entity(Id),
      not primary_value(Id, _),
      secondary_value(Id, Value).
    
    # Priority 3: Use tertiary if no primary or secondary
    final_value(Id, Value) :-
      entity(Id),
      not primary_value(Id, _),
      not secondary_value(Id, _),
      tertiary_value(Id, Value).
    
    # Priority 4: Use default if none available
    final_value(Id, "DEFAULT") :-
      entity(Id),
      not primary_value(Id, _),
      not secondary_value(Id, _),
      not tertiary_value(Id, _).
    ```
    
    ### Example
    ```mangle
    entity("e1").
    entity("e2").
    entity("e3").
    entity("e4").
    
    primary_value("e1", "primary1").
    secondary_value("e1", "secondary1").  # Ignored - primary exists
    
    secondary_value("e2", "secondary2").  # No primary
    
    tertiary_value("e3", "tertiary3").    # No primary or secondary
    
    # e4 has nothing - will get default
    
    # Results:
    # final_value("e1", "primary1")
    # final_value("e2", "secondary2")
    # final_value("e3", "tertiary3")
    # final_value("e4", "DEFAULT")
    ```
    
    ## Variation 2: Numeric Defaults (Zero-Fill)
    
    ### Problem
    Replace missing numeric values with zero.
    
    ### Solution
    ```mangle
    # Schema
    Decl user(UserId.Type<string>).
    Decl purchase(UserId.Type<string>, Amount.Type<int>).
    Decl user_total(UserId.Type<string>, Total.Type<int>).
    
    # Users with purchases - sum them
    user_total(UserId, Total) :-
      purchase(UserId, Amount)
      |> do fn:group_by(UserId),
         let Total = fn:Sum(Amount).
    
    # Users with no purchases - default to 0
    user_total(UserId, 0) :-
      user(UserId),
      not purchase(UserId, _).
    ```
    
    ### Example
    ```mangle
    user("u1").
    user("u2").
    user("u3").
    
    purchase("u1", 100).
    purchase("u1", 200).
    purchase("u3", 50).
    
    # Results:
    # user_total("u1", 300)
    # user_total("u2", 0)    # Default
    # user_total("u3", 50)
    ```
    
    ## Variation 3: Inherited Defaults (Hierarchy)
    
    ### Problem
    Use parent's value if child doesn't have one.
    
    ### Solution
    ```mangle
    # Schema
    Decl node(Id.Type<string>).
    Decl parent(Child.Type<string>, Parent.Type<string>).
    Decl own_value(Id.Type<string>, Value.Type<string>).
    Decl effective_value(Id.Type<string>, Value.Type<string>).
    
    # Use own value if it exists
    effective_value(Id, Value) :- own_value(Id, Value).
    
    # Inherit from parent if no own value
    effective_value(Child, Value) :-
      node(Child),
      not own_value(Child, _),
      parent(Child, Parent),
      effective_value(Parent, Value).  # Recursive inheritance
    
    # Root default (no parent, no own value)
    effective_value(Id, "ROOT_DEFAULT") :-
      node(Id),
      not own_value(Id, _),
      not parent(Id, _).
    ```
    
    ### Example
    ```mangle
    node("root").
    node("child1").
    node("child2").
    node("grandchild").
    
    parent("child1", "root").
    parent("child2", "root").
    parent("grandchild", "child1").
    
    own_value("root", "root_value").
    own_value("child2", "child2_value").
    # child1 and grandchild have no own values
    
    # Results:
    # effective_value("root", "root_value")
    # effective_value("child1", "root_value")      # Inherited from root
    # effective_value("child2", "child2_value")    # Own value
    # effective_value("grandchild", "root_value")  # Inherited through child1
    ```
    
    ## Variation 4: Conditional Defaults
    
    ### Problem
    Use different defaults based on other attributes.
    
    ### Solution
    ```mangle
    # Schema
    Decl user(UserId.Type<string>, Country.Type<string>).
    Decl custom_setting(UserId.Type<string>, Value.Type<string>).
    Decl effective_setting(UserId.Type<string>, Value.Type<string>).
    
    # Use custom setting if exists
    effective_setting(UserId, Value) :- custom_setting(UserId, Value).
    
    # Default varies by country
    effective_setting(UserId, "US_DEFAULT") :-
      user(UserId, "USA"),
      not custom_setting(UserId, _).
    
    effective_setting(UserId, "EU_DEFAULT") :-
      user(UserId, "EU"),
      not custom_setting(UserId, _).
    
    effective_setting(UserId, "GLOBAL_DEFAULT") :-
      user(UserId, Country),
      Country != "USA",
      Country != "EU",
      not custom_setting(UserId, _).
    ```
    
    ### Example
    ```mangle
    user("u1", "USA").
    user("u2", "EU").
    user("u3", "Japan").
    user("u4", "USA").
    
    custom_setting("u1", "CUSTOM1").
    
    # Results:
    # effective_setting("u1", "CUSTOM1")        # Custom
    # effective_setting("u2", "EU_DEFAULT")     # EU default
    # effective_setting("u3", "GLOBAL_DEFAULT") # Global default
    # effective_setting("u4", "US_DEFAULT")     # US default
    ```
    
    ## Variation 5: Range Defaults (Fill Missing Numbers)
    
    ### Problem
    Fill missing values in a numeric sequence.
    
    ### Solution
    ```mangle
    # Schema
    Decl expected_sequence(N.Type<int>).
    Decl actual_value(N.Type<int>, Value.Type<string>).
    Decl complete_sequence(N.Type<int>, Value.Type<string>).
    
    # Use actual value if it exists
    complete_sequence(N, Value) :- actual_value(N, Value).
    
    # Fill gaps with placeholder
    complete_sequence(N, "MISSING") :-
      expected_sequence(N),
      not actual_value(N, _).
    ```
    
    ### Example
    ```mangle
    expected_sequence(1).
    expected_sequence(2).
    expected_sequence(3).
    expected_sequence(4).
    expected_sequence(5).
    
    actual_value(1, "first").
    actual_value(3, "third").
    actual_value(5, "fifth").
    
    # Results:
    # complete_sequence(1, "first")
    # complete_sequence(2, "MISSING")
    # complete_sequence(3, "third")
    # complete_sequence(4, "MISSING")
    # complete_sequence(5, "fifth")
    ```
    
    ## Variation 6: Interpolation (Forward Fill)
    
    ### Problem
    Use last known value for missing entries.
    
    ### Solution
    ```mangle
    # Schema
    Decl time_point(T.Type<int>).
    Decl measurement(T.Type<int>, Value.Type<int>).
    Decl filled_value(T.Type<int>, Value.Type<int>).
    
    # Use actual measurement if exists
    filled_value(T, Value) :- measurement(T, Value).
    
    # Forward fill: use most recent previous value
    filled_value(T, Value) :-
      time_point(T),
      not measurement(T, _),
      # Find max time before T that has a measurement
      measurement(PrevT, Value),
      PrevT < T
      |> do fn:group_by(T),
         let MaxPrevT = fn:Max(PrevT),
      PrevT = MaxPrevT.
    ```
    
    ### Example
    ```mangle
    time_point(1).
    time_point(2).
    time_point(3).
    time_point(4).
    time_point(5).
    
    measurement(1, 100).
    # 2 missing
    measurement(3, 150).
    # 4 missing
    measurement(5, 200).
    
    # Results:
    # filled_value(1, 100)
    # filled_value(2, 100)  # Forward fill from 1
    # filled_value(3, 150)
    # filled_value(4, 150)  # Forward fill from 3
    # filled_value(5, 200)
    ```
    
    ## Variation 7: Aggregate-Based Defaults
    
    ### Problem
    Use aggregate statistic (mean, median, mode) as default.
    
    ### Solution
    ```mangle
    # Schema
    Decl item(Id.Type<string>, Category.Type<string>).
    Decl actual_price(Id.Type<string>, Price.Type<int>).
    Decl category_avg_price(Category.Type<string>, AvgPrice.Type<float>).
    Decl effective_price(Id.Type<string>, Price.Type<float>).
    
    # Calculate average price per category
    category_avg_price(Category, AvgPrice) :-
      item(ItemId, Category),
      actual_price(ItemId, Price)
      |> do fn:group_by(Category),
         let AvgPrice = fn:Avg(Price).
    
    # Use actual price if exists
    effective_price(Id, Price) :-
      actual_price(Id, IntPrice),
      Price = fn:to_float(IntPrice).
    
    # Use category average as default
    effective_price(Id, AvgPrice) :-
      item(Id, Category),
      not actual_price(Id, _),
      category_avg_price(Category, AvgPrice).
    ```
    
    ### Example
    ```mangle
    item("i1", "electronics").
    item("i2", "electronics").
    item("i3", "electronics").
    
    actual_price("i1", 1000).
    actual_price("i3", 2000).
    # i2 missing - will use average of i1 and i3
    
    # Results:
    # category_avg_price("electronics", 1500.0)
    # effective_price("i1", 1000.0)
    # effective_price("i2", 1500.0)  # Average
    # effective_price("i3", 2000.0)
    ```
    
    ## Variation 8: Multi-Attribute Defaults
    
    ### Problem
    Provide defaults for multiple optional attributes.
    
    ### Solution
    ```mangle
    # Schema
    Decl user(UserId.Type<string>).
    Decl user_name(UserId.Type<string>, Name.Type<string>).
    Decl user_email(UserId.Type<string>, Email.Type<string>).
    Decl user_phone(UserId.Type<string>, Phone.Type<string>).
    Decl user_profile(UserId.Type<string>, Name.Type<string>, Email.Type<string>, Phone.Type<string>).
    
    # Combine actuals with defaults
    Decl name_or_default(UserId.Type<string>, Name.Type<string>).
    name_or_default(UserId, Name) :- user_name(UserId, Name).
    name_or_default(UserId, "Anonymous") :- user(UserId), not user_name(UserId, _).
    
    Decl email_or_default(UserId.Type<string>, Email.Type<string>).
    email_or_default(UserId, Email) :- user_email(UserId, Email).
    email_or_default(UserId, "no-email") :- user(UserId), not user_email(UserId, _).
    
    Decl phone_or_default(UserId.Type<string>, Phone.Type<string>).
    phone_or_default(UserId, Phone) :- user_phone(UserId, Phone).
    phone_or_default(UserId, "no-phone") :- user(UserId), not user_phone(UserId, _).
    
    # Build complete profile
    user_profile(UserId, Name, Email, Phone) :-
      user(UserId),
      name_or_default(UserId, Name),
      email_or_default(UserId, Email),
      phone_or_default(UserId, Phone).
    ```
    
    ### Example
    ```mangle
    user("u1").
    user("u2").
    
    user_name("u1", "Alice").
    user_email("u1", "alice@example.com").
    # u1 missing phone
    
    user_email("u2", "bob@example.com").
    # u2 missing name and phone
    
    # Results:
    # user_profile("u1", "Alice", "alice@example.com", "no-phone")
    # user_profile("u2", "Anonymous", "bob@example.com", "no-phone")
    ```
    
    ## Variation 9: Computed Defaults
    
    ### Problem
    Calculate default value based on other data.
    
    ### Solution
    ```mangle
    # Schema
    Decl item(Id.Type<string>, BasePrice.Type<int>).
    Decl custom_discount(Id.Type<string>, Discount.Type<float>).
    Decl effective_discount(Id.Type<string>, Discount.Type<float>).
    
    # Use custom discount if exists
    effective_discount(Id, Discount) :- custom_discount(Id, Discount).
    
    # Compute default: 10% for items over $1000, 5% otherwise
    effective_discount(Id, 0.10) :-
      item(Id, BasePrice),
      not custom_discount(Id, _),
      BasePrice > 1000.
    
    effective_discount(Id, 0.05) :-
      item(Id, BasePrice),
      not custom_discount(Id, _),
      BasePrice <= 1000.
    ```
    
    ### Example
    ```mangle
    item("i1", 1500).
    item("i2", 500).
    item("i3", 2000).
    
    custom_discount("i1", 0.15).
    
    # Results:
    # effective_discount("i1", 0.15)  # Custom
    # effective_discount("i2", 0.05)  # Computed (<=1000)
    # effective_discount("i3", 0.10)  # Computed (>1000)
    ```
    
    ## Variation 10: Time-Based Defaults
    
    ### Problem
    Use time-dependent defaults (expire and fallback).
    
    ### Solution
    ```mangle
    # Schema
    Decl setting(Key.Type<string>, Value.Type<string>, ExpiresAt.Type<int>).
    Decl current_time(T.Type<int>).
    Decl effective_setting(Key.Type<string>, Value.Type<string>).
    
    # Use setting if not expired
    effective_setting(Key, Value) :-
      setting(Key, Value, ExpiresAt),
      current_time(Now),
      Now < ExpiresAt.
    
    # Use default if expired or not set
    effective_setting(Key, "DEFAULT_VALUE") :-
      current_time(Now),
      not (setting(Key, Value, ExpiresAt), Now < ExpiresAt).
    ```
    
    ### Example
    ```mangle
    current_time(1000).
    
    setting("key1", "active_value", 2000).  # Not expired
    setting("key2", "expired_value", 500).  # Expired
    # key3 not set
    
    # Results:
    # effective_setting("key1", "active_value")
    # effective_setting("key2", "DEFAULT_VALUE")  # Expired
    # effective_setting("key3", "DEFAULT_VALUE")  # Not set
    ```
    
    ## Anti-Patterns
    
    ### WRONG: Overlapping Rules (Ambiguous Defaults)
    ```mangle
    # Bad - both rules can match!
    result(X, "default1") :- entity(X), not data(X, _).
    result(X, "default2") :- entity(X), not data(X, _).
    
    # Result: Both facts are derived! Confusing.
    # Fix: Use mutually exclusive conditions
    ```
    
    ### WRONG: Infinite Default Chain
    ```mangle
    # Bad - circular dependency
    value(X, V) :- primary(X, V).
    value(X, V) :- not primary(X, _), value(X, V).  # Circular!
    
    # Fix: Break the cycle with explicit base case
    ```
    
    ### WRONG: Ignoring Stratification
    ```mangle
    # Bad - negation requires stratification
    result(X, Default) :- not result(X, _), Default = "default".
    
    # This asks: "Give me X with default if result(X) doesn't exist"
    # But result is being defined BY this rule!
    
    # Fix: Use separate predicates
    actual(X, V) :- data(X, V).
    result(X, V) :- actual(X, V).
    result(X, "default") :- candidate(X), not actual(X, _).
    ```
    
    ## Performance Tips
    
    1. **Materialize Defaults**: Pre-compute default values if reused
    2. **Stratify Properly**: Compute actuals before defaults
    3. **Avoid Redundant Checks**: Use mutually exclusive rules
    4. **Index Lookups**: Index predicates used in negation checks
    
    ## Common Use Cases in codeNERD
    
    ### Configuration Defaults
    ```mangle
    Decl config_key(Key.Type<string>).
    Decl user_config(UserId.Type<string>, Key.Type<string>, Value.Type<string>).
    Decl system_default(Key.Type<string>, Value.Type<string>).
    Decl effective_config(UserId.Type<string>, Key.Type<string>, Value.Type<string>).
    
    effective_config(UserId, Key, Value) :- user_config(UserId, Key, Value).
    effective_config(UserId, Key, Value) :-
      config_key(Key),
      not user_config(UserId, Key, _),
      system_default(Key, Value).
    ```
    
    ### Test Timeout Defaults
    ```mangle
    Decl test(TestId.Type<string>, Suite.Type<string>).
    Decl custom_timeout(TestId.Type<string>, TimeoutMs.Type<int>).
    Decl effective_timeout(TestId.Type<string>, TimeoutMs.Type<int>).
    
    effective_timeout(TestId, TimeoutMs) :- custom_timeout(TestId, TimeoutMs).
    effective_timeout(TestId, 5000) :- test(TestId, _), not custom_timeout(TestId, _).
    ```
    
    ### File Metadata Defaults
    ```mangle
    Decl file(Path.Type<string>).
    Decl file_encoding(Path.Type<string>, Encoding.Type<string>).
    Decl effective_encoding(Path.Type<string>, Encoding.Type<string>).
    
    effective_encoding(Path, Encoding) :- file_encoding(Path, Encoding).
    effective_encoding(Path, "UTF-8") :- file(Path), not file_encoding(Path, _).
    ```
