# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: patterns/temporal.md

- id: "language/mangle/docs/patterns/temporal"
  category: "language"
  subcategory: "mangle"
  description: "Temporal Patterns"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Temporal Patterns
    
    ## Problem Description
    
    Time-based queries are critical for:
    - Event ordering and sequencing
    - Time range filters
    - Duration calculations
    - Temporal relationships (before, after, during, overlaps)
    
    ## Core Pattern: Event Ordering
    
    ### Template
    ```mangle
    # Event happens before another
    before(E1, E2) :- event(E1, T1), event(E2, T2), T1 < T2.
    
    # Immediate predecessor (no event between)
    immediately_before(E1, E2) :-
      before(E1, E2),
      not (before(E1, E3), before(E3, E2)).
    ```
    
    ### Complete Working Example
    ```mangle
    # Schema
    Decl event(Name.Type<string>, Timestamp.Type<int>).
    Decl before(E1.Type<string>, E2.Type<string>).
    Decl immediately_before(E1.Type<string>, E2.Type<string>).
    
    # Facts - Unix timestamps
    event("login", 1000).
    event("click", 1005).
    event("purchase", 1010).
    event("logout", 1015).
    
    # Rules
    before(E1, E2) :- event(E1, T1), event(E2, T2), T1 < T2.
    
    immediately_before(E1, E2) :-
      before(E1, E2),
      not (before(E1, E3), before(E3, E2)).
    
    # Query: immediately_before(X, Y)
    # Results:
    # immediately_before("login", "click")
    # immediately_before("click", "purchase")
    # immediately_before("purchase", "logout")
    ```
    
    ## Variation 1: Time Range Filtering
    
    ### Problem
    Find events within a specific time window.
    
    ### Solution
    ```mangle
    # Schema
    Decl event(Name.Type<string>, Timestamp.Type<int>).
    Decl in_range(Name.Type<string>, T.Type<int>, Start.Type<int>, End.Type<int>).
    
    in_range(Name, T, Start, End) :-
      event(Name, T),
      T >= Start,
      T <= End.
    ```
    
    ### Example
    ```mangle
    event("e1", 1000).
    event("e2", 1500).
    event("e3", 2000).
    event("e4", 2500).
    
    # Query: in_range(Name, T, 1200, 2200)
    # Results:
    # in_range("e2", 1500, 1200, 2200)
    # in_range("e3", 2000, 1200, 2200)
    ```
    
    ## Variation 2: Duration Calculation
    
    ### Problem
    Calculate time elapsed between events.
    
    ### Solution
    ```mangle
    # Schema
    Decl event(Name.Type<string>, Timestamp.Type<int>).
    Decl session_start(SessionId.Type<string>, Time.Type<int>).
    Decl session_end(SessionId.Type<string>, Time.Type<int>).
    Decl session_duration(SessionId.Type<string>, Duration.Type<int>).
    
    session_duration(SessionId, Duration) :-
      session_start(SessionId, Start),
      session_end(SessionId, End),
      Duration = fn:minus(End, Start).
    ```
    
    ### Example
    ```mangle
    session_start("s1", 1000).
    session_end("s1", 1500).
    
    session_start("s2", 2000).
    session_end("s2", 2100).
    
    # Results:
    # session_duration("s1", 500)
    # session_duration("s2", 100)
    ```
    
    ## Variation 3: Event Sequences (Happens-Before Chain)
    
    ### Problem
    Track causal chains of events (A must happen before B before C).
    
    ### Solution
    ```mangle
    # Schema
    Decl event(Name.Type<string>, Timestamp.Type<int>, SessionId.Type<string>).
    Decl valid_sequence(SessionId.Type<string>).
    
    # Valid sequence: login -> action -> logout
    valid_sequence(Sid) :-
      event("login", T1, Sid),
      event("action", T2, Sid),
      event("logout", T3, Sid),
      T1 < T2,
      T2 < T3.
    ```
    
    ### Example
    ```mangle
    # Good session
    event("login", 1000, "s1").
    event("action", 1005, "s1").
    event("logout", 1010, "s1").
    
    # Bad session (out of order)
    event("action", 2000, "s2").
    event("login", 2005, "s2").
    event("logout", 2010, "s2").
    
    # Results:
    # valid_sequence("s1")  # YES
    # NOT valid_sequence("s2")  # NO - wrong order
    ```
    
    ## Variation 4: Time Windows / Bucketing
    
    ### Problem
    Group events into time buckets (hourly, daily, etc.).
    
    ### Solution
    ```mangle
    # Schema
    Decl event(Name.Type<string>, Timestamp.Type<int>).
    Decl event_bucket(Name.Type<string>, Bucket.Type<int>).
    
    # Bucket size: 3600 seconds (1 hour)
    event_bucket(Name, Bucket) :-
      event(Name, Timestamp),
      Bucket = fn:div(Timestamp, 3600).
    ```
    
    ### Example
    ```mangle
    event("e1", 1000).   # Bucket 0
    event("e2", 3700).   # Bucket 1
    event("e3", 5000).   # Bucket 1
    event("e4", 7300).   # Bucket 2
    
    # Results:
    # event_bucket("e1", 0)
    # event_bucket("e2", 1)
    # event_bucket("e3", 1)
    # event_bucket("e4", 2)
    ```
    
    ## Variation 5: Overlapping Intervals
    
    ### Problem
    Find intervals that overlap in time.
    
    ### Solution
    ```mangle
    # Schema
    Decl interval(Id.Type<string>, Start.Type<int>, End.Type<int>).
    Decl overlaps(A.Type<string>, B.Type<string>).
    
    # Two intervals overlap if one starts before the other ends
    overlaps(A, B) :-
      interval(A, StartA, EndA),
      interval(B, StartB, EndB),
      A != B,
      StartA < EndB,
      StartB < EndA.
    ```
    
    ### Example
    ```mangle
    interval("i1", 1000, 2000).
    interval("i2", 1500, 2500).  # Overlaps i1
    interval("i3", 3000, 4000).  # No overlap
    
    # Results:
    # overlaps("i1", "i2")
    # overlaps("i2", "i1")
    # NOT overlaps("i1", "i3")
    ```
    
    ## Variation 6: Sliding Window
    
    ### Problem
    Find events within N seconds of each other.
    
    ### Solution
    ```mangle
    # Schema
    Decl event(Name.Type<string>, Timestamp.Type<int>).
    Decl within_window(E1.Type<string>, E2.Type<string>, WindowSize.Type<int>).
    
    # Events within window seconds of each other
    within_window(E1, E2, WindowSize) :-
      event(E1, T1),
      event(E2, T2),
      E1 != E2,
      Diff = fn:minus(T2, T1),
      Diff >= 0,
      Diff <= WindowSize.
    ```
    
    ### Example
    ```mangle
    event("e1", 1000).
    event("e2", 1003).
    event("e3", 1010).
    event("e4", 1020).
    
    # Query: within_window(E1, E2, 5)
    # Results:
    # within_window("e1", "e2", 5)  # 3 seconds apart
    # within_window("e2", "e3", 5)  # 7 seconds apart - NO
    # within_window("e1", "e3", 5)  # 10 seconds apart - NO
    ```
    
    ## Variation 7: Time-to-Event
    
    ### Problem
    Calculate time between a reference event and target events.
    
    ### Solution
    ```mangle
    # Schema
    Decl event(Type.Type<string>, Timestamp.Type<int>, UserId.Type<string>).
    Decl time_to_conversion(UserId.Type<string>, Duration.Type<int>).
    
    # Time from signup to purchase
    time_to_conversion(UserId, Duration) :-
      event("signup", T1, UserId),
      event("purchase", T2, UserId),
      T2 > T1,
      Duration = fn:minus(T2, T1).
    ```
    
    ### Example
    ```mangle
    event("signup", 1000, "u1").
    event("purchase", 1500, "u1").
    
    event("signup", 2000, "u2").
    event("purchase", 2100, "u2").
    
    # Results:
    # time_to_conversion("u1", 500)
    # time_to_conversion("u2", 100)
    ```
    
    ## Variation 8: Most Recent Event
    
    ### Problem
    Find the most recent event for each entity.
    
    ### Solution
    ```mangle
    # Schema
    Decl event(Entity.Type<string>, EventType.Type<string>, Timestamp.Type<int>).
    Decl latest_event(Entity.Type<string>, EventType.Type<string>, MaxTime.Type<int>).
    
    latest_event(Entity, EventType, MaxTime) :-
      event(Entity, EventType, Timestamp)
      |> do fn:group_by(Entity, EventType),
         let MaxTime = fn:Max(Timestamp).
    ```
    
    ### Example
    ```mangle
    event("user1", "login", 1000).
    event("user1", "login", 1500).
    event("user1", "login", 1200).
    event("user1", "logout", 1600).
    
    # Results:
    # latest_event("user1", "login", 1500)
    # latest_event("user1", "logout", 1600)
    ```
    
    ## Variation 9: Gap Detection
    
    ### Problem
    Find gaps in event sequences (missing expected events).
    
    ### Solution
    ```mangle
    # Schema
    Decl event(Sequence.Type<int>, Timestamp.Type<int>).
    Decl expected_sequence(N.Type<int>).
    Decl missing_event(N.Type<int>).
    
    # Expected sequence: 1 through 10
    expected_sequence(1).
    expected_sequence(2).
    expected_sequence(3).
    # ... etc
    
    # Gap: expected but not present
    missing_event(N) :- expected_sequence(N), not event(N, _).
    ```
    
    ### Example
    ```mangle
    event(1, 1000).
    event(2, 1005).
    # event(3, ???) - MISSING
    event(4, 1015).
    
    expected_sequence(1).
    expected_sequence(2).
    expected_sequence(3).
    expected_sequence(4).
    
    # Results:
    # missing_event(3)
    ```
    
    ## Variation 10: Rate Limiting / Frequency
    
    ### Problem
    Count events per time window.
    
    ### Solution
    ```mangle
    # Schema
    Decl event(User.Type<string>, Timestamp.Type<int>).
    Decl event_count_in_window(User.Type<string>, Start.Type<int>, End.Type<int>, Count.Type<int>).
    
    event_count_in_window(User, Start, End, Count) :-
      event(User, T),
      T >= Start,
      T <= End
      |> do fn:group_by(User, Start, End),
         let Count = fn:Count().
    ```
    
    ### Example
    ```mangle
    event("u1", 1000).
    event("u1", 1005).
    event("u1", 1010).
    event("u2", 1003).
    
    # Query: event_count_in_window(User, 1000, 1010, Count)
    # Results:
    # event_count_in_window("u1", 1000, 1010, 3)
    # event_count_in_window("u2", 1000, 1010, 1)
    ```
    
    ## Anti-Patterns
    
    ### WRONG: Comparing Timestamps as Strings
    ```mangle
    # Bad - lexicographic comparison
    before(E1, E2) :- event(E1, "2024-01-10"), event(E2, "2024-01-02").
    # "2024-01-10" < "2024-01-02" is TRUE (string comparison)
    # Fix: Use integer timestamps
    ```
    
    ### WRONG: Forgetting Timezone Normalization
    ```mangle
    # Events from different timezones need normalization before comparison
    # Always convert to UTC or a single timezone first
    ```
    
    ### WRONG: Unbounded Temporal Recursion
    ```mangle
    # Infinite chain
    next_event(E1, E2) :- next_event(E0, E1), event(E2), timestamp(E2) > timestamp(E1).
    # Fix: Use bounded traversal or materialize ordering
    ```
    
    ## Performance Tips
    
    1. **Index Timestamps**: Most temporal queries filter on time ranges
    2. **Pre-compute Ordering**: Materialize `before` relation if reused
    3. **Bucket Early**: Group into time windows before complex queries
    4. **Limit Ranges**: Always bound time queries (START, END)
    
    ## Common Use Cases in codeNERD
    
    ### Session Tracking
    ```mangle
    Decl session_event(SessionId.Type<string>, EventType.Type<string>, Time.Type<int>).
    Decl session_active(SessionId.Type<string>, Start.Type<int>, End.Type<int>).
    
    session_active(Sid, Start, End) :-
      session_event(Sid, "start", Start),
      session_event(Sid, "end", End),
      End > Start.
    ```
    
    ### Code Change History
    ```mangle
    Decl file_modified(Path.Type<string>, Timestamp.Type<int>, CommitHash.Type<string>).
    Decl recent_change(Path.Type<string>, MaxTime.Type<int>).
    
    recent_change(Path, MaxTime) :-
      file_modified(Path, Timestamp, _)
      |> do fn:group_by(Path),
         let MaxTime = fn:Max(Timestamp).
    ```
    
    ### Test Execution Timeline
    ```mangle
    Decl test_run(TestId.Type<string>, StartTime.Type<int>, EndTime.Type<int>).
    Decl test_duration(TestId.Type<string>, Duration.Type<int>).
    
    test_duration(TestId, Duration) :-
      test_run(TestId, Start, End),
      Duration = fn:minus(End, Start).
    ```
