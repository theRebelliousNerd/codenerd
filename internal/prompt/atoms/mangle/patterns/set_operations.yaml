# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: patterns/set_operations.md

- id: "language/mangle/docs/patterns/set_operations"
  category: "language"
  subcategory: "mangle"
  description: "Set Operations Patterns"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Set Operations Patterns
    
    ## Problem Description
    
    Set operations are fundamental for combining and comparing collections. Common needs:
    - Union (A ∪ B)
    - Intersection (A ∩ B)
    - Difference (A - B)
    - Symmetric difference (A Δ B)
    - Subset/superset checks
    - Disjoint sets
    
    ## Core Pattern: Union
    
    ### Template
    ```mangle
    # Union: Items in A or B (or both)
    union(X) :- set_a(X).
    union(X) :- set_b(X).
    ```
    
    ### Complete Working Example
    ```mangle
    # Schema
    Decl set_a(Elem.Type<string>).
    Decl set_b(Elem.Type<string>).
    Decl union_result(Elem.Type<string>).
    
    # Facts
    set_a("a").
    set_a("b").
    set_a("c").
    
    set_b("b").
    set_b("c").
    set_b("d").
    set_b("e").
    
    # Union
    union_result(X) :- set_a(X).
    union_result(X) :- set_b(X).
    
    # Query: union_result(X)
    # Results: "a", "b", "c", "d", "e"
    ```
    
    ## Variation 1: Intersection
    
    ### Problem
    Find elements common to both sets (A ∩ B).
    
    ### Solution
    ```mangle
    # Schema
    Decl set_a(Elem.Type<string>).
    Decl set_b(Elem.Type<string>).
    Decl intersection(Elem.Type<string>).
    
    # Intersection: Items in both A and B
    intersection(X) :- set_a(X), set_b(X).
    ```
    
    ### Example
    ```mangle
    set_a("a").
    set_a("b").
    set_a("c").
    
    set_b("b").
    set_b("c").
    set_b("d").
    
    # Results: intersection("b"), intersection("c")
    ```
    
    ## Variation 2: Difference (A - B)
    
    ### Problem
    Find elements in A but not in B.
    
    ### Solution
    ```mangle
    # Schema
    Decl set_a(Elem.Type<string>).
    Decl set_b(Elem.Type<string>).
    Decl difference(Elem.Type<string>).
    
    # A - B: Items in A but not in B
    difference(X) :- set_a(X), not set_b(X).
    ```
    
    ### Example
    ```mangle
    set_a("a").
    set_a("b").
    set_a("c").
    
    set_b("b").
    set_b("c").
    set_b("d").
    
    # Result: difference("a")
    # NOT "b" or "c" (in both)
    # NOT "d" (only in B)
    ```
    
    ## Variation 3: Symmetric Difference (XOR)
    
    ### Problem
    Find elements in A or B, but not both (A Δ B).
    
    ### Solution
    ```mangle
    # Schema
    Decl set_a(Elem.Type<string>).
    Decl set_b(Elem.Type<string>).
    Decl symmetric_difference(Elem.Type<string>).
    
    # In A but not B
    symmetric_difference(X) :- set_a(X), not set_b(X).
    
    # In B but not A
    symmetric_difference(X) :- set_b(X), not set_a(X).
    ```
    
    ### Example
    ```mangle
    set_a("a").
    set_a("b").
    set_a("c").
    
    set_b("b").
    set_b("c").
    set_b("d").
    
    # Results: symmetric_difference("a"), symmetric_difference("d")
    # NOT "b" or "c" (in both)
    ```
    
    ## Variation 4: Subset Check (A ⊆ B)
    
    ### Problem
    Verify that all elements of A are in B.
    
    ### Solution
    ```mangle
    # Schema
    Decl set_a(Elem.Type<string>).
    Decl set_b(Elem.Type<string>).
    Decl is_subset(Result.Type<atom>).
    
    # A is subset of B if there's no element in A that's not in B
    is_subset(/yes) :- not (set_a(X), not set_b(X)).
    
    # Alternative: find counterexample
    Decl in_a_not_b(Elem.Type<string>).
    in_a_not_b(X) :- set_a(X), not set_b(X).
    
    is_subset(/no) :- in_a_not_b(_).
    is_subset(/yes) :- not in_a_not_b(_).
    ```
    
    ### Example
    ```mangle
    # Scenario 1: A ⊆ B
    set_a("b").
    set_a("c").
    
    set_b("a").
    set_b("b").
    set_b("c").
    set_b("d").
    
    # Result: is_subset(/yes)
    
    # Scenario 2: A ⊄ B
    set_a("x").  # x not in B
    # Result: is_subset(/no)
    ```
    
    ## Variation 5: Proper Subset (A ⊂ B)
    
    ### Problem
    Verify A is a proper subset of B (A ⊆ B and A ≠ B).
    
    ### Solution
    ```mangle
    # Schema
    Decl set_a(Elem.Type<string>).
    Decl set_b(Elem.Type<string>).
    Decl is_proper_subset(Result.Type<atom>).
    
    # A ⊂ B means:
    # 1. A ⊆ B (no element in A that's not in B)
    # 2. B has at least one element not in A
    
    is_proper_subset(/yes) :-
      not (set_a(X), not set_b(X)),    # A ⊆ B
      set_b(Y), not set_a(Y).          # B has something A doesn't
    
    is_proper_subset(/no) :-
      set_a(X), not set_b(X).          # A ⊄ B
    
    is_proper_subset(/no) :-
      not (set_b(Y), not set_a(Y)),    # A = B (not proper)
      not (set_a(X), not set_b(X)).
    ```
    
    ### Example
    ```mangle
    set_a("b").
    set_a("c").
    
    set_b("a").
    set_b("b").
    set_b("c").
    
    # Result: is_proper_subset(/yes)
    # A ⊆ B, and B has "a" which A doesn't
    ```
    
    ## Variation 6: Disjoint Sets
    
    ### Problem
    Check if two sets have no common elements.
    
    ### Solution
    ```mangle
    # Schema
    Decl set_a(Elem.Type<string>).
    Decl set_b(Elem.Type<string>).
    Decl are_disjoint(Result.Type<atom>).
    
    # Disjoint if no element is in both
    are_disjoint(/yes) :- not (set_a(X), set_b(X)).
    are_disjoint(/no) :- set_a(X), set_b(X).
    ```
    
    ### Example
    ```mangle
    # Scenario 1: Disjoint
    set_a("a").
    set_a("b").
    
    set_b("x").
    set_b("y").
    
    # Result: are_disjoint(/yes)
    
    # Scenario 2: Not disjoint
    set_a("a").
    set_a("b").
    set_b("b").  # Common element!
    
    # Result: are_disjoint(/no)
    ```
    
    ## Variation 7: Set Equality
    
    ### Problem
    Check if two sets contain exactly the same elements.
    
    ### Solution
    ```mangle
    # Schema
    Decl set_a(Elem.Type<string>).
    Decl set_b(Elem.Type<string>).
    Decl are_equal(Result.Type<atom>).
    
    # Equal if A ⊆ B and B ⊆ A
    are_equal(/yes) :-
      not (set_a(X), not set_b(X)),  # A ⊆ B
      not (set_b(Y), not set_a(Y)).  # B ⊆ A
    
    are_equal(/no) :- set_a(X), not set_b(X).  # A has something B doesn't
    are_equal(/no) :- set_b(Y), not set_a(Y).  # B has something A doesn't
    ```
    
    ### Example
    ```mangle
    # Scenario 1: Equal
    set_a("a").
    set_a("b").
    set_a("c").
    
    set_b("c").
    set_b("a").
    set_b("b").
    
    # Result: are_equal(/yes)
    
    # Scenario 2: Not equal
    set_a("a").
    set_a("b").
    set_b("a").  # Missing "b"
    
    # Result: are_equal(/no)
    ```
    
    ## Variation 8: Multiple Set Union
    
    ### Problem
    Union of three or more sets.
    
    ### Solution
    ```mangle
    # Schema
    Decl set_a(Elem.Type<string>).
    Decl set_b(Elem.Type<string>).
    Decl set_c(Elem.Type<string>).
    Decl union_all(Elem.Type<string>).
    
    # Union of A, B, and C
    union_all(X) :- set_a(X).
    union_all(X) :- set_b(X).
    union_all(X) :- set_c(X).
    ```
    
    ### Example
    ```mangle
    set_a("a").
    set_b("b").
    set_c("c").
    set_a("d").
    
    # Results: union_all("a"), union_all("b"), union_all("c"), union_all("d")
    ```
    
    ## Variation 9: Conditional Set Operations
    
    ### Problem
    Perform set operations based on element properties.
    
    ### Solution
    ```mangle
    # Schema
    Decl set_a(Elem.Type<string>, Value.Type<int>).
    Decl set_b(Elem.Type<string>, Value.Type<int>).
    Decl conditional_union(Elem.Type<string>).
    
    # Union only elements where Value > 100
    conditional_union(Elem) :- set_a(Elem, Value), Value > 100.
    conditional_union(Elem) :- set_b(Elem, Value), Value > 100.
    ```
    
    ### Example
    ```mangle
    set_a("a", 150).
    set_a("b", 50).
    set_b("c", 200).
    set_b("d", 30).
    
    # Results: conditional_union("a"), conditional_union("c")
    # NOT "b" or "d" (values too low)
    ```
    
    ## Variation 10: Partitioning (Disjoint Union)
    
    ### Problem
    Partition elements into disjoint subsets.
    
    ### Solution
    ```mangle
    # Schema
    Decl item(Id.Type<string>, Value.Type<int>).
    Decl partition_low(Id.Type<string>).
    Decl partition_mid(Id.Type<string>).
    Decl partition_high(Id.Type<string>).
    
    # Partition by value ranges (disjoint)
    partition_low(Id) :- item(Id, Value), Value < 50.
    partition_mid(Id) :- item(Id, Value), Value >= 50, Value < 100.
    partition_high(Id) :- item(Id, Value), Value >= 100.
    ```
    
    ### Example
    ```mangle
    item("i1", 25).
    item("i2", 75).
    item("i3", 150).
    item("i4", 45).
    
    # Results:
    # partition_low("i1"), partition_low("i4")
    # partition_mid("i2")
    # partition_high("i3")
    ```
    
    ## Variation 11: Power Set (All Subsets)
    
    ### Problem
    Generate all subsets of a set (limited to small sets).
    
    ### Solution
    ```mangle
    # Note: Power set grows exponentially (2^n)
    # Only practical for very small sets in Mangle
    
    # Schema
    Decl element(Elem.Type<string>).
    Decl subset(Elem.Type<string>).
    
    # Every element is either in the subset or not
    # This creates all 2^n combinations
    
    # Include element
    subset(X) :- element(X).
    
    # Exclude element (represented by absence)
    # Not explicitly represented - handled by closed world assumption
    
    # For practical use, you'd enumerate specific subsets:
    Decl subset_empty.
    subset_empty :- not element(_).  # Empty set exists if no elements
    
    # Better: Define specific subsets based on properties
    Decl subset_by_property(Elem.Type<string>, Property.Type<atom>).
    subset_by_property(Elem, Prop) :- element(Elem), has_property(Elem, Prop).
    ```
    
    ### Note
    Power sets are impractical in Datalog. Use explicit enumeration or property-based subsets instead.
    
    ## Variation 12: Cardinality Comparison
    
    ### Problem
    Compare sizes of sets.
    
    ### Solution
    ```mangle
    # Schema
    Decl set_a(Elem.Type<string>).
    Decl set_b(Elem.Type<string>).
    Decl count_a(Count.Type<int>).
    Decl count_b(Count.Type<int>).
    Decl size_comparison(Result.Type<atom>).
    
    # Count elements
    count_a(Count) :- set_a(Elem) |> do fn:group_by(), let Count = fn:Count().
    count_b(Count) :- set_b(Elem) |> do fn:group_by(), let Count = fn:Count().
    
    # Compare
    size_comparison(/a_larger) :- count_a(A), count_b(B), A > B.
    size_comparison(/b_larger) :- count_a(A), count_b(B), B > A.
    size_comparison(/equal) :- count_a(A), count_b(A).
    ```
    
    ### Example
    ```mangle
    set_a("a").
    set_a("b").
    set_a("c").
    
    set_b("x").
    set_b("y").
    
    # Results:
    # count_a(3)
    # count_b(2)
    # size_comparison(/a_larger)
    ```
    
    ## Anti-Patterns
    
    ### WRONG: Assuming Sets Are Sorted
    ```mangle
    # Bad - order is not guaranteed
    first_element(X) :- set_a(X).  # Which X?
    
    # Fix - use explicit ordering
    first_element(X) :- set_a(X, Priority), ... |> do fn:group_by(), let MinP = fn:Min(Priority), ...
    ```
    
    ### WRONG: Modifying Sets (Mutable Operations)
    ```mangle
    # Mangle sets are immutable
    # Can't "remove" from a set - create new set instead
    
    # Bad (conceptually):
    # set_a.remove(X)
    
    # Good:
    new_set(Y) :- set_a(Y), Y != X.  # New set excluding X
    ```
    
    ### WRONG: Infinite Sets
    ```mangle
    # Bad - unbounded
    all_numbers(X) :- X = fn:plus(X, 1).
    
    # Sets must be finite and grounded
    ```
    
    ## Performance Tips
    
    1. **Materialize Intermediate Sets**: For complex operations
    2. **Filter Early**: Reduce set sizes before operations
    3. **Use Indices**: Index predicates representing sets
    4. **Avoid Cartesian Products**: In multi-set operations
    
    ## Common Use Cases in codeNERD
    
    ### File Set Operations
    ```mangle
    # Files modified in branch A
    Decl modified_in_a(File.Type<string>).
    
    # Files modified in branch B
    Decl modified_in_b(File.Type<string>).
    
    # Merge conflicts (both modified)
    Decl conflict_files(File.Type<string>).
    conflict_files(File) :- modified_in_a(File), modified_in_b(File).
    ```
    
    ### Test Coverage Sets
    ```mangle
    # All source files
    Decl source_file(File.Type<string>).
    
    # Files covered by tests
    Decl covered_file(File.Type<string>).
    
    # Uncovered files (difference)
    Decl uncovered_file(File.Type<string>).
    uncovered_file(File) :- source_file(File), not covered_file(File).
    ```
    
    ### Dependency Resolution
    ```mangle
    # Direct dependencies
    Decl direct_dep(Package.Type<string>).
    
    # Transitive dependencies
    Decl transitive_dep(Package.Type<string>).
    
    # All dependencies (union)
    Decl all_deps(Package.Type<string>).
    all_deps(Pkg) :- direct_dep(Pkg).
    all_deps(Pkg) :- transitive_dep(Pkg).
    ```
    
    ### Symbol Scope Sets
    ```mangle
    # Symbols defined in scope A
    Decl defined_in_a(Symbol.Type<string>).
    
    # Symbols used in scope B
    Decl used_in_b(Symbol.Type<string>).
    
    # Undefined symbols (used but not defined)
    Decl undefined_symbol(Symbol.Type<string>).
    undefined_symbol(Sym) :- used_in_b(Sym), not defined_in_a(Sym).
    ```
    
    ## Set Algebra Laws (For Verification)
    
    ```mangle
    # Commutative: A ∪ B = B ∪ A
    # union(X) :- set_a(X) ; set_b(X).
    # Same as: union(X) :- set_b(X) ; set_a(X).
    
    # Associative: (A ∪ B) ∪ C = A ∪ (B ∪ C)
    # union(X) :- set_a(X).
    # union(X) :- set_b(X).
    # union(X) :- set_c(X).
    
    # Distributive: A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C)
    # a_and_b_or_c(X) :- set_a(X), (set_b(X) ; set_c(X)).
    # Same as: a_and_b_or_c(X) :- set_a(X), set_b(X).
    #          a_and_b_or_c(X) :- set_a(X), set_c(X).
    
    # De Morgan's Laws: ¬(A ∪ B) = ¬A ∩ ¬B
    # not_a_or_b(X) :- domain(X), not set_a(X), not set_b(X).
    # Same as: not_a_or_b(X) :- domain(X), not (set_a(X) ; set_b(X)).
    ```
