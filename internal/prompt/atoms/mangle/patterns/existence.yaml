# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: patterns/existence.md

- id: "language/mangle/docs/patterns/existence"
  category: "language"
  subcategory: "mangle"
  description: "Existence Patterns"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Existence Patterns
    
    ## Problem Description
    
    Existence checks are fundamental for validation, filtering, and conditional logic. Common needs:
    - Check if something exists
    - Find first match
    - Verify all items have a property
    - Detect missing relationships
    - Test for uniqueness
    
    ## Core Pattern: Basic Existence Check
    
    ### Template
    ```mangle
    # Exists: at least one fact matches
    exists(Result) :- predicate(X, Y), Result = /yes.
    
    # Not exists
    not_exists(Result) :- not predicate(_, _), Result = /yes.
    
    # Or using a simpler form:
    has_items :- item(_).
    no_items :- not item(_).
    ```
    
    ### Complete Working Example
    ```mangle
    # Schema
    Decl user(UserId.Type<string>).
    Decl has_users(Result.Type<atom>).
    Decl has_no_users(Result.Type<atom>).
    
    # Facts
    user("u1").
    user("u2").
    
    # Existence check
    has_users(/yes) :- user(_).
    
    # Non-existence check
    has_no_users(/yes) :- not user(_).
    
    # Query: has_users(R)
    # Result: has_users(/yes)
    
    # Query: has_no_users(R)
    # Result: (empty - users exist)
    ```
    
    ## Variation 1: Conditional Existence (IF-THEN)
    
    ### Problem
    Check if something exists given a condition.
    
    ### Solution
    ```mangle
    # Schema
    Decl user(UserId.Type<string>, Status.Type<atom>).
    Decl has_active_users(Result.Type<atom>).
    
    # Check if at least one active user exists
    has_active_users(/yes) :- user(_, /active).
    has_active_users(/no) :- not user(_, /active).
    ```
    
    ### Example
    ```mangle
    user("u1", /active).
    user("u2", /inactive).
    
    # Result: has_active_users(/yes)
    
    # If all were inactive:
    # Result: has_active_users(/no)
    ```
    
    ## Variation 2: Find First Match
    
    ### Problem
    Get the first item that matches (by some ordering).
    
    ### Solution
    ```mangle
    # Schema
    Decl item(Id.Type<string>, Priority.Type<int>, Value.Type<string>).
    Decl highest_priority_item(Id.Type<string>, Value.Type<string>).
    
    # Find max priority
    Decl max_priority(MaxP.Type<int>).
    max_priority(MaxP) :-
      item(Id, Priority, Value)
      |> do fn:group_by(),
         let MaxP = fn:Max(Priority).
    
    # Get item(s) with max priority
    highest_priority_item(Id, Value) :-
      max_priority(MaxP),
      item(Id, MaxP, Value).
    ```
    
    ### Example
    ```mangle
    item("i1", 5, "low").
    item("i2", 10, "high").
    item("i3", 8, "medium").
    item("i4", 10, "also high").
    
    # Results:
    # max_priority(10)
    # highest_priority_item("i2", "high")
    # highest_priority_item("i4", "also high")  # Both have priority 10
    ```
    
    ## Variation 3: All Items Have Property
    
    ### Problem
    Verify that every item has a certain property (universal quantification).
    
    ### Solution
    ```mangle
    # Schema
    Decl item(Id.Type<string>).
    Decl has_property(Id.Type<string>).
    Decl all_items_have_property(Result.Type<atom>).
    
    # "All have property" = "There does NOT exist an item WITHOUT the property"
    all_items_have_property(/yes) :- not (item(Id), not has_property(Id)).
    
    # Simpler: Check for counterexample
    Decl item_without_property(Id.Type<string>).
    item_without_property(Id) :- item(Id), not has_property(Id).
    
    all_items_have_property(/no) :- item_without_property(_).
    all_items_have_property(/yes) :- not item_without_property(_).
    ```
    
    ### Example
    ```mangle
    item("i1").
    item("i2").
    item("i3").
    
    has_property("i1").
    has_property("i2").
    has_property("i3").
    
    # Results:
    # item_without_property - EMPTY
    # all_items_have_property(/yes)
    
    # If i3 didn't have property:
    # item_without_property("i3")
    # all_items_have_property(/no)
    ```
    
    ## Variation 4: At Least N Items Exist
    
    ### Problem
    Check if there are at least N matching items.
    
    ### Solution
    ```mangle
    # Schema
    Decl item(Id.Type<string>).
    Decl item_count(Count.Type<int>).
    Decl has_enough_items(Result.Type<atom>).
    
    # Count items
    item_count(Count) :-
      item(Id)
      |> do fn:group_by(),
         let Count = fn:Count().
    
    # Check threshold
    has_enough_items(/yes) :- item_count(Count), Count >= 5.
    has_enough_items(/no) :- item_count(Count), Count < 5.
    ```
    
    ### Example
    ```mangle
    item("i1").
    item("i2").
    item("i3").
    
    # Results:
    # item_count(3)
    # has_enough_items(/no)
    
    # With 5+ items:
    # has_enough_items(/yes)
    ```
    
    ## Variation 5: Unique Existence (Exactly One)
    
    ### Problem
    Verify that exactly one item matches.
    
    ### Solution
    ```mangle
    # Schema
    Decl candidate(Id.Type<string>).
    Decl candidate_count(Count.Type<int>).
    Decl exactly_one(Result.Type<atom>).
    
    # Count candidates
    candidate_count(Count) :-
      candidate(Id)
      |> do fn:group_by(),
         let Count = fn:Count().
    
    # Check for exactly one
    exactly_one(/yes) :- candidate_count(1).
    exactly_one(/no) :- candidate_count(Count), Count != 1.
    ```
    
    ### Example
    ```mangle
    # Scenario 1: Exactly one
    candidate("c1").
    # Result: exactly_one(/yes)
    
    # Scenario 2: Multiple
    candidate("c2").
    candidate("c3").
    # Result: exactly_one(/no)
    
    # Scenario 3: None
    # (no candidates)
    # Result: exactly_one(/no)
    ```
    
    ## Variation 6: Missing Relationship Detection
    
    ### Problem
    Find items that lack a required relationship.
    
    ### Solution
    ```mangle
    # Schema
    Decl entity(Id.Type<string>).
    Decl related_to(Id.Type<string>, TargetId.Type<string>).
    Decl orphaned(Id.Type<string>).
    
    # Entities without any relationships
    orphaned(Id) :- entity(Id), not related_to(Id, _).
    ```
    
    ### Example
    ```mangle
    entity("e1").
    entity("e2").
    entity("e3").
    
    related_to("e1", "target1").
    related_to("e2", "target2").
    # e3 has no relationships
    
    # Result: orphaned("e3")
    ```
    
    ## Variation 7: Exists in Both Sets (Intersection Test)
    
    ### Problem
    Check if an item exists in both set A and set B.
    
    ### Solution
    ```mangle
    # Schema
    Decl set_a(Elem.Type<string>).
    Decl set_b(Elem.Type<string>).
    Decl in_both(Elem.Type<string>).
    Decl intersection_exists(Result.Type<atom>).
    
    # Elements in both sets
    in_both(Elem) :- set_a(Elem), set_b(Elem).
    
    # Check if intersection is non-empty
    intersection_exists(/yes) :- in_both(_).
    intersection_exists(/no) :- not in_both(_).
    ```
    
    ### Example
    ```mangle
    set_a("a").
    set_a("b").
    set_a("c").
    
    set_b("b").
    set_b("d").
    
    # Results:
    # in_both("b")
    # intersection_exists(/yes)
    ```
    
    ## Variation 8: Any vs. All (Existential vs. Universal)
    
    ### Problem
    Distinguish between "any item matches" and "all items match".
    
    ### Solution
    ```mangle
    # Schema
    Decl item(Id.Type<string>, Value.Type<int>).
    Decl any_item_large(Result.Type<atom>).
    Decl all_items_large(Result.Type<atom>).
    
    # Any item > 100
    any_item_large(/yes) :- item(Id, Value), Value > 100.
    any_item_large(/no) :- not (item(Id, Value), Value > 100).
    
    # All items > 100 (no item <= 100)
    all_items_large(/yes) :- not (item(Id, Value), Value <= 100).
    all_items_large(/no) :- item(Id, Value), Value <= 100.
    ```
    
    ### Example
    ```mangle
    item("i1", 150).
    item("i2", 200).
    item("i3", 50).
    
    # Results:
    # any_item_large(/yes)   # i1 and i2 are > 100
    # all_items_large(/no)   # i3 is <= 100
    ```
    
    ## Variation 9: Existence with Path (Reachability)
    
    ### Problem
    Check if there exists a path between two nodes.
    
    ### Solution
    ```mangle
    # Schema
    Decl edge(From.Type<string>, To.Type<string>).
    Decl reachable(From.Type<string>, To.Type<string>).
    Decl path_exists(From.Type<string>, To.Type<string>, Result.Type<atom>).
    
    # Reachability
    reachable(X, Y) :- edge(X, Y).
    reachable(X, Z) :- reachable(X, Y), edge(Y, Z).
    
    # Check specific path
    path_exists(From, To, /yes) :- reachable(From, To).
    path_exists(From, To, /no) :- not reachable(From, To).
    ```
    
    ### Example
    ```mangle
    edge("a", "b").
    edge("b", "c").
    edge("x", "y").
    
    # Results:
    # reachable("a", "b")
    # reachable("a", "c")
    # reachable("x", "y")
    # path_exists("a", "c", /yes)
    # path_exists("a", "x", /no)  # No path from a to x
    ```
    
    ## Variation 10: Find First Non-Null
    
    ### Problem
    Get the first non-missing value for each entity.
    
    ### Solution
    ```mangle
    # Schema
    Decl entity(Id.Type<string>).
    Decl attribute(Id.Type<string>, Source.Type<string>, Value.Type<string>, Priority.Type<int>).
    Decl best_value(Id.Type<string>, Value.Type<string>).
    
    # For each entity, find highest priority source
    Decl max_priority_per_entity(Id.Type<string>, MaxP.Type<int>).
    max_priority_per_entity(Id, MaxP) :-
      attribute(Id, Source, Value, Priority)
      |> do fn:group_by(Id),
         let MaxP = fn:Max(Priority).
    
    # Get value from highest priority source
    best_value(Id, Value) :-
      max_priority_per_entity(Id, MaxP),
      attribute(Id, Source, Value, MaxP).
    ```
    
    ### Example
    ```mangle
    entity("e1").
    
    attribute("e1", "source1", "value1", 1).
    attribute("e1", "source2", "value2", 3).  # Highest priority
    attribute("e1", "source3", "value3", 2).
    
    # Results:
    # max_priority_per_entity("e1", 3)
    # best_value("e1", "value2")  # From source2
    ```
    
    ## Variation 11: Exists with Join
    
    ### Problem
    Check if a complex condition involving multiple predicates is satisfied.
    
    ### Solution
    ```mangle
    # Schema
    Decl user(UserId.Type<string>).
    Decl purchase(PurchaseId.Type<string>, UserId.Type<string>, Amount.Type<int>).
    Decl has_high_value_customer(Result.Type<atom>).
    
    # Check if there exists a user with purchase > 10000
    has_high_value_customer(/yes) :-
      user(UserId),
      purchase(PurchaseId, UserId, Amount),
      Amount > 10000.
    
    has_high_value_customer(/no) :-
      not (user(UserId), purchase(PurchaseId, UserId, Amount), Amount > 10000).
    ```
    
    ### Example
    ```mangle
    user("u1").
    user("u2").
    
    purchase("p1", "u1", 5000).
    purchase("p2", "u1", 6000).
    purchase("p3", "u2", 15000).  # High value!
    
    # Result: has_high_value_customer(/yes)
    ```
    
    ## Anti-Patterns
    
    ### WRONG: Checking Existence on Unbound Variable
    ```mangle
    # Bad - X is never bound
    exists(X) :- not predicate(X).
    
    # This doesn't make sense - you're asking for all X that don't exist
    # But X is infinite!
    
    # Fix - provide domain
    exists(X) :- domain(X), not predicate(X).
    ```
    
    ### WRONG: Confusing "Any" with "All"
    ```mangle
    # Intended: "All items are valid"
    # Wrong implementation:
    all_valid :- item(X), valid(X).
    
    # This actually means "There exists a valid item"
    # Not "All items are valid"
    
    # Fix:
    all_valid :- not (item(X), not valid(X)).
    ```
    
    ### WRONG: Double Negation Without Understanding
    ```mangle
    # Confusing:
    result :- not (not predicate(X)).
    
    # This is just predicate(X) with extra steps
    # Use positive logic:
    result :- predicate(X).
    ```
    
    ## Performance Tips
    
    1. **Short-Circuit Existence**: Stop searching after first match
    2. **Use Indices**: Index predicates used in existence checks
    3. **Positive over Negative**: `exists(X)` is faster than `not (not exists(X))`
    4. **Materialize Counts**: If checking multiple thresholds, compute count once
    
    ## Common Use Cases in codeNERD
    
    ### Check if File Has Tests
    ```mangle
    Decl source_file(File.Type<string>).
    Decl test_covers(TestFile.Type<string>, SourceFile.Type<string>).
    Decl has_tests(File.Type<string>, Result.Type<atom>).
    
    has_tests(File, /yes) :- source_file(File), test_covers(_, File).
    has_tests(File, /no) :- source_file(File), not test_covers(_, File).
    ```
    
    ### Verify All Functions Are Documented
    ```mangle
    Decl function(FuncId.Type<string>).
    Decl has_doc(FuncId.Type<string>).
    Decl all_documented(Result.Type<atom>).
    
    Decl undocumented(FuncId.Type<string>).
    undocumented(FuncId) :- function(FuncId), not has_doc(FuncId).
    
    all_documented(/yes) :- not undocumented(_).
    all_documented(/no) :- undocumented(_).
    ```
    
    ### Check if Shard Has Completed Any Tasks
    ```mangle
    Decl shard(ShardId.Type<string>).
    Decl shard_executed(ShardId.Type<string>, TaskId.Type<string>, Status.Type<atom>).
    Decl has_completed_tasks(ShardId.Type<string>, Result.Type<atom>).
    
    has_completed_tasks(ShardId, /yes) :-
      shard(ShardId),
      shard_executed(ShardId, _, /success).
    
    has_completed_tasks(ShardId, /no) :-
      shard(ShardId),
      not shard_executed(ShardId, _, /success).
    ```
