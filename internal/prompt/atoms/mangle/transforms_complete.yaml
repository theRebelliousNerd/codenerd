# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: transforms_complete.md

- id: "language/mangle/docs/transforms_complete"
  category: "language"
  subcategory: "mangle"
  description: "Mangle Transform Pipelines - Complete Guide"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle Transform Pipelines - Complete Guide
    
    ## Transform Pipeline Architecture
    
    ### Basic Pipeline Structure
    ```mangle
    result(GroupVars, AggResults) :-
        source_atoms |>
        do fn:operation1() |>
        do fn:operation2() |>
        let AggVar1 = fn:aggregate1(),
        let AggVar2 = fn:aggregate2().
    ```
    
    ### Pipeline Keywords
    
    | Keyword | Purpose | Position | Example |
    |---------|---------|----------|---------|
    | `\|>` | Pipeline operator | Infix | `source() \|>` |
    | `do` | Apply transform | Before function | `do fn:group_by(K)` |
    | `let` | Bind aggregation result | Before assignment | `let N = fn:Count()` |
    | `fn:` | Function namespace | Prefix | `fn:Sum`, `fn:Count` |
    
    ## Single-Stage Aggregation
    
    ### Count
    ```mangle
    items_per_category(Cat, N) :-
        item(Cat, _) |>
        do fn:group_by(Cat),
        let N = fn:Count().
    ```
    
    ### Sum
    ```mangle
    total_by_category(Cat, Total) :-
        item(Cat, Value) |>
        do fn:group_by(Cat),
        let Total = fn:Sum(Value).
    ```
    
    ### Min/Max
    ```mangle
    value_range(Cat, Min, Max) :-
        item(Cat, Value) |>
        do fn:group_by(Cat),
        let Min = fn:Min(Value),
        let Max = fn:Max(Value).
    ```
    
    ### Average (Derived)
    ```mangle
    average_per_category(Cat, Avg) :-
        item(Cat, Value) |>
        do fn:group_by(Cat),
        let Total = fn:Sum(Value),
        let Count = fn:Count(),
        let Avg = fn:divide(Total, Count).
    ```
    
    ## Multi-Stage Pipelines
    
    ### Filter then Aggregate
    ```mangle
    high_value_count(Cat, N) :-
        item(Cat, Value) |>
        do fn:filter(fn:gt(Value, 1000)) |>
        do fn:group_by(Cat),
        let N = fn:Count().
    ```
    
    ### Transform then Aggregate
    ```mangle
    normalized_total(Cat, Total) :-
        item(Cat, RawValue) |>
        do fn:transform(fn:multiply(RawValue, 1.1)) |>
        do fn:group_by(Cat),
        let Total = fn:Sum(NormalizedValue).
    ```
    
    ### Multiple Filters
    ```mangle
    filtered_count(Cat, N) :-
        item(Cat, Value, Status) |>
        do fn:filter(fn:gt(Value, 100)) |>
        do fn:filter(fn:eq(Status, /active)) |>
        do fn:group_by(Cat),
        let N = fn:Count().
    ```
    
    ### Complex Multi-Stage
    ```mangle
    complex_stats(Region, Product, Count, Revenue, Avg) :-
        sale(Region, Product, Amount) |>
        do fn:filter(fn:gt(Amount, 0)) |>
        do fn:group_by(Region, Product) |>
        let Count = fn:Count(),
        let Revenue = fn:Sum(Amount) |>
        let Avg = fn:divide(Revenue, Count).
    ```
    
    ## Grouping Patterns
    
    ### Single Variable Grouping
    ```mangle
    count_by_lang(Lang, N) :-
        file(_, Lang) |>
        do fn:group_by(Lang),
        let N = fn:Count().
    ```
    
    ### Multi-Variable Grouping
    ```mangle
    sales_summary(Region, Product, Count, Revenue) :-
        sale(Region, Product, Amount) |>
        do fn:group_by(Region, Product),
        let Count = fn:Count(),
        let Revenue = fn:Sum(Amount).
    ```
    
    ### Grouping with No Variables (Global Aggregation)
    ```mangle
    overall_total(GrandTotal) :-
        item(_, Value) |>
        do fn:group_by(),  # No grouping variables = single group
        let GrandTotal = fn:Sum(Value).
    ```
    
    ## Nested Aggregation
    
    ### Two-Level Aggregation
    ```mangle
    # Step 1: Category subtotals
    category_total(Cat, Total) :-
        item(Cat, Value) |>
        do fn:group_by(Cat),
        let Total = fn:Sum(Value).
    
    # Step 2: Grand total from subtotals
    grand_total(GrandTotal) :-
        category_total(_, Total) |>
        do fn:group_by(),
        let GrandTotal = fn:Sum(Total).
    ```
    
    ### Average of Averages
    ```mangle
    # Step 1: Regional averages
    regional_avg(Region, Avg) :-
        sale(Region, Amount) |>
        do fn:group_by(Region),
        let Total = fn:Sum(Amount),
        let Count = fn:Count(),
        let Avg = fn:divide(Total, Count).
    
    # Step 2: Overall average of regional averages
    overall_avg(OverallAvg) :-
        regional_avg(_, Avg) |>
        do fn:group_by(),
        let AvgTotal = fn:Sum(Avg),
        let RegionCount = fn:Count(),
        let OverallAvg = fn:divide(AvgTotal, RegionCount).
    ```
    
    ## Conditional Aggregation
    
    ### Filter Before Aggregation
    ```mangle
    # Only count items > 1000
    high_value_count(Cat, N) :-
        item(Cat, Value) |>
        do fn:filter(fn:gt(Value, 1000)),
        do fn:group_by(Cat),
        let N = fn:Count().
    ```
    
    ### Multiple Conditional Aggregations
    ```mangle
    # Separate high and low counts
    category_breakdown(Cat, HighCount, LowCount) :-
        high_value_count(Cat, HighCount),
        low_value_count(Cat, LowCount).
    
    high_value_count(Cat, N) :-
        item(Cat, V) |>
        do fn:filter(fn:gt(V, 1000)),
        do fn:group_by(Cat),
        let N = fn:Count().
    
    low_value_count(Cat, N) :-
        item(Cat, V) |>
        do fn:filter(fn:le(V, 1000)),
        do fn:group_by(Cat),
        let N = fn:Count().
    ```
    
    ### HAVING Clause Equivalent
    ```mangle
    # Categories with > 10 items
    large_categories(Cat, N) :-
        count_per_category(Cat, N),
        N > 10.
    
    count_per_category(Cat, N) :-
        item(Cat, _) |>
        do fn:group_by(Cat),
        let N = fn:Count().
    ```
    
    ## Window Functions (Simulated)
    
    ### Running Total
    ```mangle
    # Assumes ordered data (e.g., by timestamp)
    running_total(Item, Timestamp, RunningSum) :-
        item(Item, Timestamp, Value),
        item(PrevItem, PrevTimestamp, PrevValue),
        PrevTimestamp <= Timestamp |>
        do fn:group_by(Item, Timestamp),
        let RunningSum = fn:Sum(PrevValue).
    ```
    
    ### Rank (Simulated)
    ```mangle
    # Count items with higher value
    rank(Item, Value, Rank) :-
        item(Item, Value),
        item(_, OtherValue),
        OtherValue > Value |>
        do fn:group_by(Item, Value),
        let BetterCount = fn:Count(),
        let Rank = fn:plus(BetterCount, 1).
    ```
    
    ### Row Number (Simulated)
    ```mangle
    # Assign sequential numbers within group
    row_number(Group, Item, RowNum) :-
        item(Group, Item, Timestamp),
        item(Group, OtherItem, OtherTimestamp),
        OtherTimestamp < Timestamp |>
        do fn:group_by(Group, Item),
        let PriorCount = fn:Count(),
        let RowNum = fn:plus(PriorCount, 1).
    ```
    
    ## Advanced Transform Patterns
    
    ### Percentage Calculation
    ```mangle
    # Step 1: Category totals
    category_total(Cat, Total) :-
        item(Cat, Value) |>
        do fn:group_by(Cat),
        let Total = fn:Sum(Value).
    
    # Step 2: Grand total
    grand_total(GT) :-
        item(_, Value) |>
        do fn:group_by(),
        let GT = fn:Sum(Value).
    
    # Step 3: Percentage
    category_percentage(Cat, Pct) :-
        category_total(Cat, CatTotal),
        grand_total(GT) |>
        let Pct = fn:divide(fn:multiply(CatTotal, 100), GT).
    ```
    
    ### Cumulative Distribution
    ```mangle
    # Count items at or below value
    cumulative_count(Value, Count) :-
        item(ItemValue),
        item(OtherValue),
        OtherValue <= Value |>
        do fn:group_by(Value),
        let Count = fn:Count().
    ```
    
    ### Moving Average (Fixed Window)
    ```mangle
    # 3-item moving average
    moving_avg(Item, Avg) :-
        item(Item, Timestamp, Value),
        item(OtherItem, OtherTimestamp, OtherValue),
        OtherTimestamp >= fn:minus(Timestamp, 3),
        OtherTimestamp <= Timestamp |>
        do fn:group_by(Item, Timestamp),
        let Total = fn:Sum(OtherValue),
        let Count = fn:Count(),
        let Avg = fn:divide(Total, Count).
    ```
    
    ## Aggregation with Arithmetic
    
    ### Weighted Average
    ```mangle
    weighted_avg(Category, WeightedAvg) :-
        item(Category, Value, Weight) |>
        do fn:group_by(Category),
        let WeightedSum = fn:Sum(fn:multiply(Value, Weight)),
        let TotalWeight = fn:Sum(Weight),
        let WeightedAvg = fn:divide(WeightedSum, TotalWeight).
    ```
    
    ### Variance Calculation
    ```mangle
    # Step 1: Mean
    mean(Cat, Mean) :-
        item(Cat, Value) |>
        do fn:group_by(Cat),
        let Total = fn:Sum(Value),
        let Count = fn:Count(),
        let Mean = fn:divide(Total, Count).
    
    # Step 2: Squared deviations
    sq_dev(Cat, Item, SqDev) :-
        item(Cat, Item, Value),
        mean(Cat, Mean),
        Diff = fn:minus(Value, Mean) |>
        let SqDev = fn:multiply(Diff, Diff).
    
    # Step 3: Variance
    variance(Cat, Var) :-
        sq_dev(Cat, _, SqDev) |>
        do fn:group_by(Cat),
        let SumSqDev = fn:Sum(SqDev),
        let Count = fn:Count(),
        let Var = fn:divide(SumSqDev, Count).
    ```
    
    ## Common Pipeline Errors
    
    ### Missing `do` Keyword
    ```mangle
    # ❌ WRONG
    result(K, N) :-
        source(K, _) |>
        fn:group_by(K),  # Missing 'do'!
        let N = fn:Count().
    
    # ✅ CORRECT
    result(K, N) :-
        source(K, _) |>
        do fn:group_by(K),
        let N = fn:Count().
    ```
    
    ### Wrong Function Casing
    ```mangle
    # ❌ WRONG - lowercase
    ... let N = fn:count().
    ... let S = fn:sum(X).
    
    # ✅ CORRECT - capital letters
    ... let N = fn:Count().
    ... let S = fn:Sum(X).
    ```
    
    ### Missing Pipeline Operator
    ```mangle
    # ❌ WRONG
    result(K, N) :-
        source(K, _)
        do fn:group_by(K),
        let N = fn:Count().
    
    # ✅ CORRECT
    result(K, N) :-
        source(K, _) |>
        do fn:group_by(K),
        let N = fn:Count().
    ```
    
    ### Aggregation Without Grouping
    ```mangle
    # ❌ WRONG - implicit grouping doesn't work
    total(K, Sum) :- item(K, V), Sum = sum(V).
    
    # ✅ CORRECT - explicit pipeline
    total(K, Sum) :-
        item(K, V) |>
        do fn:group_by(K),
        let Sum = fn:Sum(V).
    ```
    
    ### Unbound Grouping Variable
    ```mangle
    # ❌ WRONG - Cat not in body
    bad(Cat, N) :-
        item(_, _) |>
        do fn:group_by(Cat),  # Cat unbound!
        let N = fn:Count().
    
    # ✅ CORRECT - Cat appears in body
    good(Cat, N) :-
        item(Cat, _) |>
        do fn:group_by(Cat),
        let N = fn:Count().
    ```
    
    ## Performance Optimization
    
    ### Filter Early
    ```mangle
    # ✅ GOOD - filter before aggregation
    efficient(Cat, N) :-
        item(Cat, Value) |>
        do fn:filter(fn:gt(Value, 1000)) |>  # Filter first
        do fn:group_by(Cat),
        let N = fn:Count().
    
    # ❌ BAD - aggregate then filter
    inefficient(Cat, N) :-
        count_all(Cat, Total),
        high_value_count(Cat, N),
        # Did extra work counting all items
    ```
    
    ### Minimize Aggregation Stages
    ```mangle
    # ✅ GOOD - single aggregation
    efficient(Cat, Total, Count, Avg) :-
        item(Cat, Value) |>
        do fn:group_by(Cat),
        let Total = fn:Sum(Value),
        let Count = fn:Count(),
        let Avg = fn:divide(Total, Count).
    
    # ❌ BAD - three separate aggregations
    inefficient(Cat, Avg) :-
        total(Cat, Total),
        count(Cat, Count),
        Avg = fn:divide(Total, Count).
    
    total(Cat, T) :- item(Cat, V) |> do fn:group_by(Cat), let T = fn:Sum(V).
    count(Cat, N) :- item(Cat, _) |> do fn:group_by(Cat), let N = fn:Count().
    ```
