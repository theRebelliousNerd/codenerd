# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: builtins_complete.md

- id: "language/mangle/docs/builtins_complete"
  category: "language"
  subcategory: "mangle"
  description: "Mangle Built-in Functions - Complete Reference"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle Built-in Functions - Complete Reference
    
    ## Aggregation Functions
    
    ### Count
    ```mangle
    fn:Count()  # Count elements in group
    ```
    **Usage**:
    ```mangle
    items_per_category(Cat, N) :-
        item(Cat, _) |>
        do fn:group_by(Cat),
        let N = fn:Count().
    ```
    
    ### Sum
    ```mangle
    fn:Sum(Variable)  # Sum numeric values
    ```
    **Usage**:
    ```mangle
    category_total(Cat, Total) :-
        item(Cat, Value) |>
        do fn:group_by(Cat),
        let Total = fn:Sum(Value).
    ```
    
    ### Min / Max
    ```mangle
    fn:Min(Variable)  # Minimum value
    fn:Max(Variable)  # Maximum value
    ```
    **Usage**:
    ```mangle
    value_range(Cat, Min, Max) :-
        item(Cat, Value) |>
        do fn:group_by(Cat),
        let Min = fn:Min(Value),
        let Max = fn:Max(Value).
    ```
    
    ### Grouping
    ```mangle
    fn:group_by(Var1, Var2, ...)  # Partition facts by variables
    ```
    **Single variable**:
    ```mangle
    count_per_category(Cat, N) :-
        item(Cat, _) |>
        do fn:group_by(Cat),
        let N = fn:Count().
    ```
    
    **Multiple variables**:
    ```mangle
    stats(Region, Product, Count) :-
        sale(Region, Product, Amount) |>
        do fn:group_by(Region, Product),
        let Count = fn:Count().
    ```
    
    ## Arithmetic Functions
    
    ### Basic Operations
    ```mangle
    fn:plus(A, B)      # A + B
    fn:minus(A, B)     # A - B
    fn:multiply(A, B)  # A × B
    fn:divide(A, B)    # A / B (float division)
    fn:modulo(A, B)    # A % B (remainder)
    fn:negate(A)       # -A (unary minus)
    fn:abs(A)          # |A| (absolute value)
    ```
    
    **Example - Calculate Average**:
    ```mangle
    average(Cat, Avg) :-
        item(Cat, Value) |>
        do fn:group_by(Cat),
        let Total = fn:Sum(Value),
        let Count = fn:Count(),
        let Avg = fn:divide(Total, Count).
    ```
    
    ## Comparison Functions
    
    ```mangle
    fn:eq(A, B)   # A = B (equality)
    fn:ne(A, B)   # A ≠ B (inequality)
    fn:lt(A, B)   # A < B (less than)
    fn:le(A, B)   # A ≤ B (less or equal)
    fn:gt(A, B)   # A > B (greater than)
    fn:ge(A, B)   # A ≥ B (greater or equal)
    ```
    
    **Usage in Filter Transforms**:
    ```mangle
    high_values(Cat, N) :-
        item(Cat, Value) |>
        do fn:filter(fn:gt(Value, 1000)),
        do fn:group_by(Cat),
        let N = fn:Count().
    ```
    
    ## List Functions
    
    ### Construction and Destructuring
    ```mangle
    fn:list_cons(Head, Tail)        # [Head|Tail] (cons cell)
    fn:list_append(List1, List2)    # List1 ++ List2 (concatenation)
    fn:list_length(List)             # Length of list
    fn:list:get(List, Index)         # Get element at index (0-based)
    ```
    
    **List Pattern Matching**:
    ```mangle
    # Cons pattern (destructure)
    :match_cons(List, Head, Tail)
    
    # Example
    first_element(List, Head) :-
        :match_cons(List, Head, _).
    
    # List membership
    :list:member(Elem, List)
    ```
    
    **Usage Examples**:
    ```mangle
    # Get first element
    path(Start, End, [Start, End]) :- edge(Start, End).
    
    # Build path recursively
    path(Start, End, [Start|Rest]) :-
        edge(Start, Mid),
        path(Mid, End, Rest).
    ```
    
    ## String Functions
    
    ```mangle
    fn:string_concat(S1, S2)         # S1 + S2 (concatenation)
    fn:string_length(S)              # Length of string
    fn:string_contains(S, Substring) # Contains check
    ```
    
    **IMPORTANT**: Mangle has LIMITED string manipulation. No `fn:substring`, `fn:regex`, `fn:split`.
    
    ## Struct/Map Functions
    
    ### Field Access
    ```mangle
    :match_field(Struct, /field_name, Value)  # Extract struct field
    :match_entry(Map, /key, Value)            # Extract map entry (same as match_field)
    ```
    
    **Usage**:
    ```mangle
    # Extract single field
    volunteer_name(ID, Name) :-
        volunteer_record(R),
        :match_field(R, /id, ID),
        :match_field(R, /name, Name).
    
    # Extract multiple fields
    person_info(ID, Name, Age, City) :-
        person_record(R),
        :match_field(R, /id, ID),
        :match_field(R, /name, Name),
        :match_field(R, /age, Age),
        :match_field(R, /city, City).
    ```
    
    ### Map Operations
    ```mangle
    fn:map_get(Map, /key, Default)  # Get with default value
    ```
    
    ## Pair and Tuple Functions
    
    ```mangle
    fn:pair(First, Second)          # Create pair
    fn:tuple(Elem1, Elem2, ...)     # Create tuple
    ```
    
    **Usage**:
    ```mangle
    # Create pair
    coordinate(/loc1, fn:pair(10, 20)).
    
    # Create tuple
    rgb_color(/red, fn:tuple(255, 0, 0)).
    ```
    
    ## Transform Pipeline Keywords
    
    ```mangle
    |>   # Pipeline operator
    do   # Apply transform function
    let  # Bind aggregation result
    ```
    
    **Complete Pipeline Example**:
    ```mangle
    result(Vars, Final) :-
        source(X) |>
        do fn:filter(fn:gt(X, 10)) |>
        do fn:transform(X) |>
        do fn:group_by(Category) |>
        let Count = fn:Count() |>
        let Total = fn:Sum(Value) |>
        let Final = fn:divide(Total, Count).
    ```
    
    ## Function Casing Rules
    
    **CRITICAL**: Aggregation functions use specific casing:
    - `fn:Count()` - Capital C
    - `fn:Sum(X)` - Capital S
    - `fn:Min(X)`, `fn:Max(X)` - Capital M
    - `fn:group_by(X)` - lowercase
    - `fn:plus(A, B)` - lowercase (all arithmetic)
    - `fn:list_cons(H, T)` - lowercase (all list operations)
    
    ## Functions That DON'T Exist
    
    **IMPORTANT**: These are common hallucinations. They DO NOT exist in Mangle:
    
    ```mangle
    # ❌ NO substring operations
    fn:substring(S, Start, End)
    fn:substr(S, N)
    
    # ❌ NO regex
    fn:regex(Pattern, String)
    fn:match(Pattern, String)
    
    # ❌ NO date/time functions
    fn:now()
    fn:date(Y, M, D)
    fn:timestamp()
    
    # ❌ NO array indexing (use fn:list:get instead)
    List[Index]
    
    # ❌ NO SQL-style aggregation
    sum(X), count(*), avg(X)
    
    # ❌ NO implicit GROUP BY
    Total = sum(Amount)  # WRONG
    
    # ❌ NO findall/bagof (Prolog)
    findall(X, pred(X), Bag)
    ```
    
    ## Virtual Predicates (Go Integration)
    
    These are predicates implemented in Go (not built-in Mangle):
    ```mangle
    # Example virtual predicates (codeNERD-specific)
    :recall_similar(Query, Results)
    :file_content(Path, Content)
    :symbol_at(Path, Line, Symbol)
    ```
    
    Virtual predicates are registered via Go's VirtualStore and behave like normal predicates in Mangle queries.
    
    ## Usage Patterns
    
    ### Conditional Aggregation
    ```mangle
    high_value_count(Cat, N) :-
        item(Cat, Value) |>
        do fn:filter(fn:gt(Value, 1000)),
        do fn:group_by(Cat),
        let N = fn:Count().
    ```
    
    ### Multi-Stage Aggregation
    ```mangle
    # Step 1: Category totals
    category_total(Cat, Total) :-
        item(Cat, Value) |>
        do fn:group_by(Cat),
        let Total = fn:Sum(Value).
    
    # Step 2: Overall stats
    overall_stats(GrandTotal, AvgCategoryTotal) :-
        category_total(_, Total) |>
        do fn:group_by(),
        let GrandTotal = fn:Sum(Total),
        let Count = fn:Count(),
        let AvgCategoryTotal = fn:divide(GrandTotal, Count).
    ```
    
    ### Running Total (Window Function Simulation)
    ```mangle
    running_total(Item, RunningSum) :-
        item(Item, Value),
        item(PrevItem, PrevValue),
        PrevItem < Item |>  # Ordering assumption
        do fn:group_by(Item),
        let RunningSum = fn:Sum(PrevValue).
    ```
