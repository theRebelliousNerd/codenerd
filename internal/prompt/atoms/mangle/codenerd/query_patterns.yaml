# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: codenerd/query_patterns.md

- id: "language/mangle/docs/codenerd/query_patterns"
  category: "language"
  subcategory: "mangle"
  description: "Mangle Query Patterns for codeNERD"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle Query Patterns for codeNERD
    
    Comprehensive guide to querying the Mangle knowledge graph. Shows common query patterns with both Mangle syntax and Go integration.
    
    ## Query Fundamentals
    
    ### Basic Query Syntax
    
    ```mangle
    # Query format: predicate(Arg1, Arg2, ...)
    # Variables: UPPERCASE
    # Constants: /lowercase or "string"
    # Anonymous: _
    
    ? file_topology(Path, _, /go, _, _).
    ```
    
    ### Go Query API
    
    ```go
    result, err := engine.Query(ctx, "file_topology(Path, _, /go, _, _)")
    if err != nil {
        return err
    }
    
    for _, binding := range result.Bindings {
        path := binding["Path"].(string)
        fmt.Println("Go file:", path)
    }
    ```
    
    ---
    
    ## Intent & Focus Queries
    
    ### Find User Intent
    
    ```mangle
    # Get current user intent
    ? user_intent(ID, Category, Verb, Target, Constraint).
    
    # Find mutation intents
    ? user_intent(ID, /mutation, Verb, Target, _).
    
    # Find specific verb
    ? user_intent(ID, _, /fix, Target, _).
    ```
    
    ```go
    // Get all fix requests
    result, _ := engine.Query(ctx, "user_intent(ID, _, /fix, Target, _)")
    for _, b := range result.Bindings {
        id := b["ID"].(string)
        target := b["Target"].(string)
        fmt.Printf("Fix request %s for %s\n", id, target)
    }
    ```
    
    ### Check for Clarification Needed
    
    ```mangle
    # Is clarification needed?
    ? clarification_needed(Ref).
    
    # Low-confidence focus resolution
    ? focus_resolution(Ref, _, _, Score), Score < 85.
    ```
    
    ```go
    // Check if clarification needed
    result, _ := engine.Query(ctx, "clarification_needed(Ref)")
    if len(result.Bindings) > 0 {
        fmt.Println("Clarification required")
    }
    ```
    
    ---
    
    ## File System Queries
    
    ### Find Files by Language
    
    ```mangle
    # All Go files
    ? file_topology(Path, _, /go, _, _).
    
    # All test files
    ? file_topology(Path, _, _, _, /true).
    
    # Go test files
    ? file_topology(Path, _, /go, _, /true).
    ```
    
    ```go
    // Get all Go test files
    result, _ := engine.Query(ctx, "file_topology(Path, _, /go, _, /true)")
    for _, b := range result.Bindings {
        fmt.Println("Test file:", b["Path"])
    }
    ```
    
    ### Find Recently Modified Files
    
    ```mangle
    # Files modified in last 5 minutes
    ? file_topology(Path, _, _, LastMod, _),
      current_time(Now),
      Now - LastMod < 300.
    ```
    
    ```go
    // Add current_time fact first
    now := time.Now().Unix()
    engine.AddFact("current_time", now)
    
    // Query recent files
    result, _ := engine.Query(ctx, `
        file_topology(Path, _, _, LastMod, _),
        current_time(Now),
        fn:minus(Now, LastMod) < 300
    `)
    ```
    
    ### Find Files by Pattern
    
    ```mangle
    # Files in specific directory
    ? file_topology(Path, _, _, _, _),
      fn:string_contains(Path, "src/auth").
    
    # Files with specific extension
    ? file_topology(Path, _, _, _, _),
      fn:string_contains(Path, ".go").
    ```
    
    ### Get File Dependencies
    
    ```mangle
    # What does main.go import?
    ? file_imports("src/main.go", ImportPath, /direct).
    
    # Who imports this file?
    ? file_imports(SourcePath, "src/auth/handler.go", _).
    ```
    
    ---
    
    ## Impact Analysis Queries
    
    ### Find Impacted Files
    
    ```mangle
    # Direct impact
    ? impacted(Path).
    
    # Files that need testing
    ? needs_testing(Path).
    
    # Unsafe refactoring targets
    ? unsafe_to_refactor(Target).
    ```
    
    ```go
    // Find all impacted files
    result, _ := engine.Query(ctx, "impacted(Path)")
    for _, b := range result.Bindings {
        fmt.Println("Impacted:", b["Path"])
    }
    ```
    
    ### Transitive Dependency Closure
    
    ```mangle
    # All files depending on X (transitive)
    ? impacted(Path),
      dependency_link(Path, "src/auth/handler.go", _).
    ```
    
    ---
    
    ## Symbol Graph Queries
    
    ### Find Symbols by Type
    
    ```mangle
    # All functions
    ? symbol_graph(ID, /function, _, _, _).
    
    # Public functions
    ? symbol_graph(ID, /function, /public, _, _).
    
    # Structs
    ? symbol_graph(ID, /struct, _, _, _).
    ```
    
    ```go
    // Get all public functions
    result, _ := engine.Query(ctx, "symbol_graph(ID, /function, /public, _, _)")
    for _, b := range result.Bindings {
        fmt.Println("Function:", b["ID"])
    }
    ```
    
    ### Find Symbol Definitions
    
    ```mangle
    # Where is AuthHandler defined?
    ? symbol_graph("func:main:AuthHandler", _, _, DefinedAt, _).
    
    # All symbols in a file
    ? symbol_graph(ID, _, _, DefinedAt, _),
      fn:string_contains(DefinedAt, "src/auth/handler.go").
    ```
    
    ### Call Graph Queries
    
    ```mangle
    # What does main call?
    ? dependency_link("func:main:main", CalleeID, _).
    
    # Who calls AuthHandler?
    ? dependency_link(CallerID, "func:auth:AuthHandler", _).
    
    # Transitive callers (recursive)
    ? ancestor_caller(CallerID, "func:auth:AuthHandler").
    ```
    
    ---
    
    ## Diagnostic Queries
    
    ### Find Errors
    
    ```mangle
    # Any errors?
    ? diagnostic(/error, _, _, _, _).
    
    # Errors in specific file
    ? diagnostic(/error, "src/main.go", Line, Code, Msg).
    
    # All panics
    ? diagnostic(/panic, File, Line, _, Msg).
    ```
    
    ```go
    // Check for build errors
    result, _ := engine.Query(ctx, "diagnostic(/error, _, _, _, _)")
    if len(result.Bindings) > 0 {
        fmt.Println("Build has errors - cannot commit")
    }
    ```
    
    ### Find Test Failures
    
    ```mangle
    # Failed tests
    ? test_result(TestName, File, /failed, _, Msg).
    
    # Panicking tests
    ? test_result(TestName, File, /panic, _, Msg).
    
    # All non-passing tests
    ? test_result(TestName, _, Status, _, _),
      Status != /passed.
    ```
    
    ```go
    // Get all test failures
    result, _ := engine.Query(ctx, "test_result(Name, File, /failed, _, Msg)")
    for _, b := range result.Bindings {
        fmt.Printf("FAIL: %s in %s - %s\n", b["Name"], b["File"], b["Msg"])
    }
    ```
    
    ### Check Commit Barrier
    
    ```mangle
    # Is commit allowed?
    ? git_commit_allowed().
    
    # Why is commit blocked?
    ? block_commit(Reason).
    ```
    
    ```go
    // Check if safe to commit
    result, _ := engine.Query(ctx, "git_commit_allowed()")
    if len(result.Bindings) == 0 {
        fmt.Println("Commit blocked")
    
        // Find reason
        reasons, _ := engine.Query(ctx, "block_commit(Reason)")
        for _, b := range reasons.Bindings {
            fmt.Println("Reason:", b["Reason"])
        }
    }
    ```
    
    ---
    
    ## TDD Loop Queries
    
    ### Check Current State
    
    ```mangle
    # What's the current test state?
    ? test_state(State).
    
    # What's the next action?
    ? next_action(Action).
    ```
    
    ```go
    // Get next action
    result, _ := engine.Query(ctx, "next_action(Action)")
    if len(result.Bindings) > 0 {
        action := result.Bindings[0]["Action"].(string)
        fmt.Println("Next action:", action)
    }
    ```
    
    ### Check Retry Count
    
    ```mangle
    # How many retries?
    ? retry_count(N).
    
    # Should we escalate?
    ? test_state(/failing), retry_count(N), N >= 3.
    ```
    
    ---
    
    ## Strategy Selection Queries
    
    ### Find Active Strategy
    
    ```mangle
    # What strategy is active?
    ? active_strategy(Strategy).
    
    # Is TDD loop active?
    ? active_strategy(/tdd_repair_loop).
    
    # Check for strategy conflicts
    ? strategy_conflict().
    ```
    
    ```go
    // Get active strategy
    result, _ := engine.Query(ctx, "active_strategy(Strategy)")
    if len(result.Bindings) > 0 {
        strategy := result.Bindings[0]["Strategy"].(string)
        fmt.Println("Using strategy:", strategy)
    }
    ```
    
    ---
    
    ## Permission & Safety Queries
    
    ### Check Action Permissions
    
    ```mangle
    # Is action permitted?
    ? permitted(/write_file).
    
    # Is action dangerous?
    ? dangerous_action(Action).
    
    # Is action blocked?
    ? block_action(ActionType, Details).
    ```
    
    ```go
    // Check if action allowed
    result, _ := engine.Query(ctx, "permitted(/write_file)")
    if len(result.Bindings) == 0 {
        fmt.Println("Write not permitted")
    }
    ```
    
    ### Check Safety Constraints
    
    ```mangle
    # Is binary allowed?
    ? binary_allowlist(Binary).
    
    # Is network domain allowed?
    ? network_allowlist(Domain).
    
    # Any security violations?
    ? security_violation(Type, Details).
    ```
    
    ---
    
    ## Context Selection Queries
    
    ### Find Activated Facts
    
    ```mangle
    # High-activation facts
    ? activation(Concept, Weight, _), Weight > 80.
    
    # Facts in context
    ? context_atom(Fact).
    
    # Spreading from dependencies
    ? activation(FileB, Score, /dependency).
    ```
    
    ```go
    // Get context atoms
    result, _ := engine.Query(ctx, "context_atom(Fact)")
    for _, b := range result.Bindings {
        fmt.Println("Include in context:", b["Fact"])
    }
    ```
    
    ---
    
    ## Shard Management Queries
    
    ### Find Specialist Agents
    
    ```mangle
    # All specialists
    ? shard_profile(Name, _, _, _).
    
    # Rust specialist
    ? shard_profile(/agent_rust, Desc, Topics, Tools).
    
    # Agents needing research
    ? needs_research(Agent).
    ```
    
    ### Check Delegated Tasks
    
    ```mangle
    # All delegated tasks
    ? delegate_task(ShardType, Task, Priority).
    
    # High-priority tasks
    ? delegate_task(ShardType, Task, Priority), Priority > 90.
    
    # Tasks for reviewer
    ? delegate_task(/reviewer, Task, _).
    ```
    
    ### Check Shard Status
    
    ```mangle
    # Running shards
    ? shard_status(Name, /running, _).
    
    # Completed shards
    ? shard_status(Name, /completed, LastActive).
    ```
    
    ---
    
    ## Campaign Queries
    
    ### Find Active Campaigns
    
    ```mangle
    # All active campaigns
    ? campaign(ID, Goal, /active).
    
    # All campaigns
    ? campaign(ID, Goal, Status).
    ```
    
    ### Check Phase Status
    
    ```mangle
    # Current phase
    ? campaign_phase(CID, PhaseNum, Desc, /active).
    
    # Completed phases
    ? campaign_phase(CID, PhaseNum, _, /completed).
    
    # Ready phases
    ? phase_ready(CID, Phase).
    ```
    
    ### Check Phase Dependencies
    
    ```mangle
    # What does phase 3 depend on?
    ? phase_depends(/c1, 3, DependsOn).
    
    # Can phase 2 start?
    ? phase_ready(/c1, 2).
    ```
    
    ---
    
    ## Knowledge & Research Queries
    
    ### Find Knowledge Atoms
    
    ```mangle
    # All Rust knowledge
    ? knowledge_atom(URL, Concept, Pattern, _),
      fn:string_contains(URL, "rust").
    
    # Specific concept
    ? knowledge_atom(URL, "ownership", Pattern, AntiPattern).
    ```
    
    ### Check Research Status
    
    ```mangle
    # Completed research
    ? research_topic(Agent, Topic, /completed).
    
    # Pending research
    ? research_topic(Agent, Topic, /pending).
    ```
    
    ---
    
    ## Autopoiesis Queries (Ouroboros Loop)
    
    ### Check Loop State
    
    ```mangle
    # Current state
    ? state(StepID, Stability, Location).
    
    # Proposed next state
    ? proposed(StepID).
    
    # Should halt?
    ? should_halt(StepID).
    
    # Should complete?
    ? should_complete(StepID).
    ```
    
    ### Check Termination Conditions
    
    ```mangle
    # Stagnation detected?
    ? stagnation_detected().
    
    # Max iterations exceeded?
    ? max_iterations_exceeded(StepID).
    
    # Stability degrading?
    ? stability_degrading(StepID).
    
    # Converged?
    ? converged(StepID).
    ```
    
    ### Check Effective Stability
    
    ```mangle
    # Get effective stability
    ? effective_stability(StepID, Effective).
    
    # Check penalties
    ? cumulative_penalty(StepID, Penalty).
    
    # Valid transition?
    ? valid_transition(NextStep).
    ```
    
    ---
    
    ## Aggregation Queries
    
    ### Count Files by Language
    
    ```mangle
    # Count Go files
    ? file_topology(_, _, /go, _, _)
      |> do fn:group_by(),
         let Count = fn:count().
    
    # Count by language
    ? file_topology(_, _, Lang, _, _)
      |> do fn:group_by(Lang),
         let Count = fn:count().
    ```
    
    ```go
    // Go integration (aggregations require special handling)
    // Note: Direct aggregation queries may not work via Query API
    // Better to use GetFacts and aggregate in Go
    goFiles, _ := engine.GetFacts("file_topology")
    count := 0
    for _, f := range goFiles {
        if f.Args[2] == "/go" {
            count++
        }
    }
    fmt.Printf("Go files: %d\n", count)
    ```
    
    ### Sum Test Duration
    
    ```mangle
    # Total test time
    ? test_result(_, _, _, Duration, _)
      |> do fn:group_by(),
         let Total = fn:sum(Duration).
    ```
    
    ### Find Max/Min
    
    ```mangle
    # Highest priority task
    ? delegate_task(_, _, Priority)
      |> do fn:group_by(),
         let Max = fn:max(Priority).
    ```
    
    ---
    
    ## Complex Join Queries
    
    ### Files with Errors
    
    ```mangle
    # Files that have errors
    ? diagnostic(/error, File, _, _, _),
      file_topology(File, _, Lang, _, _).
    ```
    
    ### Impacted Test Files
    
    ```mangle
    # Test files that need re-running
    ? impacted(Path),
      file_topology(Path, _, _, _, /true).
    ```
    
    ### High-Activation Recent Files
    
    ```mangle
    # Recently modified files with high activation
    ? activation(Path, Weight, _),
      Weight > 80,
      file_topology(Path, _, _, LastMod, _),
      current_time(Now),
      fn:minus(Now, LastMod) < 300.
    ```
    
    ---
    
    ## Negation Queries
    
    ### Files Without Tests
    
    ```mangle
    # Files missing test coverage
    ? file_topology(Path, _, /go, _, /false),
      not test_coverage(Path, /true).
    ```
    
    ### Unresolved Ambiguities
    
    ```mangle
    # References with low confidence
    ? focus_resolution(Ref, _, _, Score),
      Score < 85,
      not ambiguity_flag(Ref, _, _).  # Not yet flagged
    ```
    
    ---
    
    ## Debugging Queries
    
    ### List All Predicates
    
    ```go
    // Get stats showing all predicates
    stats := engine.GetStats()
    for pred, count := range stats.PredicateCounts {
        fmt.Printf("%s: %d facts\n", pred, count)
    }
    ```
    
    ### Dump All Facts for Predicate
    
    ```go
    facts, _ := engine.GetFacts("file_topology")
    for _, f := range facts {
        fmt.Printf("%s(%v)\n", f.Predicate, f.Args)
    }
    ```
    
    ### Check Rule Derivation
    
    ```mangle
    # Did the rule fire?
    ? next_action(Action).
    
    # Why is clarification needed?
    ? clarification_needed(Ref),
      focus_resolution(Ref, Path, Sym, Score).
    ```
    
    ---
    
    ## Performance Tips
    
    ### Selective Binding
    
    ```mangle
    # BAD: Unbounded cartesian product
    ? file_topology(Path1, _, _, _, _),
      file_topology(Path2, _, _, _, _).
    
    # GOOD: Bind first
    ? file_topology(Path1, _, /go, _, _),
      file_imports(Path1, Path2, _).
    ```
    
    ### Early Filtering
    
    ```mangle
    # BAD: Filter late
    ? file_topology(Path, _, Lang, _, _),
      Lang = /go.
    
    # GOOD: Filter early
    ? file_topology(Path, _, /go, _, _).
    ```
    
    ### Use Anonymous Variables
    
    ```mangle
    # BAD: Unnecessary binding
    ? file_topology(Path, Hash, Lang, LastMod, IsTest).
    
    # GOOD: Only bind what's needed
    ? file_topology(Path, _, /go, _, _).
    ```
    
    ---
    
    ## Error Handling
    
    ```go
    // Always check for errors
    result, err := engine.Query(ctx, "next_action(Action)")
    if err != nil {
        if strings.Contains(err.Error(), "not declared") {
            log.Printf("Predicate not declared in schema")
        } else if strings.Contains(err.Error(), "timeout") {
            log.Printf("Query timed out")
        }
        return err
    }
    
    // Check for empty results
    if len(result.Bindings) == 0 {
        log.Printf("Query returned no results")
    }
    ```
    
    ---
    
    ## See Also
    
    - [schemas.md](schemas.md) - Predicate declarations
    - [policy.md](policy.md) - IDB derivation rules
    - [fact_patterns.md](fact_patterns.md) - Creating facts
    - [integration_points.md](integration_points.md) - Go API patterns
