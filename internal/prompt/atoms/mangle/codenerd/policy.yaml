# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: codenerd/policy.md

- id: "language/mangle/docs/codenerd/policy"
  category: "language"
  subcategory: "mangle"
  description: "codeNERD Mangle Policy Rules (IDB)"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # codeNERD Mangle Policy Rules (IDB)
    
    Complete reference of Intensional Database (IDB) derivation rules used in codeNERD. These rules **derive** new facts from existing EDB facts through logical inference.
    
    ## Overview
    
    IDB rules are the "brains" of the Mangle kernel. They implement:
    - **Intent routing** - Map user requests to actions
    - **Strategy selection** - Choose execution workflows
    - **Safety constraints** - Constitutional gatekeeping
    - **Context selection** - Spreading activation
    - **Repair orchestration** - TDD loop state machine
    - **Impact analysis** - Transitive dependency tracking
    
    ## Rule Categories
    
    Policy rules are organized into thematic sections matching the codeNERD architecture.
    
    ---
    
    ## SECTION 1: Intent Classification & Routing
    
    ### Clarification Logic
    
    Blocks execution when user intent is ambiguous.
    
    ```mangle
    # Trigger interrogative mode when focus resolution confidence is low
    clarification_needed(Ref) :-
        focus_resolution(Ref, _, _, Score),
        Score < 85.
    
    # Block action derivation if clarification needed
    next_action(/interrogative_mode) :-
        clarification_needed(_).
    
    # Block on ambiguity flags
    next_action(/interrogative_mode) :-
        ambiguity_flag(_, _, _).
    ```
    
    ### Polymorphic Verb Dispatch
    
    Same verb applied to different targets triggers different strategies.
    
    ```mangle
    # fix applied to File -> TDD repair loop
    active_strategy(/tdd_repair_loop) :-
        user_intent(_, /mutation, /fix, Target, _),
        file_topology(Target, _, _, _, _).
    
    # fix applied to Schema -> migration generation
    active_strategy(/migration_generation) :-
        user_intent(_, /mutation, /fix, Target, _),
        database_schema(Target, _).
    
    # review applied to security -> vulnerability scan
    active_strategy(/security_scan) :-
        user_intent(_, /query, /review, _, _),
        context_token("security").
    ```
    
    ### Verb Selection (Semantic Classification)
    
    Advanced semantic matching with learned patterns.
    
    ```mangle
    # Base score from candidates
    potential_score(Verb, Score) :- candidate_intent(Verb, Score).
    
    # Learned pattern override (highest priority)
    potential_score(Verb, 100.0) :-
        user_input_string(Input),
        learned_exemplar(Pattern, Verb, _, _, _),
        Input = Pattern.
    
    # High-confidence semantic override (similarity >= 85)
    potential_score(Verb, 100.0) :-
        semantic_match(_, _, Verb, _, 1, Similarity),
        Similarity >= 85.
    
    # Medium-confidence boost (similarity 70-84)
    potential_score(Verb, NewScore) :-
        candidate_intent(Verb, Base),
        semantic_match(_, _, Verb, _, Rank, Similarity),
        Rank <= 3,
        Similarity >= 70,
        Similarity < 85,
        NewScore = fn:plus(Base, 30.0).
    
    # Contextual boosting
    potential_score(Verb, NewScore) :-
        candidate_intent(Verb, Base),
        Verb = /security,
        context_token("vulnerability"),
        NewScore = fn:plus(Base, 0.3).
    
    # Max score selection (relational negation)
    has_greater_score(S) :-
        potential_score(_, S),
        potential_score(_, Other),
        Other > S.
    
    best_score(S) :-
        potential_score(_, S),
        !has_greater_score(S).
    
    selected_verb(Verb) :-
        potential_score(Verb, S),
        best_score(Max),
        S = Max.
    ```
    
    ---
    
    ## SECTION 2: Strategy Selection
    
    Dynamic workflow dispatch based on context.
    
    ### TDD Strategies
    
    ```mangle
    # TDD repair loop for test failures
    active_strategy(/tdd_repair_loop) :-
        user_intent(_, /mutation, /fix, _, _),
        focus_resolution(_, Path, _, _),
        file_topology(Path, _, _, _, /true).
    
    # TDD for mutation with existing tests
    active_strategy(/tdd_with_coverage) :-
        user_intent(_, /mutation, _, Target, _),
        test_coverage(Target, /true).
    ```
    
    ### Exploration Strategies
    
    ```mangle
    # Breadth-first for large codebases
    active_strategy(/breadth_first_survey) :-
        user_intent(_, /query, /explore, _, _),
        file_count(N),
        N > 100.
    
    # Depth-first for small codebases
    active_strategy(/depth_first_dive) :-
        user_intent(_, /query, /explore, _, _),
        file_count(N),
        N <= 100.
    ```
    
    ### Scaffolding Strategies
    
    ```mangle
    # Project init for empty directories
    active_strategy(/project_init) :-
        user_intent(_, /mutation, /scaffold, _, _),
        file_count(0).
    
    # Feature scaffolding for existing projects
    active_strategy(/feature_scaffold) :-
        user_intent(_, /mutation, /scaffold, _, _),
        file_count(N),
        N > 0.
    ```
    
    ### Strategy Conflict Detection
    
    ```mangle
    # Only one strategy active per shard
    strategy_conflict() :-
        active_strategy(A),
        active_strategy(B),
        A != B.
    ```
    
    ---
    
    ## SECTION 3: TDD Repair Loop State Machine
    
    The TDD repair orchestrator - derives next action based on test state.
    
    ### State Transitions
    
    ```mangle
    # Read error log when failing
    next_action(/read_error_log) :-
        test_state(/failing),
        retry_count(N),
        N < 3.
    
    # Analyze after reading logs
    next_action(/analyze_root_cause) :-
        test_state(/log_read).
    
    # Generate patch after analysis
    next_action(/generate_patch) :-
        test_state(/cause_found).
    
    # Run tests after patching
    next_action(/run_tests) :-
        test_state(/patch_applied).
    
    # Escalate after max retries
    next_action(/escalate_to_user) :-
        test_state(/failing),
        retry_count(N),
        N >= 3.
    
    # Success - mark complete
    next_action(/mark_complete) :-
        test_state(/passing).
    ```
    
    ### Retry Logic
    
    ```mangle
    # Increment retry counter
    retry_count(NewN) :-
        retry_count(N),
        test_state(/failing),
        NewN = fn:plus(N, 1).
    ```
    
    ---
    
    ## SECTION 4: Impact Analysis & Dependency Tracking
    
    Transitive closure for "who is affected by this change?"
    
    ### Direct Impact
    
    ```mangle
    # Direct impact from modification
    impacted(X) :-
        dependency_link(X, Y, _),
        modified(Y).
    ```
    
    ### Recursive Closure
    
    ```mangle
    # Recursive spread through call graph
    impacted(X) :-
        dependency_link(X, Z, _),
        impacted(Z).
    ```
    
    ### Test Coverage Requirements
    
    ```mangle
    # Mark impacted files for testing
    needs_testing(X) :-
        impacted(X).
    
    # Unsafe if impacted symbol has no tests
    unsafe_to_refactor(Target) :-
        impacted(Dependent),
        depends_on(Dependent, Target),
        test_coverage(Dependent, /false).
    ```
    
    ---
    
    ## SECTION 5: Constitutional Safety (Permission Gate)
    
    Default-deny execution model. Every action requires explicit permission.
    
    ### Permission Rules
    
    ```mangle
    # Safe actions are permitted
    permitted(Action) :-
        safe_action(Action).
    
    # Dangerous actions require override + approval
    permitted(Action) :-
        dangerous_action(Action),
        admin_override(User),
        signed_approval(Action).
    ```
    
    ### Safe Action Classification
    
    ```mangle
    # Read operations are safe
    safe_action(/read_file).
    safe_action(/query_database).
    safe_action(/list_directory).
    
    # Some write operations are safe
    safe_action(/write_test_file) :-
        file_path(Action, Path),
        fn:string_contains(Path, "_test").
    ```
    
    ### Dangerous Action Classification
    
    ```mangle
    # Shell commands with destructive potential
    dangerous_action(Action) :-
        action_type(Action, /exec_cmd),
        cmd_string(Action, Cmd),
        fn:string_contains(Cmd, "rm").
    
    dangerous_action(Action) :-
        action_type(Action, /exec_cmd),
        cmd_string(Action, Cmd),
        fn:string_contains(Cmd, "sudo").
    
    # File writes to sensitive files
    dangerous_action(Action) :-
        action_type(Action, /write_file),
        file_path(Action, Path),
        fn:string_contains(Path, ".env").
    
    dangerous_action(Action) :-
        action_type(Action, /write_file),
        file_path(Action, Path),
        fn:string_contains(Path, "credentials").
    ```
    
    ### Commit Barrier
    
    ```mangle
    # Block git commit if any errors exist
    block_commit("Build Broken") :-
        diagnostic(/error, _, _, _, _).
    
    # Block commit if tests failing
    block_commit("Tests Failing") :-
        test_result(_, _, /failed, _, _).
    
    # Commit allowed only when no blockers
    git_commit_allowed() :-
        not block_commit(_).
    ```
    
    ### Network Policy
    
    ```mangle
    # Allowlist for network requests
    network_allowlist("github.com").
    network_allowlist("pypi.org").
    network_allowlist("crates.io").
    network_allowlist("npmjs.com").
    
    # Detect exfiltration attempts
    security_violation(/exfiltration, URL) :-
        next_action(/network_request, URL),
        extract_domain(URL, Domain),
        not network_allowlist(Domain).
    ```
    
    ### Binary Allowlist
    
    ```mangle
    # Permitted binaries for shell execution
    binary_allowlist("go").
    binary_allowlist("npm").
    binary_allowlist("cargo").
    binary_allowlist("git").
    binary_allowlist("python").
    
    # Block if not in allowlist
    block_action(/shell_exec, Req) :-
        shell_exec_request(Binary, _, _, _, _),
        not binary_allowlist(Binary).
    ```
    
    ---
    
    ## SECTION 6: Context Selection (Spreading Activation)
    
    Implements attention mechanism for prompt context selection.
    
    ### Base Activation
    
    ```mangle
    # Recency boost for new facts
    activation(Fact, 100) :-
        new_fact(Fact).
    
    # Mentioned in current turn
    activation(File, 90) :-
        focus_resolution(_, File, _, _).
    ```
    
    ### Spreading from Goals
    
    ```mangle
    # Spread from active goal to relevant tools
    activation(Tool, 80) :-
        active_goal(Goal),
        tool_capabilities(Tool, Cap),
        goal_requires(Goal, Cap).
    ```
    
    ### Recursive Spread via Dependencies
    
    ```mangle
    # Spread through call graph (decay factor 0.5)
    activation(FileB, Score2) :-
        activation(FileA, Score),
        Score > 40,
        dependency_link(FileA, FileB, _),
        Score2 = fn:times(Score, 0.5).
    ```
    
    ### Context Pruning
    
    ```mangle
    # Include in prompt context if activation above threshold
    context_atom(Fact) :-
        activation(Fact, Score),
        Score > 30.
    ```
    
    ### Priority Weighting
    
    ```mangle
    # Higher priority for files with errors
    activation(File, 95) :-
        diagnostic(_, File, _, _, _).
    
    # Higher priority for recently modified files
    activation(File, 85) :-
        file_topology(File, _, _, LastMod, _),
        current_time(Now),
        Now - LastMod < 300.  # Modified in last 5 minutes
    ```
    
    ---
    
    ## SECTION 7: Shard Delegation
    
    Dynamic shard spawning and task routing.
    
    ### Delegation Triggers
    
    ```mangle
    # Spawn shard when task delegated
    spawn_shard(ShardType) :-
        delegate_task(ShardType, _, _).
    
    # Route /review verb to ReviewerShard
    delegate_task(/reviewer, Target, /pending) :-
        user_intent(_, _, /review, Target, _).
    
    # Route /test verb to TesterShard
    delegate_task(/tester, Target, /pending) :-
        user_intent(_, _, /test, Target, _).
    
    # Route /research verb to ResearcherShard
    delegate_task(/researcher, Topic, /pending) :-
        user_intent(_, _, /research, Topic, _).
    ```
    
    ### Specialist Requirements
    
    ```mangle
    # Specialists require knowledge base
    invalid_shard(ShardID) :-
        shard_lifecycle(ShardID, /specialist, _, null, _).
    
    # Research needed before instantiation
    needs_research(Agent) :-
        shard_profile(Agent, _, Topics, _),
        not knowledge_ingested(Agent).
    ```
    
    ---
    
    ## SECTION 8: Memory Operations
    
    Long-term memory promotion and archival.
    
    ### Promotion Criteria
    
    ```mangle
    # Promote facts mentioned repeatedly
    to_promote(Fact) :-
        mentioned_count(Fact, N),
        N > 3.
    
    # Promote important observations
    to_promote(Fact) :-
        observation(Fact, _),
        activation(Fact, Score),
        Score > 80.
    ```
    
    ### Archival Criteria
    
    ```mangle
    # Archive old facts with low activation
    to_archive(Fact) :-
        last_accessed(Fact, Time),
        current_time(Now),
        Now - Time > 3600,
        not activation(Fact, _).
    ```
    
    ---
    
    ## SECTION 9: Campaign Orchestration
    
    Multi-phase goal tracking and phase dependency resolution.
    
    ### Phase Ordering
    
    ```mangle
    # Phase ready when dependencies completed
    phase_ready(CampaignID, Phase) :-
        campaign_phase(CampaignID, Phase, _, /pending),
        !has_incomplete_dependency(CampaignID, Phase).
    
    has_incomplete_dependency(CID, Phase) :-
        phase_depends(CID, Phase, DependsOn),
        campaign_phase(CID, DependsOn, _, Status),
        Status != /completed.
    ```
    
    ### Next Phase Selection
    
    ```mangle
    # Next phase is the lowest-numbered ready phase
    next_phase(CampaignID, Phase) :-
        phase_ready(CampaignID, Phase),
        !has_earlier_ready_phase(CampaignID, Phase).
    
    has_earlier_ready_phase(CID, Phase) :-
        phase_ready(CID, Earlier),
        Earlier < Phase.
    ```
    
    ---
    
    ## SECTION 10: Autopoiesis (Ouroboros Loop)
    
    Self-modification stability tracking and termination detection.
    
    ### Stagnation Detection
    
    ```mangle
    # Detect code hash repetition
    stagnation_detected() :-
        history(StepA, Hash),
        history(StepB, Hash),
        StepA != StepB.
    ```
    
    ### Penalty Calculation
    
    ```mangle
    # Panic penalty
    has_panic_penalty(StepID) :-
        error_history(StepID, /panic, _).
    
    # Retry penalty
    has_retry_penalty(StepID) :-
        retry_attempt(StepID, N, _),
        N >= 2.
    
    # Cumulative penalties (fixed tiers)
    cumulative_penalty(StepID, 0.3) :-
        has_panic_penalty(StepID),
        has_retry_penalty(StepID).
    
    cumulative_penalty(StepID, 0.2) :-
        has_panic_penalty(StepID),
        !has_retry_penalty(StepID).
    
    cumulative_penalty(StepID, 0.1) :-
        has_retry_penalty(StepID),
        !has_panic_penalty(StepID).
    
    cumulative_penalty(StepID, 0.0) :-
        state(StepID, _, _),
        !has_penalty(StepID).
    ```
    
    ### Effective Stability
    
    ```mangle
    # Stability adjusted for penalties
    effective_stability(StepID, Effective) :-
        base_stability(StepID, Base),
        cumulative_penalty(StepID, Penalty),
        Effective = fn:minus(Base, Penalty).
    ```
    
    ### Transition Validation
    
    ```mangle
    # Monotonic improvement constraint
    valid_transition(Next) :-
        state(Curr, _, _),
        proposed(Next),
        effective_stability(Curr, CurrEff),
        effective_stability(Next, NextEff),
        NextEff >= CurrEff.
    ```
    
    ### Termination Conditions
    
    ```mangle
    # Max iterations exceeded
    max_iterations_exceeded(StepID) :-
        iteration(StepID, N),
        max_iterations(Limit),
        N >= Limit.
    
    # Max retries exceeded
    max_retries_exceeded(StepID) :-
        retry_attempt(StepID, N, _),
        max_retries(Limit),
        N >= Limit.
    
    # Stability degrading (3 consecutive drops)
    stability_degrading(StepID) :-
        state_at_iteration(StepID, N1, S1),
        state_at_iteration(StepID, N2, S2),
        state_at_iteration(StepID, N3, S3),
        N2 = fn:plus(N1, 1),
        N3 = fn:plus(N2, 1),
        S2 < S1,
        S3 < S2.
    
    # Convergence (stable for 2 iterations)
    converged(StepID) :-
        state_at_iteration(StepID, N1, S1),
        state_at_iteration(StepID, N2, S2),
        N2 = fn:plus(N1, 1),
        S1 = S2,
        N2 >= 2.
    ```
    
    ### Halting Oracle
    
    ```mangle
    # Halt on various failure conditions
    should_halt(StepID) :-
        iteration(StepID, _),
        max_iterations_exceeded(StepID).
    
    should_halt(StepID) :-
        retry_attempt(StepID, _, _),
        max_retries_exceeded(StepID).
    
    should_halt(StepID) :-
        state(StepID, _, _),
        stagnation_detected().
    
    should_halt(StepID) :-
        state_at_iteration(StepID, _, _),
        stability_degrading(StepID).
    
    # Complete on convergence
    should_complete(StepID) :-
        state_at_iteration(StepID, _, _),
        converged(StepID).
    ```
    
    ---
    
    ## SECTION 11: Abductive Reasoning
    
    Hypothesis generation for root cause analysis.
    
    ### Symptom-Cause Mapping
    
    ```mangle
    # Known cause lookup
    diagnosis(RootCause) :-
        symptom(_, Symptom),
        known_cause(Symptom, RootCause).
    
    # Generate hypothesis when cause unknown
    missing_hypothesis(Symptom) :-
        symptom(_, Symptom),
        not known_cause(Symptom, _).
    
    # Trigger clarification for unknown symptoms
    clarification_needed(Symptom) :-
        missing_hypothesis(Symptom).
    ```
    
    ---
    
    ## SECTION 12: Browser Automation (Semantic Web)
    
    Spatial and semantic reasoning over DOM.
    
    ### Element Selection
    
    ```mangle
    # Find checkbox to the left of text
    target_checkbox(CheckID) :-
        dom_node(CheckID, /input, _),
        attr(CheckID, "type", "checkbox"),
        visible_text(TextID, "Agree"),
        geometry(CheckID, Cx, _, _, _),
        geometry(TextID, Tx, _, _, _),
        Cx < Tx.
    
    # Find visible and interactable buttons
    clickable_button(ID) :-
        dom_node(ID, /button, _),
        interactable(ID, /click),
        computed_style(ID, "display", Display),
        Display != "none",
        geometry(ID, _, _, W, H),
        W > 0,
        H > 0.
    ```
    
    ---
    
    ## Rule Composition Patterns
    
    ### Chaining Rules
    
    ```mangle
    # Multi-step derivation
    final_conclusion(X) :-
        initial_fact(X),
        intermediate_step(X),
        final_check(X).
    ```
    
    ### Negation Safety
    
    ```mangle
    # All variables in negated atoms must be bound first
    safe_negation(X) :-
        positive_binding(X),
        not negative_condition(X).
    ```
    
    ### Aggregation with Transforms
    
    ```mangle
    # Count files per language
    file_count_by_lang(Lang, Count) :-
        file_topology(_, _, Lang, _, _)
        |> do fn:group_by(Lang),
           let Count = fn:count().
    ```
    
    ### Recursive Closure
    
    ```mangle
    # Transitive closure pattern
    ancestor(X, Y) :- parent(X, Y).
    ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).
    ```
    
    ---
    
    ## Usage Guidelines
    
    1. **Variable Safety**: All variables in rule head must appear in positive body atoms
    2. **Negation Safety**: Variables in negated atoms must be bound elsewhere
    3. **Stratification**: No recursion through negation (causes cyclic dependency)
    4. **Termination**: Recursive rules must have base case and bounded domain
    5. **Aggregation**: Use pipe `|>` operator with `do fn:group_by()`
    
    ## See Also
    
    - [schemas.md](schemas.md) - EDB predicate declarations
    - [predicates_reference.md](predicates_reference.md) - Predicate documentation
    - [validation_rules.md](validation_rules.md) - Common errors to avoid
