# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: codenerd/integration_points.md

- id: "language/mangle/docs/codenerd/integration_points"
  category: "language"
  subcategory: "mangle"
  description: "Mangle-Go Integration Points for codeNERD"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle-Go Integration Points for codeNERD
    
    Complete guide to integrating Mangle with Go code in codeNERD. Covers engine lifecycle, fact management, queries, and virtual predicates.
    
    ## Engine Lifecycle
    
    ### Creating an Engine
    
    ```go
    import (
        "codenerd/internal/mangle"
        "context"
    )
    
    // Create with default config
    cfg := mangle.DefaultConfig()
    eng, err := mangle.NewEngine(cfg, nil)
    if err != nil {
        return fmt.Errorf("failed to create engine: %w", err)
    }
    defer eng.Close()
    ```
    
    ### Configuration Options
    
    ```go
    cfg := mangle.Config{
        FactLimit:         100000,  // Max facts in store
        DerivedFactsLimit: 100000,  // Gas limit for inference (prevents runaway)
        QueryTimeout:      30,      // Seconds
        AutoEval:          true,    // Auto-recompute rules after fact insertion
        SchemaPath:        "",      // Optional: path to schema file
        PolicyPath:        "",      // Optional: path to policy file
    }
    ```
    
    ### Loading Schemas
    
    ```go
    // From file
    err := eng.LoadSchema("path/to/schema.mg")
    
    // From string
    schemaContent := `
    Decl file_topology(Path, Hash, Lang, LastMod, IsTest).
    Decl user_intent(ID, Category, Verb, Target, Constraint).
    `
    err = eng.LoadSchemaString(schemaContent)
    ```
    
    ### Auto-Eval Control
    
    ```go
    // Disable for bulk insertion
    eng.ToggleAutoEval(false)
    
    // Insert many facts
    for _, fact := range facts {
        eng.AddFact(fact.Predicate, fact.Args...)
    }
    
    // Re-enable and recompute once
    eng.ToggleAutoEval(true)
    eng.RecomputeRules()
    ```
    
    ---
    
    ## Fact Management
    
    ### Adding Single Facts
    
    ```go
    // AddFact(predicate string, args ...interface{})
    err := eng.AddFact("file_topology",
        "src/main.go",      // Path (String)
        "a3f4b2c1",         // Hash (String)
        "/go",              // Language (Name)
        1702345678,         // LastModified (Int)
        "/false")           // IsTestFile (Name)
    ```
    
    ### Adding Batch Facts
    
    ```go
    facts := []mangle.Fact{
        {
            Predicate: "file_topology",
            Args: []interface{}{"src/main.go", "hash1", "/go", 1702345678, "/false"},
        },
        {
            Predicate: "file_topology",
            Args: []interface{}{"src/db.go", "hash2", "/go", 1702345679, "/false"},
        },
    }
    
    err := eng.AddFacts(facts)
    ```
    
    ### Replacing Facts for File
    
    ```go
    // Removes old facts for file, adds new ones
    err := eng.ReplaceFactsForFile("src/main.go", facts)
    
    // With content hash
    err = eng.ReplaceFactsForFileWithHash("src/main.go", facts, "sha256hash")
    ```
    
    ### Getting Facts
    
    ```go
    // Get all facts for a predicate
    facts, err := eng.GetFacts("file_topology")
    for _, fact := range facts {
        fmt.Printf("%s(%v)\n", fact.Predicate, fact.Args)
    }
    ```
    
    ### Clearing Facts
    
    ```go
    // Clear all facts (keeps schema)
    eng.Clear()
    ```
    
    ---
    
    ## Querying
    
    ### Basic Query
    
    ```go
    ctx := context.Background()
    
    // Query with variables (UPPERCASE)
    result, err := eng.Query(ctx, "file_topology(Path, _, /go, _, _)")
    if err != nil {
        return err
    }
    
    // Access bindings
    for _, binding := range result.Bindings {
        path := binding["Path"].(string)
        fmt.Println("Go file:", path)
    }
    ```
    
    ### Query with Multiple Variables
    
    ```go
    query := "user_intent(ID, Category, Verb, Target, _)"
    result, err := eng.Query(ctx, query)
    
    for _, b := range result.Bindings {
        id := b["ID"].(string)
        category := b["Category"].(string)
        verb := b["Verb"].(string)
        target := b["Target"].(string)
        fmt.Printf("%s: %s %s on %s\n", id, category, verb, target)
    }
    ```
    
    ### Query with Constraints
    
    ```go
    // Note: Constraints in query string are limited
    // Better to filter in Go or use IDB rules
    
    result, err := eng.Query(ctx, "file_topology(Path, _, Lang, _, _)")
    for _, b := range result.Bindings {
        lang := b["Lang"].(string)
        if lang == "/go" {
            // Process Go files
        }
    }
    ```
    
    ### Check for Existence
    
    ```go
    // Does any error exist?
    result, err := eng.Query(ctx, "diagnostic(/error, _, _, _, _)")
    hasErrors := len(result.Bindings) > 0
    ```
    
    ### Nullary Predicates (No Arguments)
    
    ```go
    // Check stagnation
    result, err := eng.Query(ctx, "stagnation_detected()")
    isStagnant := len(result.Bindings) > 0
    ```
    
    ---
    
    ## Type Conversion
    
    ### Go to Mangle Types
    
    The engine automatically converts Go types to Mangle types:
    
    ```go
    // Strings
    "path/to/file"     -> String constant
    "/atom"            -> Name constant (atom)
    
    // Numbers
    int(42)            -> Number (int64)
    int64(42)          -> Number (int64)
    float64(0.95)      -> Number (scaled to int if 0.0-1.0)
    
    // Booleans
    true               -> /true (Name constant)
    false              -> /false (Name constant)
    
    // Lists
    []string{"a", "b"} -> List of String constants
    ```
    
    ### Mangle to Go Types
    
    When extracting from bindings:
    
    ```go
    binding := result.Bindings[0]
    
    // Type assertions
    path := binding["Path"].(string)
    priority := binding["Priority"].(int64)  // Numbers are int64
    confidence := binding["Confidence"].(float64)
    
    // Safe extraction
    path, ok := binding["Path"].(string)
    if !ok {
        return fmt.Errorf("unexpected type for Path")
    }
    ```
    
    ### Atom Handling
    
    ```go
    // Atoms come back as strings with "/" prefix
    verb := binding["Verb"].(string)
    if verb == "/fix" {
        // Handle fix verb
    }
    
    // Strip "/" if needed
    verbName := strings.TrimPrefix(verb, "/")
    ```
    
    ---
    
    ## Statistics & Monitoring
    
    ### Get Engine Stats
    
    ```go
    stats := eng.GetStats()
    fmt.Printf("Total facts: %d\n", stats.TotalFacts)
    
    for pred, count := range stats.PredicateCounts {
        fmt.Printf("%s: %d facts\n", pred, count)
    }
    ```
    
    ### Gas Limit Monitoring
    
    ```go
    // Check derived fact count (gas usage)
    derivedCount := eng.GetDerivedFactCount()
    fmt.Printf("Derived facts: %d\n", derivedCount)
    
    // Reset at session start
    eng.ResetDerivedFactCount()
    ```
    
    ---
    
    ## Persistence Integration
    
    ### Implementing Persistence Interface
    
    ```go
    type Persistence interface {
        ReplaceFactsForFile(ctx context.Context, file string, facts []Fact, contentHash string) error
        LoadFacts(ctx context.Context) ([]Fact, error)
        GetFileStates(ctx context.Context) (map[string]string, error)
    }
    
    // Example SQLite implementation
    type SQLitePersistence struct {
        db *sql.DB
    }
    
    func (p *SQLitePersistence) LoadFacts(ctx context.Context) ([]mangle.Fact, error) {
        rows, err := p.db.QueryContext(ctx, "SELECT predicate, args FROM facts")
        // ... unmarshal and return
    }
    ```
    
    ### Warm Start from Persistence
    
    ```go
    // Create engine with persistence
    persistence := NewSQLitePersistence(db)
    eng, err := mangle.NewEngine(cfg, persistence)
    
    // Load persisted facts
    err = eng.WarmFromPersistence(ctx)
    ```
    
    ---
    
    ## Error Handling
    
    ### Common Errors
    
    ```go
    err := eng.AddFact("unknown_predicate", "arg1")
    // Error: "predicate unknown_predicate is not declared in schemas"
    
    err = eng.AddFact("file_topology", "path", "hash")
    // Error: "predicate file_topology expects 5 args, got 2"
    
    result, err := eng.Query(ctx, "file_topology(path, _, _, _, _)")
    // Error: "failed to parse query"
    // (Variables must be UPPERCASE)
    ```
    
    ### Error Checks
    
    ```go
    err := eng.AddFact("file_topology", path, hash, lang, ts, isTest)
    if err != nil {
        if strings.Contains(err.Error(), "not declared") {
            log.Printf("Predicate not declared - load schema first")
        } else if strings.Contains(err.Error(), "expects") {
            log.Printf("Arity mismatch")
        } else {
            log.Printf("Unknown error: %v", err)
        }
    }
    ```
    
    ### Gas Limit Exceeded
    
    ```go
    err := eng.AddFacts(facts)
    if err != nil {
        if errors.Is(err, mangle.ErrDerivedFactsLimitExceeded) {
            log.Printf("Inference gas limit exceeded - possible runaway derivation")
            // Reset and retry with smaller batch
            eng.ResetDerivedFactCount()
        }
    }
    ```
    
    ---
    
    ## Virtual Predicates (FFI)
    
    Virtual predicates allow Mangle queries to call out to Go code.
    
    ### Defining Virtual Predicates (Future Feature)
    
    ```go
    // Example pattern (not yet implemented in codeNERD)
    // Virtual predicates would allow filesystem access from Mangle queries
    
    func fileExists(query engine.Query, cb func(engine.Fact)) error {
        // Extract path from query
        path := query.Args[0].(string)
    
        // Check filesystem
        if _, err := os.Stat(path); err == nil {
            // Assert fact
            cb(engine.Fact{
                Predicate: engine.PredicateSym{Symbol: "file_exists"},
                Args:      []engine.BaseTerm{engine.String(path), engine.TrueConstant},
            })
        }
        return nil
    }
    
    // Register virtual predicate
    engine.RegisterVirtual("file_exists", fileExists)
    ```
    
    ---
    
    ## Integration with codeNERD Components
    
    ### Kernel Integration
    
    ```go
    // internal/core/kernel.go
    type Kernel struct {
        engine *mangle.Engine
        // ...
    }
    
    func (k *Kernel) AddFact(predicate string, args ...interface{}) error {
        return k.engine.AddFact(predicate, args...)
    }
    
    func (k *Kernel) Query(ctx context.Context, query string) (*mangle.QueryResult, error) {
        return k.engine.Query(ctx, query)
    }
    ```
    
    ### Perception Integration
    
    ```go
    // internal/perception/transducer.go
    func (t *Transducer) TransduceIntent(input string) error {
        // Parse NL to intent
        intent := t.parseNL(input)
    
        // Create user_intent fact
        return t.kernel.AddFact("user_intent",
            intent.ID,
            intent.Category,
            intent.Verb,
            intent.Target,
            intent.Constraint)
    }
    ```
    
    ### World Model Integration
    
    ```go
    // internal/world/scanner.go
    func (s *Scanner) ScanDirectory(root string) error {
        facts := []mangle.Fact{}
    
        filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
            if info.IsDir() {
                return nil
            }
    
            // Create file_topology fact
            facts = append(facts, mangle.Fact{
                Predicate: "file_topology",
                Args: []interface{}{
                    path,
                    computeHash(path),
                    detectLanguage(path),
                    info.ModTime().Unix(),
                    boolToAtom(isTestFile(path)),
                },
            })
            return nil
        })
    
        return s.engine.AddFacts(facts)
    }
    ```
    
    ### Shard Integration
    
    ```go
    // internal/shards/reviewer/reviewer.go
    func (r *ReviewerShard) Execute(ctx context.Context, task string) error {
        // Query for files to review
        result, err := r.kernel.Query(ctx, `
            user_intent(_, _, /review, Target, _),
            file_topology(Target, _, _, _, _)
        `)
        if err != nil {
            return err
        }
    
        // Process each file
        for _, b := range result.Bindings {
            target := b["Target"].(string)
            r.reviewFile(target)
        }
    
        return nil
    }
    ```
    
    ---
    
    ## Testing with Mangle
    
    ### Test Setup
    
    ```go
    func setupTestEngine(t *testing.T) *mangle.Engine {
        cfg := mangle.DefaultConfig()
        cfg.AutoEval = true
    
        eng, err := mangle.NewEngine(cfg, nil)
        require.NoError(t, err)
    
        // Load test schema
        err = eng.LoadSchemaString(`
            Decl file_topology(Path, Hash, Lang, LastMod, IsTest).
            Decl user_intent(ID, Cat, Verb, Target, Constraint).
        `)
        require.NoError(t, err)
    
        return eng
    }
    ```
    
    ### Test Fact Insertion
    
    ```go
    func TestFactInsertion(t *testing.T) {
        eng := setupTestEngine(t)
    
        err := eng.AddFact("file_topology", "test.go", "hash", "/go", 123, "/true")
        assert.NoError(t, err)
    
        facts, err := eng.GetFacts("file_topology")
        assert.NoError(t, err)
        assert.Len(t, facts, 1)
    }
    ```
    
    ### Test Derivation
    
    ```go
    func TestNextActionDerivation(t *testing.T) {
        eng := setupTestEngine(t)
    
        // Load policy
        err := eng.LoadSchemaString(`
            Decl test_state(State).
            Decl next_action(Action).
    
            next_action(/read_error_log) :- test_state(/failing).
        `)
        require.NoError(t, err)
    
        // Add fact
        err = eng.AddFact("test_state", "/failing")
        require.NoError(t, err)
    
        // Query derived fact
        result, err := eng.Query(context.Background(), "next_action(Action)")
        require.NoError(t, err)
        require.Len(t, result.Bindings, 1)
        assert.Equal(t, "/read_error_log", result.Bindings[0]["Action"])
    }
    ```
    
    ---
    
    ## Performance Optimization
    
    ### Batch Inserts
    
    ```go
    // BAD: Individual inserts with auto-eval
    for _, file := range files {
        eng.AddFact("file_topology", ...) // Triggers recomputation each time
    }
    
    // GOOD: Batch with controlled eval
    eng.ToggleAutoEval(false)
    facts := make([]mangle.Fact, len(files))
    for i, file := range files {
        facts[i] = mangle.Fact{...}
    }
    eng.AddFacts(facts)
    eng.ToggleAutoEval(true)
    eng.RecomputeRules()
    ```
    
    ### Fact Limits
    
    ```go
    // Monitor fact count
    stats := eng.GetStats()
    if stats.TotalFacts > 80000 {
        log.Printf("WARNING: Approaching fact limit (80k/100k)")
    }
    
    // Prune old facts if needed
    eng.ReplaceFactsForFile("old-file.go", nil) // Remove facts
    ```
    
    ### Query Timeouts
    
    ```go
    // Set timeout in context
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    result, err := eng.Query(ctx, "complex_query(X)")
    if err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            log.Printf("Query timed out")
        }
    }
    ```
    
    ---
    
    ## Debugging
    
    ### Enable Debug Logging
    
    ```go
    import "codenerd/internal/logging"
    
    logging.Get(logging.CategoryKernel).SetLevel(logging.LevelDebug)
    ```
    
    ### Dump All Facts
    
    ```go
    stats := eng.GetStats()
    for pred := range stats.PredicateCounts {
        facts, _ := eng.GetFacts(pred)
        for _, f := range facts {
            fmt.Printf("%s(%v)\n", f.Predicate, f.Args)
        }
    }
    ```
    
    ### Trace Derivation
    
    ```go
    // Add instrumentation facts
    eng.AddFact("debug_trace", "/enabled")
    
    // Query to see what derived
    result, _ := eng.Query(ctx, "next_action(Action)")
    if len(result.Bindings) == 0 {
        // No derivation - check intermediate facts
        result, _ = eng.Query(ctx, "test_state(State)")
        fmt.Printf("Test state: %v\n", result.Bindings)
    }
    ```
    
    ---
    
    ## Best Practices
    
    1. **Load Schema First**: Always load schemas before adding facts
    2. **Batch When Possible**: Use `ToggleAutoEval(false)` for bulk inserts
    3. **Type Safety**: Use explicit `/atom` syntax for enums
    4. **Error Handling**: Always check errors from AddFact/Query
    5. **Resource Limits**: Monitor fact count and derived fact gas
    6. **Persistence**: Use persistence layer for production
    7. **Testing**: Write unit tests for fact derivation logic
    8. **Debugging**: Use debug logging and fact dumps for troubleshooting
    
    ---
    
    ## See Also
    
    - [schemas.md](schemas.md) - Predicate declarations
    - [fact_patterns.md](fact_patterns.md) - Creating facts
    - [query_patterns.md](query_patterns.md) - Query examples
    - [validation_rules.md](validation_rules.md) - Common errors
