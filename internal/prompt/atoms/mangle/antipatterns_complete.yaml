# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: antipatterns_complete.md

- id: "language/mangle/docs/antipatterns_complete"
  category: "language"
  subcategory: "mangle"
  description: "Mangle Anti-Patterns - Complete Error Catalog"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle Anti-Patterns - Complete Error Catalog
    
    ## Top 30 AI Failure Modes
    
    ### 1. Atom vs String Confusion (CRITICAL - Silent Failure)
    
    **WRONG**:
    ```mangle
    status(User, "active").
    active_users(U) :- status(U, "active").
    ```
    
    **CORRECT**:
    ```mangle
    status(User, /active).
    active_users(U) :- status(U, /active).
    ```
    
    **Why**: `/atom` and `"string"` are different types and NEVER unify. Using wrong type causes silent failure (no errors, just empty results).
    
    **Rule**: Use `/atom` for identifiers, enums, statuses. Use `"string"` only for human-readable text.
    
    ---
    
    ### 2. Aggregation Syntax - SQL Style (HIGH FREQUENCY)
    
    **WRONG**:
    ```mangle
    region_sales(Region, Total) :-
        sales(Region, Amount),
        Total = sum(Amount).  # SQL mental model
    ```
    
    **CORRECT**:
    ```mangle
    region_sales(Region, Total) :-
        sales(Region, Amount) |>
        do fn:group_by(Region),
        let Total = fn:Sum(Amount).
    ```
    
    **Why**: Mangle requires explicit pipeline syntax with `|>`, `do`, `let` keywords.
    
    ---
    
    ### 3. Aggregation - Missing `do` Keyword
    
    **WRONG**:
    ```mangle
    total(K, S) :-
        item(K, V) |>
        fn:group_by(K),  # Missing 'do'!
        let S = fn:Sum(V).
    ```
    
    **CORRECT**:
    ```mangle
    total(K, S) :-
        item(K, V) |>
        do fn:group_by(K),
        let S = fn:Sum(V).
    ```
    
    ---
    
    ### 4. Wrong Aggregation Function Casing
    
    **WRONG**:
    ```mangle
    ... let N = fn:count().
    ... let S = fn:sum(X).
    ... let M = fn:max(X).
    ```
    
    **CORRECT**:
    ```mangle
    ... let N = fn:Count().
    ... let S = fn:Sum(X).
    ... let M = fn:Max(X).
    ```
    
    **Why**: Capital letters required: `Count`, `Sum`, `Min`, `Max`. Lowercase `group_by`.
    
    ---
    
    ### 5. Type Declaration - Soufflé Syntax
    
    **WRONG**:
    ```mangle
    .decl dependency(app: string, lib: string)
    ```
    
    **CORRECT**:
    ```mangle
    Decl dependency(App.Type<string>, Lib.Type<string>).
    ```
    
    **Why**: Mangle uses `Decl` (capital D) with `Arg.Type<type>` syntax.
    
    ---
    
    ### 6. Type Declaration - Missing Type<> Wrapper
    
    **WRONG**:
    ```mangle
    Decl person(Name.string, Age.int).
    ```
    
    **CORRECT**:
    ```mangle
    Decl person(Name.Type<string>, Age.Type<int>).
    ```
    
    ---
    
    ### 7. Unbound Variable in Negation (CRITICAL)
    
    **WRONG**:
    ```mangle
    non_admin(User) :- not admin(User).  # User unbound!
    ```
    
    **CORRECT**:
    ```mangle
    non_admin(User) :- user(User), not admin(User).
    #                  ^^^^^^^^^^^ Generator predicate
    ```
    
    **Why**: Variables in negated atoms MUST be bound by positive atoms first. Bottom-up evaluation cannot iterate over "all possible users."
    
    ---
    
    ### 8. Negation After Binding (Order Matters)
    
    **WRONG**:
    ```mangle
    bad(X, Y) :- foo(X), not bar(Y).  # Y unbound when negation evaluated
    ```
    
    **CORRECT**:
    ```mangle
    good(X, Y) :- foo(X), candidate(Y), not bar(Y).
    ```
    
    ---
    
    ### 9. Stratification Violation - Direct Negative Cycle
    
    **WRONG**:
    ```mangle
    bad(X) :- not bad(X).  # Direct self-negation
    ```
    
    **Why**: No stable truth value - violates stratification.
    
    ---
    
    ### 10. Stratification Violation - Game Theory Cycle
    
    **WRONG**:
    ```mangle
    winning(X) :- move(X, Y), losing(Y).
    losing(X) :- not winning(X).  # Cycle through negation!
    ```
    
    **CORRECT**:
    ```mangle
    # Add terminal condition
    losing(X) :- position(X), not has_move(X).
    has_move(X) :- move(X, _).
    winning(X) :- move(X, Y), losing(Y).
    ```
    
    ---
    
    ### 11. Infinite Recursion - Counter Generation
    
    **WRONG**:
    ```mangle
    next_id(ID) :- current_id(Old), ID = fn:plus(Old, 1).
    current_id(ID) :- next_id(ID).
    # Generates 1, 2, 3, ... forever!
    ```
    
    **CORRECT**:
    ```mangle
    # Bounded by finite domain
    reachable(X, Y) :- edge(X, Y).
    reachable(X, Z) :- edge(X, Y), reachable(Y, Z).
    # Terminates when all paths explored
    ```
    
    ---
    
    ### 12. Cartesian Product Explosion
    
    **WRONG**:
    ```mangle
    # 10K × 10K = 100M intermediate results
    slow(X, Y) :-
        table1(X),    # 10,000 rows
        table2(Y),    # 10,000 rows
        filter(X, Y). # 1,000 matches
    ```
    
    **CORRECT**:
    ```mangle
    # Only 1,000 checks
    fast(X, Y) :-
        filter(X, Y),  # 1,000 matches first
        table1(X),
        table2(Y).
    ```
    
    ---
    
    ### 13. Struct Field Access - Dot Notation
    
    **WRONG**:
    ```mangle
    bad(Name) :- record.name = Name.
    bad(Name) :- record(R), R.name = Name.
    ```
    
    **CORRECT**:
    ```mangle
    good(Name) :-
        record(R),
        :match_field(R, /name, Name).
    ```
    
    ---
    
    ### 14. Struct Field Access - Direct Pattern Match
    
    **WRONG**:
    ```mangle
    bad(Name) :- record({/name: Name}).
    ```
    
    **CORRECT**:
    ```mangle
    good(Name) :-
        record(R),
        :match_field(R, /name, Name).
    ```
    
    ---
    
    ### 15. List Indexing - Array Style
    
    **WRONG**:
    ```mangle
    first(List[0]).
    head(List, List[0]).
    ```
    
    **CORRECT**:
    ```mangle
    first(List, Head) :- :match_cons(List, Head, _).
    # OR
    first(List, Head) :- Head = fn:list:get(List, 0).
    ```
    
    ---
    
    ### 16. Missing Period Terminator
    
    **WRONG**:
    ```mangle
    parent(/a, /b)
    rule(X) :- foo(X)
    ```
    
    **CORRECT**:
    ```mangle
    parent(/a, /b).
    rule(X) :- foo(X).
    ```
    
    ---
    
    ### 17. Lowercase Variables (Prolog Style)
    
    **WRONG**:
    ```mangle
    ancestor(x, y) :- parent(x, y).
    ```
    
    **CORRECT**:
    ```mangle
    ancestor(X, Y) :- parent(X, Y).
    ```
    
    ---
    
    ### 18. Block Comments
    
    **WRONG**:
    ```mangle
    /* This is a comment */
    ```
    
    **CORRECT**:
    ```mangle
    # This is a comment
    # Multi-line comments
    # use multiple single-line
    ```
    
    ---
    
    ### 19. Hallucinated Functions - String Operations
    
    **WRONG**:
    ```mangle
    result(Sub) :- text(T), Sub = fn:substring(T, 0, 5).
    result(M) :- text(T), M = fn:regex("\\d+", T).
    result(Parts) :- text(T), Parts = fn:split(T, ",").
    ```
    
    **Why**: These functions DON'T EXIST in Mangle. Limited string support.
    
    **Actual**: Only `fn:string_concat`, `fn:string_length`, `fn:string_contains` exist.
    
    ---
    
    ### 20. Hallucinated Functions - Date/Time
    
    **WRONG**:
    ```mangle
    current(T) :- T = fn:now().
    date(D) :- D = fn:date(2024, 1, 1).
    ```
    
    **Why**: NO date/time functions in Mangle.
    
    ---
    
    ### 21. NULL/Unknown Handling (Open World Bias)
    
    **WRONG**:
    ```mangle
    handle(X, Status) :-
        item(X),
        Status = case
            when known(X, S) then S
            else /unknown.  # No case/else in Mangle!
    ```
    
    **CORRECT**:
    ```mangle
    # Closed World Assumption
    known(X) :- known_status(X, _).
    unknown(X) :- item(X), not known(X).
    ```
    
    **Why**: Mangle uses Closed World Assumption - a fact either exists (true) or doesn't (false). No NULL/UNKNOWN.
    
    ---
    
    ### 22. Go Integration - String-Based API
    
    **WRONG**:
    ```go
    store.Add("parent", "alice", "bob")
    ```
    
    **CORRECT**:
    ```go
    alice, _ := ast.Name("alice")
    bob, _ := ast.Name("bob")
    fact := ast.NewAtom("parent", alice, bob)
    store.Add(fact)
    ```
    
    ---
    
    ### 23. Go Integration - Skipping Parse
    
    **WRONG**:
    ```go
    result := engine.Run("ancestor(X, Y) :- parent(X, Y).")
    ```
    
    **CORRECT**:
    ```go
    unit, _ := parse.Unit(strings.NewReader(source))
    programInfo, _ := analysis.AnalyzeOneUnit(unit, nil)
    engine.EvalProgram(programInfo, store)
    ```
    
    ---
    
    ### 24. Go Integration - Ignoring Binding Patterns
    
    **WRONG**:
    ```go
    func myPred(query ast.Atom, cb func(ast.Atom) error) error {
        // Always assumes bound
        path := query.Args[0].(ast.Constant).StringValue()
        // Panics if Args[0] is Variable!
    }
    ```
    
    **CORRECT**:
    ```go
    func myPred(query ast.Atom, cb func(ast.Atom) error) error {
        switch arg := query.Args[0].(type) {
        case ast.Constant:
            path := arg.StringValue()
        case ast.Variable:
            // Enumerate or error
        }
    }
    ```
    
    ---
    
    ### 25. Unsafe Head Variables
    
    **WRONG**:
    ```mangle
    result(X, Y) :- other(X).  # Y unbound in head!
    ```
    
    **CORRECT**:
    ```mangle
    result(X, Y) :- other(X), source(Y).
    # OR
    result(X, Y) :- other(X), Y = 42.
    ```
    
    ---
    
    ### 26. Anonymous Variable Misuse
    
    **WRONG**:
    ```mangle
    # Using _ when value needed later
    rule(X) :- foo(X, _), bar(_, Y).  # Lost binding!
    ```
    
    **CORRECT**:
    ```mangle
    rule(X, Y) :- foo(X, Y), bar(Y, Z).
    ```
    
    ---
    
    ### 27. Multiple Rule Definitions (Misunderstanding Union)
    
    **WRONG** (thinking they overwrite):
    ```mangle
    p(X) :- a(X).  # Thinks this overwrites next line
    p(X) :- b(X).
    ```
    
    **CORRECT** (understanding union):
    ```mangle
    p(X) :- a(X).
    p(X) :- b(X).
    # p is true if a OR b is true (union semantics)
    ```
    
    ---
    
    ### 28. Type Mismatch - Int vs Float
    
    **WRONG**:
    ```mangle
    Decl score(Player.Type<n>, Points.Type<float>).
    score(/alice, 100).  # 100 is int, not float!
    ```
    
    **CORRECT**:
    ```mangle
    score(/alice, 100.0).  # Use 100.0 for float
    ```
    
    ---
    
    ### 29. Duplicate Rule Heads (Thinking First Wins)
    
    **WRONG** (thinking first rule takes precedence):
    ```mangle
    result(X) :- fast_check(X).
    result(X) :- slow_check(X).  # Thinks this never executes
    ```
    
    **CORRECT** (understanding all rules fire):
    ```mangle
    # Both rules execute, results are unioned
    result(X) :- fast_check(X).
    result(X) :- slow_check(X).
    # If slow_check derives something not in fast_check, it's included
    ```
    
    ---
    
    ### 30. Slopsquatting - Package Hallucination
    
    **WRONG**:
    ```mangle
    use /std/date.
    use /std/regex.
    use /std/http.
    ```
    
    **Why**: These packages DON'T EXIST. Mangle has minimal standard library.
    
    **Actual**: Only core builtin predicates and functions exist (see builtins_complete.md).
    
    ---
    
    ## Detection Checklist
    
    Before committing Mangle code, check:
    
    - [ ] All atoms use `/slash` syntax, not `"quotes"`
    - [ ] All aggregations use `|> do fn:group_by() let Result = fn:Agg()`
    - [ ] All negations have variables bound by positive atoms first
    - [ ] All variables in rule heads appear in positive body atoms
    - [ ] All statements end with period (`.`)
    - [ ] All variables are UPPERCASE
    - [ ] All type declarations use `Decl Arg.Type<type>` syntax
    - [ ] No hallucinated functions (check builtins_complete.md)
    - [ ] No stratification cycles (check with dependency graph)
    - [ ] No infinite recursion (all recursion bounded by finite domain)
    - [ ] No Cartesian products (selective predicates first)
    - [ ] Struct/map access uses `:match_field`, not dot notation
    - [ ] Go integration uses proper AST types, not strings
    
    ## Common Repair Patterns
    
    ### Fix Atom/String Confusion
    ```mangle
    # Find all string literals that should be atoms
    status(User, "active").  # WRONG
    # Replace with:
    status(User, /active).   # CORRECT
    ```
    
    ### Fix Aggregation
    ```mangle
    # Find SQL-style aggregation
    total(K, S) :- item(K, V), S = sum(V).  # WRONG
    # Replace with:
    total(K, S) :- item(K, V) |> do fn:group_by(K), let S = fn:Sum(V).
    ```
    
    ### Fix Unbound Negation
    ```mangle
    # Find negation without generator
    bad(X) :- not foo(X).  # WRONG
    # Add generator predicate:
    good(X) :- candidate(X), not foo(X).
    ```
    
    ### Fix Stratification
    ```mangle
    # Find negative cycles
    p(X) :- not q(X).
    q(X) :- not p(X).  # WRONG
    # Add base cases:
    p(X) :- base_p(X).
    q(X) :- base_q(X).
    p(X) :- intermediate(X), not q(X).
    ```
    
    ### Fix Go Type Errors
    ```go
    // Find string-based APIs
    store.Add("pred", "arg1", "arg2")  // WRONG
    // Replace with:
    arg1, _ := ast.Name("arg1")
    arg2, _ := ast.Name("arg2")
    fact := ast.NewAtom("pred", arg1, arg2)
    store.Add(fact)
    ```
