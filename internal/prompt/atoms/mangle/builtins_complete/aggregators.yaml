# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: builtins_complete/aggregators.md

- id: "language/mangle/docs/builtins_complete/aggregators"
  category: "language"
  subcategory: "mangle"
  description: "Mangle Builtin Aggregators: Complete Reference"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle Builtin Aggregators: Complete Reference
    
    ## Overview
    
    Aggregators are **reducer functions** that operate on groups of values. They are used in **transform blocks** with the `|>` operator.
    
    ### Aggregators vs Functions
    
    | Aspect | Regular Functions | Aggregators |
    |--------|------------------|-------------|
    | **Syntax** | `fn:plus(X, Y)` | `fn:Sum(X)` |
    | **Usage** | Rule body | Transform block (`|>`) |
    | **Input** | Individual values | Groups of values |
    | **Output** | Single value | Single value per group |
    | **Context** | Per fact | Per group |
    
    ---
    
    ## Transform Block Syntax
    
    ```mangle
    predicate(Result) :-
        base_predicate(X)
        |> do fn:group_by(GroupVar1, GroupVar2, ...),
           let Result = fn:Aggregator(X).
    ```
    
    **Components**:
    - `|>` - Pipe operator (starts transform)
    - `do fn:group_by(...)` - Defines grouping variables
    - `let Result = fn:Aggregator(...)` - Applies aggregator
    
    ---
    
    ## Numeric Aggregators
    
    ### fn:Sum
    
    **Signature**: `fn:Sum(NumberExpr) → Number`
    
    **Purpose**: Sums all numeric values in a group.
    
    **Examples**:
    ```mangle
    # Total of all values
    total(T) :-
        item(X)
        |> do fn:group_by(),
           let T = fn:Sum(X).
    
    # Sum by category
    category_total(Cat, Total) :-
        item(Cat, Value)
        |> do fn:group_by(Cat),
           let Total = fn:Sum(Value).
    
    # Sum of computed values
    price_total(Total) :-
        item(Quantity, Price)
        |> do fn:group_by(),
           let ItemCost = fn:mult(Quantity, Price),
           let Total = fn:Sum(ItemCost).
    ```
    
    **Type**: Works with integers. Use `fn:FloatSum` for floats.
    
    ---
    
    ### fn:FloatSum
    
    **Signature**: `fn:FloatSum(FloatExpr) → Float`
    
    **Purpose**: Sums all floating-point values in a group.
    
    **Examples**:
    ```mangle
    # Total with floating-point precision
    precise_total(T) :-
        measurement(X)
        |> do fn:group_by(),
           let T = fn:FloatSum(X).
    
    # Average price (using FloatSum)
    avg_price(Avg) :-
        item(Price)
        |> do fn:group_by(),
           let Total = fn:FloatSum(Price),
           let Count = fn:Count(),
           let Avg = fn:float_div(Total, Count).
    ```
    
    ---
    
    ### fn:Max
    
    **Signature**: `fn:Max(NumberExpr) → Number`
    
    **Purpose**: Finds the maximum value in a group.
    
    **Examples**:
    ```mangle
    # Maximum value
    max_value(M) :-
        data(X)
        |> do fn:group_by(),
           let M = fn:Max(X).
    
    # Maximum per category
    category_max(Cat, Max) :-
        item(Cat, Value)
        |> do fn:group_by(Cat),
           let Max = fn:Max(Value).
    
    # Oldest person per city
    oldest_age(City, Age) :-
        person(Name, Age, City)
        |> do fn:group_by(City),
           let Age = fn:Max(Age).
    ```
    
    ---
    
    ### fn:FloatMax
    
    **Signature**: `fn:FloatMax(FloatExpr) → Float`
    
    **Purpose**: Finds the maximum floating-point value in a group.
    
    **Examples**:
    ```mangle
    # Maximum temperature
    max_temp(T) :-
        temperature(T)
        |> do fn:group_by(),
           let Max = fn:FloatMax(T).
    ```
    
    ---
    
    ### fn:Min
    
    **Signature**: `fn:Min(NumberExpr) → Number`
    
    **Purpose**: Finds the minimum value in a group.
    
    **Examples**:
    ```mangle
    # Minimum value
    min_value(M) :-
        data(X)
        |> do fn:group_by(),
           let M = fn:Min(X).
    
    # Minimum per category
    category_min(Cat, Min) :-
        item(Cat, Value)
        |> do fn:group_by(Cat),
           let Min = fn:Min(Value).
    
    # Cheapest item per department
    cheapest_price(Dept, Price) :-
        product(Dept, Item, Price)
        |> do fn:group_by(Dept),
           let Price = fn:Min(Price).
    ```
    
    ---
    
    ### fn:FloatMin
    
    **Signature**: `fn:FloatMin(FloatExpr) → Float`
    
    **Purpose**: Finds the minimum floating-point value in a group.
    
    ---
    
    ### fn:Avg
    
    **Signature**: `fn:Avg(NumberExpr) → Number`
    
    **Purpose**: Computes the average (mean) of values in a group.
    
    **Examples**:
    ```mangle
    # Average of all values
    average(A) :-
        data(X)
        |> do fn:group_by(),
           let A = fn:Avg(X).
    
    # Average per category
    category_avg(Cat, Avg) :-
        item(Cat, Value)
        |> do fn:group_by(Cat),
           let Avg = fn:Avg(Value).
    
    # Average age per city
    avg_age(City, Avg) :-
        person(Name, Age, City)
        |> do fn:group_by(City),
           let Avg = fn:Avg(Age).
    ```
    
    **Note**: The return type and rounding behavior are not explicitly documented.
    
    ---
    
    ## Counting Aggregators
    
    ### fn:Count
    
    **Signature**: `fn:Count() → Number` or `fn:Count(Expr) → Number`
    
    **Purpose**: Counts the number of items in a group (including duplicates).
    
    **Examples**:
    ```mangle
    # Count all items
    total_count(C) :-
        item(X)
        |> do fn:group_by(),
           let C = fn:Count().
    
    # Count per category
    category_count(Cat, Count) :-
        item(Cat, Value)
        |> do fn:group_by(Cat),
           let Count = fn:Count().
    
    # Count with expression
    count_positive(C) :-
        data(X),
        X > 0
        |> do fn:group_by(),
           let C = fn:Count().
    
    # Count people per city
    city_population(City, Pop) :-
        person(Name, City)
        |> do fn:group_by(City),
           let Pop = fn:Count().
    ```
    
    **Variants**:
    - `fn:Count()` - Counts rows in group
    - `fn:Count(Expr)` - Counts non-null values of expression
    
    ---
    
    ### fn:CountDistinct
    
    **Signature**: `fn:CountDistinct(Expr) → Number`
    
    **Purpose**: Counts the number of **distinct** (unique) values in a group.
    
    **Examples**:
    ```mangle
    # Count distinct values
    unique_count(C) :-
        data(X)
        |> do fn:group_by(),
           let C = fn:CountDistinct(X).
    
    # Count distinct items per category
    category_variety(Cat, Variety) :-
        item(Cat, Value)
        |> do fn:group_by(Cat),
           let Variety = fn:CountDistinct(Value).
    
    # How many different cities do people live in?
    city_count(C) :-
        person(Name, City)
        |> do fn:group_by(),
           let C = fn:CountDistinct(City).
    ```
    
    **Comparison**:
    ```mangle
    # If data has: item(1), item(1), item(2), item(2), item(3)
    
    # fn:Count() → 5 (all items)
    # fn:CountDistinct() → 3 (unique values: 1, 2, 3)
    ```
    
    ---
    
    ## Collection Aggregators
    
    ### fn:Collect
    
    **Signature**: `fn:Collect(Expr) → List`
    
    **Purpose**: Collects all values (including duplicates) into a list.
    
    **Examples**:
    ```mangle
    # Collect all values into list
    all_values(L) :-
        data(X)
        |> do fn:group_by(),
           let L = fn:Collect(X).
    
    # Collect values per category
    category_values(Cat, Values) :-
        item(Cat, Value)
        |> do fn:group_by(Cat),
           let Values = fn:Collect(Value).
    
    # List of all ages for each city
    city_ages(City, Ages) :-
        person(Name, Age, City)
        |> do fn:group_by(City),
           let Ages = fn:Collect(Age).
    ```
    
    **Order**: The order of elements in the resulting list is not guaranteed.
    
    ---
    
    ### fn:CollectDistinct
    
    **Signature**: `fn:CollectDistinct(Expr) → List`
    
    **Purpose**: Collects **unique** values into a list (removes duplicates).
    
    **Examples**:
    ```mangle
    # Collect unique values
    unique_values(L) :-
        data(X)
        |> do fn:group_by(),
           let L = fn:CollectDistinct(X).
    
    # Unique values per category
    category_unique(Cat, Unique) :-
        item(Cat, Value)
        |> do fn:group_by(Cat),
           let Unique = fn:CollectDistinct(Value).
    
    # List of unique cities
    all_cities(Cities) :-
        person(Name, City)
        |> do fn:group_by(),
           let Cities = fn:CollectDistinct(City).
    ```
    
    **Comparison**:
    ```mangle
    # If data has: item(1), item(1), item(2), item(2), item(3)
    
    # fn:Collect() → [1, 1, 2, 2, 3] (all values)
    # fn:CollectDistinct() → [1, 2, 3] (unique only)
    ```
    
    ---
    
    ### fn:CollectToMap
    
    **Signature**: `fn:CollectToMap(KeyExpr, ValueExpr) → Map`
    
    **Purpose**: Collects key-value pairs into a map.
    
    **Examples**:
    ```mangle
    # Create map from key-value pairs
    name_age_map(M) :-
        person(Name, Age)
        |> do fn:group_by(),
           let M = fn:CollectToMap(Name, Age).
    
    # Map per category
    category_map(Cat, M) :-
        item(Cat, Key, Value)
        |> do fn:group_by(Cat),
           let M = fn:CollectToMap(Key, Value).
    ```
    
    **Duplicate Keys**: If multiple values exist for the same key, behavior is not documented (likely last-write-wins or error).
    
    ---
    
    ## Grouping
    
    ### fn:group_by
    
    **Signature**: `fn:group_by(Var1, Var2, ..., VarN)`
    
    **Purpose**: Defines which variables to group by.
    
    **Behavior**:
    - Variables listed are used as grouping keys
    - One result per unique combination of grouping variables
    - Empty `fn:group_by()` means one global group (all facts together)
    
    **Examples**:
    ```mangle
    # No grouping - single global group
    total(T) :-
        item(X)
        |> do fn:group_by(),
           let T = fn:Sum(X).
    
    # Group by one variable
    category_total(Cat, Total) :-
        item(Cat, Value)
        |> do fn:group_by(Cat),
           let Total = fn:Sum(Value).
    
    # Group by multiple variables
    city_age_count(City, Age, Count) :-
        person(Name, Age, City)
        |> do fn:group_by(City, Age),
           let Count = fn:Count().
    ```
    
    **Important**: All grouping variables MUST be bound before the transform block.
    
    ---
    
    ## Multiple Aggregators
    
    You can compute multiple aggregators in one transform:
    
    ```mangle
    # Statistics per category
    category_stats(Cat, Total, Avg, Min, Max, Count) :-
        item(Cat, Value)
        |> do fn:group_by(Cat),
           let Total = fn:Sum(Value),
           let Avg = fn:Avg(Value),
           let Min = fn:Min(Value),
           let Max = fn:Max(Value),
           let Count = fn:Count().
    ```
    
    ---
    
    ## Computed Expressions in Aggregators
    
    You can aggregate over computed expressions:
    
    ```mangle
    # Sum of products
    revenue(Total) :-
        sale(Quantity, Price)
        |> do fn:group_by(),
           let Revenue = fn:mult(Quantity, Price),
           let Total = fn:Sum(Revenue).
    
    # Average of complex expression
    avg_score(Avg) :-
        test(Reading, Writing, Math)
        |> do fn:group_by(),
           let TotalScore = fn:plus(Reading, fn:plus(Writing, Math)),
           let Avg = fn:Avg(TotalScore).
    ```
    
    ---
    
    ## Transform Chains
    
    You can chain transforms (though this is advanced):
    
    ```mangle
    # First transform, then another
    result(R) :-
        data(X)
        |> do fn:group_by(Cat),
           let SubTotal = fn:Sum(X)
        |> do fn:group_by(),
           let R = fn:Sum(SubTotal).
    ```
    
    This is equivalent to a two-level aggregation.
    
    ---
    
    ## Common Pitfalls
    
    ### Unbound Grouping Variables
    
    ```mangle
    # ERROR: Cat is not bound before transform
    bad(Cat, Total) :-
        item(Value)
        |> do fn:group_by(Cat),  # Cat never bound!
           let Total = fn:Sum(Value).
    ```
    
    **Fix**: Bind all grouping variables:
    ```mangle
    good(Cat, Total) :-
        item(Cat, Value)  # Cat is now bound
        |> do fn:group_by(Cat),
           let Total = fn:Sum(Value).
    ```
    
    ### Aggregating Without Grouping
    
    ```mangle
    # What this does: Creates ONE global sum
    total(T) :-
        item(Cat, Value)
        |> do fn:group_by(),  # Empty = one group
           let T = fn:Sum(Value).
    ```
    
    This is valid and useful for global aggregates.
    
    ### Type Mismatches
    
    ```mangle
    # ERROR: Can't sum strings
    bad(T) :-
        name(N)
        |> do fn:group_by(),
           let T = fn:Sum(N).  # N is a string!
    ```
    
    ---
    
    ## Aggregator Summary Table
    
    | Aggregator | Input Type | Output Type | Purpose |
    |------------|------------|-------------|---------|
    | `fn:Sum` | number | number | Sum integers |
    | `fn:FloatSum` | float | float | Sum floats |
    | `fn:Max` | number | number | Maximum integer |
    | `fn:FloatMax` | float | float | Maximum float |
    | `fn:Min` | number | number | Minimum integer |
    | `fn:FloatMin` | float | float | Minimum float |
    | `fn:Avg` | number | number | Average |
    | `fn:Count` | any | number | Count all |
    | `fn:CountDistinct` | any | number | Count unique |
    | `fn:Collect` | any | list | Collect all |
    | `fn:CollectDistinct` | any | list | Collect unique |
    | `fn:CollectToMap` | (any, any) | map | Build map |
    
    ---
    
    ## Real-World Examples
    
    ### Sales Analysis
    
    ```mangle
    # Total revenue by product
    product_revenue(Product, Revenue) :-
        sale(Product, Quantity, Price)
        |> do fn:group_by(Product),
           let ItemRevenue = fn:mult(Quantity, Price),
           let Revenue = fn:Sum(ItemRevenue).
    
    # Average order value
    avg_order_value(Avg) :-
        order(OrderId, Total)
        |> do fn:group_by(),
           let Avg = fn:Avg(Total).
    ```
    
    ### People Analytics
    
    ```mangle
    # People per city with age stats
    city_stats(City, Pop, MinAge, MaxAge, AvgAge) :-
        person(Name, Age, City)
        |> do fn:group_by(City),
           let Pop = fn:Count(),
           let MinAge = fn:Min(Age),
           let MaxAge = fn:Max(Age),
           let AvgAge = fn:Avg(Age).
    ```
    
    ### Data Quality
    
    ```mangle
    # How many distinct values per field?
    field_cardinality(Field, Distinct, Total) :-
        data_value(Field, Value)
        |> do fn:group_by(Field),
           let Distinct = fn:CountDistinct(Value),
           let Total = fn:Count().
    ```
