# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: builtins_complete/functions_lists.md

- id: "language/mangle/docs/builtins_complete/functions_lists"
  category: "language"
  subcategory: "mangle"
  description: "Mangle Builtin Functions: List Operations"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle Builtin Functions: List Operations
    
    ## List Construction
    
    ### fn:list
    
    **Signature**: `fn:list(Elem1, ..., ElemN) → List`
    
    **Purpose**: Constructs a list from individual elements.
    
    **Examples**:
    ```mangle
    # Create list of three elements
    numbers(L) :- L = fn:list(1, 2, 3).
    
    # Equivalent to bracket notation
    numbers(L) :- L = [1, 2, 3].
    
    # Dynamic list creation
    pair_list(L) :- a(X), b(Y), L = fn:list(X, Y).
    ```
    
    **Note**: Bracket notation `[...]` is syntactic sugar for `fn:list(...)`.
    
    ---
    
    ### fn:cons
    
    **Signature**: `fn:cons(Head, Tail) → List`
    
    **Purpose**: Prepends an element to the front of a list (LISP-style cons).
    
    **Examples**:
    ```mangle
    # Add element to front
    prepend(NewList) :- existing_list(L), NewList = fn:cons(0, L).
    
    # Build list incrementally
    build_list([]).
    build_list(L) :-
        build_list(SubList),
        length(SubList, Len),
        Len < 10,
        L = fn:cons(Len, SubList).
    
    # Reconstruct from head and tail
    reconstruct(L) :- :match_cons(L, H, T), NewL = fn:cons(H, T).  # Identity
    ```
    
    **Relationship**: `fn:cons` is the constructor; `:match_cons` is the deconstructor.
    
    ```mangle
    # These are inverses:
    :match_cons(fn:cons(H, T), H, T).  # Always true
    fn:cons(H, T) when :match_cons(L, H, T).  # Reconstructs L
    ```
    
    ---
    
    ### Empty List
    
    **Syntax**: `[]`
    
    **Purpose**: Represents an empty list.
    
    **Examples**:
    ```mangle
    # Base case for recursion
    sum_list([], 0).
    
    # Check emptiness
    is_empty(L) :- L = [].
    
    # Alternative using :match_nil
    is_empty(L) :- :match_nil(L).
    ```
    
    ---
    
    ## List Access
    
    ### fn:list:get
    
    **Signature**: `fn:list:get(List, Index) → Element`
    
    **Type**: `(list, number) → any`
    
    **Purpose**: Retrieves the element at position Index (0-indexed).
    
    **Examples**:
    ```mangle
    # Get first element (index 0)
    first(E) :- data(L), E = fn:list:get(L, 0).
    
    # Get second element
    second(E) :- data(L), E = fn:list:get(L, 1).
    
    # Get element at variable index
    nth_element(L, N, E) :- E = fn:list:get(L, N).
    ```
    
    **Indexing**: 0-based (first element is index 0).
    
    **Error Behavior**: If index is out of bounds, likely fails or errors (not documented).
    
    **Alternative**: For head, use `:match_cons` pattern matching.
    
    ---
    
    ### fn:len (Length)
    
    **Signature**: `fn:len(List) → Number`
    
    **Type**: `(list) → number`
    
    **Purpose**: Returns the number of elements in a list.
    
    **Examples**:
    ```mangle
    # Get list length
    list_size(S) :- data(L), S = fn:len(L).
    
    # Check if list has specific size
    has_three_elements(L) :- data(L), fn:len(L) = 3.
    
    # Filter by size
    small_list(L) :- data(L), Size = fn:len(L), Size < 5.
    
    # Empty check using length
    is_empty(L) :- data(L), fn:len(L) = 0.
    ```
    
    **Complexity**: O(n) - must traverse the entire list.
    
    ---
    
    ## List Operations
    
    ### fn:append
    
    **Signature**: `fn:append(List1, List2) → List3`
    
    **Type**: `(list, list) → list`
    
    **Purpose**: Concatenates two lists.
    
    **Examples**:
    ```mangle
    # Join two lists
    combined(C) :- first(L1), second(L2), C = fn:append(L1, L2).
    
    # Add element to end (inefficient)
    append_one(NewL) :- data(L), NewL = fn:append(L, [1]).
    
    # Build longer list
    extend(Extended) :-
        base([1, 2, 3]),
        addition([4, 5]),
        Extended = fn:append(base, addition).  # [1, 2, 3, 4, 5]
    ```
    
    **Performance**: O(n) where n is length of first list.
    
    **Note**: Adding to end is inefficient. Prefer `fn:cons` to add to front.
    
    ---
    
    ### fn:list_contains
    
    **Signature**: `fn:list_contains(List, Element) → Boolean`
    
    **Type**: `(list, any) → bool`
    
    **Purpose**: Checks if an element exists in the list.
    
    **Examples**:
    ```mangle
    # Check membership
    contains_zero(L) :- data(L), fn:list_contains(L, 0).
    
    # Filter lists containing specific value
    has_target(L) :- data(L), fn:list_contains(L, /target).
    ```
    
    **Alternative**: Use recursive pattern matching:
    ```mangle
    contains(L, X) :- :match_cons(L, X, _).
    contains(L, X) :- :match_cons(L, _, T), contains(T, X).
    ```
    
    ---
    
    ## List Processing Patterns
    
    ### Recursive List Processing
    
    **Sum of list**:
    ```mangle
    sum_list([], 0).
    sum_list(L, Sum) :-
        :match_cons(L, H, T),
        sum_list(T, SubSum),
        Sum = fn:plus(H, SubSum).
    ```
    
    **Find maximum**:
    ```mangle
    max_list([X], X).
    max_list(L, Max) :-
        :match_cons(L, H, T),
        max_list(T, MaxTail),
        H > MaxTail,
        Max = H.
    max_list(L, Max) :-
        :match_cons(L, H, T),
        max_list(T, MaxTail),
        H <= MaxTail,
        Max = MaxTail.
    ```
    
    **Filter list**:
    ```mangle
    filter_positive([], []).
    filter_positive(L, Filtered) :-
        :match_cons(L, H, T),
        H > 0,
        filter_positive(T, FilteredTail),
        Filtered = fn:cons(H, FilteredTail).
    filter_positive(L, Filtered) :-
        :match_cons(L, H, T),
        H <= 0,
        filter_positive(T, Filtered).
    ```
    
    ### List Iteration
    
    **Process each element**:
    ```mangle
    # Create fact for each list element
    element_fact(E) :- data(L), :match_cons(L, E, _).
    element_fact(E) :- data(L), :match_cons(L, _, T), element_fact_helper(T, E).
    
    element_fact_helper(L, E) :- :match_cons(L, E, _).
    element_fact_helper(L, E) :- :match_cons(L, _, T), element_fact_helper(T, E).
    ```
    
    **Alternative using indices**:
    ```mangle
    # If you know the list length
    element_at_0(E) :- data(L), E = fn:list:get(L, 0).
    element_at_1(E) :- data(L), E = fn:list:get(L, 1).
    # ... etc
    ```
    
    ---
    
    ## List Aggregation
    
    For aggregating over list elements, use transform blocks:
    
    ```mangle
    # Sum all elements in all lists
    total_sum(Sum) :-
        data(L),
        :match_cons(L, E, _)
        |> do fn:group_by(),
           let Sum = fn:Sum(E).
    
    # Count all elements across all lists
    total_count(Count) :-
        data(L),
        :match_cons(L, E, _)
        |> do fn:group_by(),
           let Count = fn:Count(E).
    ```
    
    **Note**: This aggregates across multiple lists. For single-list aggregation, use recursion.
    
    ---
    
    ## Nested Lists
    
    **Access nested elements**:
    ```mangle
    # List of lists
    nested([[1, 2], [3, 4], [5, 6]]).
    
    # Get first inner list
    first_inner(Inner) :-
        nested(Outer),
        Inner = fn:list:get(Outer, 0).  # [1, 2]
    
    # Get first element of first inner list
    first_of_first(E) :-
        nested(Outer),
        Inner = fn:list:get(Outer, 0),
        E = fn:list:get(Inner, 0).  # 1
    ```
    
    ---
    
    ## List Comparison
    
    **Equality**: Two lists are equal if they have the same elements in the same order.
    
    ```mangle
    # Check list equality
    same_list(L1, L2) :- data(L1), data(L2), L1 = L2.
    
    # Check list inequality
    different_list(L1, L2) :- data(L1), data(L2), L1 != L2.
    ```
    
    ---
    
    ## Common Pitfalls
    
    ### Building Lists Backwards
    
    ```mangle
    # WRONG: Builds list in reverse order
    build_wrong([]).
    build_wrong(L) :-
        build_wrong(SubList),
        # Problem: cons prepends, so builds backwards
        L = fn:cons(new_element, SubList).
    ```
    
    **Fix**: Either reverse at the end or append (though append is inefficient).
    
    ### Infinite List Generation
    
    ```mangle
    # DANGEROUS: Infinite list
    infinite_list([]).
    infinite_list(L) :-
        infinite_list(SubList),
        L = fn:cons(1, SubList).  # Never terminates!
    ```
    
    **Fix**: Add bounds:
    ```mangle
    # SAFE: Bounded list
    bounded_list([], 0).
    bounded_list(L, N) :-
        N > 0,
        N < 100,  # Upper bound
        M = fn:minus(N, 1),
        bounded_list(SubList, M),
        L = fn:cons(N, SubList).
    ```
    
    ### Inefficient Append
    
    ```mangle
    # INEFFICIENT: O(n²) complexity
    build_slow([]).
    build_slow(L) :-
        build_slow(SubList),
        L = fn:append(SubList, [new_element]).  # Expensive!
    ```
    
    **Better**: Use cons and reverse, or build differently.
    
    ---
    
    ## List Functions Summary
    
    | Function | Arguments | Return | Purpose |
    |----------|-----------|--------|---------|
    | `fn:list` | (elem, ..., elem) | list | Construct list |
    | `fn:cons` | (elem, list) | list | Prepend element |
    | `fn:append` | (list, list) | list | Concatenate lists |
    | `fn:len` | (list) | number | List length |
    | `fn:list:get` | (list, number) | any | Get element at index |
    | `fn:list_contains` | (list, any) | bool | Check membership |
    
    **Related Predicates**:
    - `:match_cons(list, head, tail)` - Deconstruct list
    - `:match_nil(list)` - Check empty list
    - `[] `- Empty list constant
