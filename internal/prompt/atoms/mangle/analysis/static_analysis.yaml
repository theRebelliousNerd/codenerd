# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: analysis/static_analysis.md

- id: "language/mangle/docs/analysis/static_analysis"
  category: "language"
  subcategory: "mangle"
  description: "Mangle Analysis: Static Analysis Rules"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle Analysis: Static Analysis Rules
    
    ## Overview
    
    The `analysis` package provides static analysis of Mangle programs BEFORE execution. This catches errors early and ensures programs are well-formed.
    
    ## Analysis Pipeline
    
    Static analysis happens in stages:
    
    1. **Parsing** - Convert text to AST
    2. **Declaration analysis** - Check predicate declarations
    3. **Rule checking** - Verify safety and arity
    4. **Stratification** - Check negation dependencies
    5. **Type checking** (optional) - Verify type bounds
    
    ## AnalyzeOneUnit
    
    The main entry point for analyzing a source unit:
    
    ```go
    import "github.com/google/mangle/analysis"
    
    // Analyze a parsed unit
    analyzed, err := analysis.AnalyzeOneUnit(parsedUnit)
    if err != nil {
        // Analysis found errors
        log.Printf("Analysis failed: %v", err)
    }
    ```
    
    This performs:
    - Declaration processing
    - Rule safety checking
    - Arity verification
    - Dependency analysis
    
    ## Declaration Analysis
    
    ### Desugaring Declarations
    
    Declarations may contain syntactic sugar that needs expansion:
    
    ```mangle
    Decl person(Name, Age)
      bounds [ /string, /number ].
    ```
    
    The analyzer **desugars** this into primitive type bounds.
    
    ### Declaration Errors
    
    **Missing declarations**:
    ```mangle
    # ERROR: person not declared
    result(X) :- person(X, Y).
    ```
    
    Fix: Add declaration
    ```mangle
    Decl person(Name, Age).
    result(X) :- person(X, Y).
    ```
    
    **Arity mismatch**:
    ```mangle
    Decl person(Name, Age).  # Arity 2
    
    # ERROR: Wrong arity (3 instead of 2)
    result(X) :- person(X, Y, Z).
    ```
    
    Fix: Use correct arity
    ```mangle
    result(X) :- person(X, Y).
    ```
    
    ## Rule Safety Analysis
    
    The analyzer checks every rule for **safety constraints**:
    
    1. All head variables are bound in body
    2. Variables in negation are bound before negation
    3. Variables in inequality are bound
    4. Function applications have correct arity
    
    See `safety_checks.md` for detailed safety rules.
    
    ## Arity Checking
    
    Every predicate and function use is checked for **correct arity**:
    
    ### Predicate Arity
    
    ```mangle
    Decl parent(Person, Child).  # Arity 2
    
    # VALID
    ancestor(X, Y) :- parent(X, Y).
    
    # INVALID - arity mismatch
    ancestor(X, Y, Z) :- parent(X, Y).  # Wrong: head has arity 3
    ```
    
    ### Function Arity
    
    ```mangle
    # fn:plus has arity 2
    
    # VALID
    sum(X) :- a(A), b(B), X = fn:plus(A, B).
    
    # INVALID
    sum(X) :- a(A), X = fn:plus(A).  # Missing second argument
    ```
    
    ## Dependency Analysis
    
    The analyzer builds a **dependency graph**:
    
    - **Nodes**: Predicates (IDB predicates defined by rules)
    - **Edges**: Dependencies between predicates
    - **Negative edges**: Dependencies through negation
    
    ### Uses of Dependency Graph
    
    1. **Stratification checking** - Detect cycles through negation
    2. **Evaluation ordering** - Determine which predicates to compute first
    3. **SCC identification** - Find mutually recursive groups
    
    ### Example Dependency Graph
    
    ```mangle
    # Rules
    ancestor(X, Y) :- parent(X, Y).
    ancestor(X, Z) :- ancestor(X, Y), parent(Y, Z).
    unrelated(X, Y) :- person(X), person(Y), not ancestor(X, Y).
    ```
    
    **Dependencies**:
    - `ancestor` → `parent` (positive)
    - `ancestor` → `ancestor` (positive, recursive)
    - `unrelated` → `person` (positive)
    - `unrelated` → `ancestor` (negative)
    
    **Graph**:
    ```
    parent (EDB)
      ↓
    ancestor ←┐ (recursive)
      │       │
      └───────┘
      ↓ (negation)
    unrelated
    ```
    
    ## Type Checking
    
    Optional type checking verifies that facts match declared type bounds.
    
    ### NewTypeChecker
    
    ```go
    import "github.com/google/mangle/builtin"
    
    // Create type checker from declarations
    typeChecker, err := builtin.NewTypeChecker(decls)
    if err != nil {
        log.Printf("Invalid declarations: %v", err)
    }
    ```
    
    ### CheckTypeBounds
    
    ```go
    // Check a fact against type bounds
    err := typeChecker.CheckTypeBounds(fact)
    if err != nil {
        log.Printf("Type error: %v", err)
    }
    ```
    
    ### Type Bound Examples
    
    ```mangle
    Decl person(Name, Age)
      bounds [ /string, /number ].
    
    # VALID
    person("Alice", 30).
    
    # INVALID - age is string, not number
    person("Bob", "twenty").
    ```
    
    The type checker catches this **before evaluation**.
    
    ## Mode Checking
    
    If mode declarations are present, the analyzer checks:
    
    1. **Input arguments** are bound before predicate use
    2. **Output arguments** are bound after predicate succeeds
    3. **Bidirectional arguments** work correctly
    
    ### Mode Example
    
    ```mangle
    Decl parent(Person, Child)
      descr [mode(+, -)].  # Input, Output
    ```
    
    **VALID**:
    ```mangle
    # X is bound, Y will be bound by parent
    has_child(X) :- person(X), parent(X, Y).
    ```
    
    **INVALID**:
    ```mangle
    # X is not bound before parent - violates mode(+, -)
    has_child(Y) :- parent(X, Y).
    ```
    
    ## Extensional vs Intensional
    
    The analyzer distinguishes:
    
    - **EDB (Extensional)** - Facts provided as input, no rules
    - **IDB (Intensional)** - Predicates defined by rules
    
    ### Extensional Descriptor
    
    ```mangle
    Decl base_data(X, Y)
      descr [extensional()].
    ```
    
    This means:
    - No rules can define `base_data`
    - Only facts can be asserted
    - Used for input data
    
    If you write a rule for an extensional predicate → **ERROR**
    
    ## Deferred Predicates
    
    Some predicates are marked `deferred`:
    
    ```mangle
    Decl lookup(Key, Value)
      descr [deferred()].
    ```
    
    This affects:
    - **Input-only** arguments must be bound
    - Used for external data sources
    - Evaluation strategy may differ
    
    ## Functional Dependencies
    
    Functional dependencies (fundep) declare uniqueness:
    
    ```mangle
    Decl employee(ID, Name, Salary)
      descr [fundep([/id], [/name, /salary])].
    ```
    
    This means: "Same ID → Same Name and Salary"
    
    The analyzer can use this for:
    - Optimization (uniqueness guarantees)
    - Integrity checking
    - Query planning
    
    ## Analysis Errors
    
    Common static analysis errors:
    
    ### Safety Violations
    
    ```
    Error: Variable X appears in head but is not bound in body
    Error: Variable Y in negated atom is not bound
    Error: Variable Z appears only in inequality
    ```
    
    ### Arity Mismatches
    
    ```
    Error: Predicate 'person' expects 2 arguments, got 3
    Error: Function 'fn:plus' expects 2 arguments, got 1
    ```
    
    ### Stratification Failures
    
    ```
    Error: Cannot stratify program - cycle through negation detected
    Error: Predicate 'p' recursively depends on its own negation
    ```
    
    ### Type Errors
    
    ```
    Error: Expected /number for argument 2, got /string
    Error: Type bounds violated for predicate 'person'
    ```
    
    ## Optimization Opportunities
    
    The analyzer identifies optimization opportunities:
    
    1. **Constant folding** - Evaluate `fn:plus(2, 3)` at compile time
    2. **Dead code** - Predicates never used
    3. **Selectivity** - Which atoms should be evaluated first
    4. **Join ordering** - Optimal order for rule evaluation
    
    These are used by the engine for efficient evaluation.
    
    ## Best Practices
    
    1. **Always declare predicates** - Don't rely on implicit declarations
    2. **Use type bounds** - Catch errors early
    3. **Document modes** - Make input/output expectations clear
    4. **Check analysis errors** - Fix before running
    5. **Run analyzer in CI** - Catch errors before deployment
    
    ## Analysis in the Build Pipeline
    
    ```go
    // Complete analysis pipeline
    func analyzeProgram(source string) error {
        // 1. Parse
        unit, err := parse.Unit(source)
        if err != nil {
            return fmt.Errorf("parse error: %w", err)
        }
    
        // 2. Analyze
        analyzed, err := analysis.AnalyzeOneUnit(unit)
        if err != nil {
            return fmt.Errorf("analysis error: %w", err)
        }
    
        // 3. Stratify (if using negation)
        _, _, err = analysis.Stratify(analyzed)
        if err != nil {
            return fmt.Errorf("stratification error: %w", err)
        }
    
        // 4. Type check (optional)
        typeChecker, err := builtin.NewTypeChecker(analyzed.Decls)
        if err != nil {
            return fmt.Errorf("type checker error: %w", err)
        }
    
        // Ready for evaluation
        return nil
    }
    ```
    
    This ensures programs are correct BEFORE execution, catching most errors at compile time rather than runtime.
