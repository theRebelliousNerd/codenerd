# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: advanced/migration.md

- id: "language/mangle/docs/advanced/migration"
  category: "language"
  subcategory: "mangle"
  description: "Migrating to Mangle from Other Logic Languages"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Migrating to Mangle from Other Logic Languages
    
    ## From Soufflé
    
    Soufflé is a high-performance Datalog variant. Mangle shares many concepts but has different syntax.
    
    ### Declaration Syntax
    
    #### Soufflé
    ```souffle
    .decl edge(x:number, y:number)
    .decl path(x:number, y:number)
    ```
    
    #### Mangle
    ```mangle
    Decl edge(X.Type<int>, Y.Type<int>).
    Decl path(X.Type<int>, Y.Type<int>).
    ```
    
    **Changes**:
    - `.decl` → `Decl` (capitalized, no dot)
    - `x:number` → `X.Type<int>` (uppercase variable, explicit type syntax)
    - `:` → `.` separator
    - `number` → `int` (or `float`)
    
    ### Variables
    
    #### Soufflé
    ```souffle
    path(x, y) :- edge(x, y).
    ```
    
    #### Mangle
    ```mangle
    path(X, Y) :- edge(X, Y).
    ```
    
    **Change**: Variables must be UPPERCASE.
    
    ### Facts
    
    #### Soufflé
    ```souffle
    edge(1, 2).
    edge(2, 3).
    ```
    
    #### Mangle
    ```mangle
    edge(1, 2).
    edge(2, 3).
    ```
    
    **Same!** ✓
    
    ### Atoms (Symbols)
    
    #### Soufflé
    ```souffle
    .decl status(id:symbol, status:symbol)
    status("user1", "active").
    ```
    
    #### Mangle
    ```mangle
    Decl status(Id.Type<string>, Status.Type<atom>).
    status("user1", /active).
    ```
    
    **Changes**:
    - Soufflé `symbol` can be string OR atom
    - Mangle distinguishes `string` (quoted) from `atom` (starts with `/`)
    
    ### Negation
    
    #### Soufflé
    ```souffle
    not_manager(id) :- employee(id, _), !manager(id).
    ```
    
    #### Mangle
    ```mangle
    not_manager(Id) :- employee(Id, _), not manager(Id).
    ```
    
    **Change**: `!` → `not`
    
    ### Aggregation
    
    #### Soufflé
    ```souffle
    dept_total(dept, sum salary) :-
        employee(_, dept, salary).
    ```
    
    #### Mangle
    ```mangle
    dept_total(Dept, Total) :-
      employee(_, Dept, Salary)
      |> do fn:group_by(Dept),
      let Total = fn:sum(Salary).
    ```
    
    **Changes**:
    - Soufflé has inline aggregation syntax
    - Mangle uses explicit pipe `|>` and `fn:sum()`
    
    ### Subsumption (Max/Min)
    
    #### Soufflé
    ```souffle
    .decl cheapest(product:symbol, price:number)
    cheapest(product, min price) :- item(product, price).
    ```
    
    #### Mangle
    ```mangle
    Decl cheapest(Product.Type<atom>, Price.Type<int>).
    
    cheapest(Product, Price) :-
      item(Product, P)
      |> do fn:group_by(Product),
      let Price = fn:min(P).
    ```
    
    ### Records (Structs)
    
    #### Soufflé
    ```souffle
    .type Person = [name:symbol, age:number]
    .decl person(p:Person)
    person(["Alice", 30]).
    ```
    
    #### Mangle
    ```mangle
    Decl person(P.Type<struct>).
    person({ /name: "Alice", /age: 30 }).
    ```
    
    **Changes**:
    - Soufflé uses `[...]` for records
    - Mangle uses `{...}` with `/key: value` syntax
    
    ### Relations as Output
    
    #### Soufflé
    ```souffle
    .output path
    ```
    
    #### Mangle
    ```mangle
    # No explicit output declaration
    # Query any predicate directly
    ```
    
    ---
    
    ## From Prolog
    
    Prolog is a general-purpose logic language. Mangle is a pure Datalog subset.
    
    ### Facts and Rules
    
    #### Prolog
    ```prolog
    parent(tom, bob).
    parent(bob, ann).
    
    ancestor(X, Y) :- parent(X, Y).
    ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).
    ```
    
    #### Mangle
    ```mangle
    Decl parent(X.Type<atom>, Y.Type<atom>).
    Decl ancestor(X.Type<atom>, Y.Type<atom>).
    
    parent(/tom, /bob).
    parent(/bob, /ann).
    
    ancestor(X, Y) :- parent(X, Y).
    ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).
    ```
    
    **Changes**:
    - Must declare predicates with `Decl`
    - Atoms use `/` prefix
    - Variables must be UPPERCASE
    
    ### Lists
    
    #### Prolog
    ```prolog
    append([], L, L).
    append([H|T1], L2, [H|T3]) :- append(T1, L2, T3).
    ```
    
    #### Mangle
    ```mangle
    Decl append(L1.Type<list<int>>, L2.Type<list<int>>, Result.Type<list<int>>).
    
    append([], L, L).
    append(List, L2, Result) :-
      :match_cons(List, H, T1),
      append(T1, L2, T3),
      :cons(H, T3, Result).
    ```
    
    **Changes**:
    - List matching uses `:match_cons` instead of `[H|T]` syntax
    - List construction uses `:cons` instead of `[H|T]`
    
    ### Cut (!)
    
    #### Prolog
    ```prolog
    max(X, Y, X) :- X >= Y, !.
    max(X, Y, Y).
    ```
    
    #### Mangle
    ```mangle
    # Mangle does NOT support cut
    # Must use explicit conditions
    
    Decl max(X.Type<int>, Y.Type<int>, Result.Type<int>).
    
    max(X, Y, X) :- X >= Y.
    max(X, Y, Y) :- X < Y.
    ```
    
    **Change**: No `!` operator. Use explicit guards.
    
    ### Arithmetic
    
    #### Prolog
    ```prolog
    factorial(0, 1).
    factorial(N, F) :-
        N > 0,
        N1 is N - 1,
        factorial(N1, F1),
        F is N * F1.
    ```
    
    #### Mangle
    ```mangle
    Decl factorial(N.Type<int>, F.Type<int>).
    
    factorial(0, 1).
    factorial(N, F) :-
      N > 0,
      N1 = fn:minus(N, 1),
      factorial(N1, F1),
      F = fn:mult(N, F1).
    ```
    
    **Changes**:
    - `is` → `=`
    - `N - 1` → `fn:minus(N, 1)`
    - `N * F1` → `fn:mult(N, F1)`
    
    ### Findall
    
    #### Prolog
    ```prolog
    all_children(Parent, Children) :-
        findall(Child, parent(Parent, Child), Children).
    ```
    
    #### Mangle
    ```mangle
    Decl all_children(Parent.Type<atom>, Children.Type<list<atom>>).
    
    all_children(Parent, Children) :-
      parent(Parent, Child)
      |> do fn:group_by(Parent),
      let Children = fn:collect(Child).
    ```
    
    **Change**: Use aggregation with `fn:collect`.
    
    ### Assert/Retract
    
    #### Prolog
    ```prolog
    :- assert(new_fact(foo)).
    :- retract(old_fact(bar)).
    ```
    
    #### Mangle
    ```mangle
    # Mangle does NOT support assert/retract
    # Facts are immutable within a program
    # Add/remove facts in Go before evaluation
    ```
    
    ---
    
    ## From SQL
    
    SQL is declarative but procedural in execution. Mangle is pure logic.
    
    ### SELECT
    
    #### SQL
    ```sql
    SELECT name, age FROM users WHERE age > 25;
    ```
    
    #### Mangle
    ```mangle
    Decl user(Id.Type<atom>, Name.Type<string>, Age.Type<int>).
    Decl result(Name.Type<string>, Age.Type<int>).
    
    result(Name, Age) :-
      user(Id, Name, Age),
      Age > 25.
    ```
    
    ### JOIN
    
    #### SQL
    ```sql
    SELECT e.name, d.dept_name
    FROM employees e
    JOIN departments d ON e.dept_id = d.dept_id;
    ```
    
    #### Mangle
    ```mangle
    Decl employee(Id.Type<atom>, Name.Type<string>, DeptId.Type<atom>).
    Decl department(DeptId.Type<atom>, DeptName.Type<string>).
    Decl result(Name.Type<string>, DeptName.Type<string>).
    
    result(Name, DeptName) :-
      employee(Id, Name, DeptId),
      department(DeptId, DeptName).
    ```
    
    **Change**: Joins are implicit via shared variables.
    
    ### Aggregation
    
    #### SQL
    ```sql
    SELECT dept_id, SUM(salary) AS total
    FROM employees
    GROUP BY dept_id;
    ```
    
    #### Mangle
    ```mangle
    Decl employee(Id.Type<atom>, DeptId.Type<atom>, Salary.Type<int>).
    Decl dept_total(DeptId.Type<atom>, Total.Type<int>).
    
    dept_total(DeptId, Total) :-
      employee(Id, DeptId, Salary)
      |> do fn:group_by(DeptId),
      let Total = fn:sum(Salary).
    ```
    
    ### Subqueries
    
    #### SQL
    ```sql
    SELECT name FROM employees
    WHERE salary > (SELECT AVG(salary) FROM employees);
    ```
    
    #### Mangle
    ```mangle
    Decl employee(Id.Type<atom>, Name.Type<string>, Salary.Type<int>).
    Decl avg_salary(Avg.Type<float>).
    Decl high_earner(Name.Type<string>).
    
    avg_salary(Avg) :-
      employee(Id, Name, Salary)
      |> do fn:group_by(),
      let Avg = fn:mean(Salary).
    
    high_earner(Name) :-
      employee(Id, Name, Salary),
      avg_salary(Avg),
      fn:to_float(Salary) > Avg.
    ```
    
    **Change**: Break into multiple rules (stratification).
    
    ### NOT IN
    
    #### SQL
    ```sql
    SELECT id FROM users WHERE id NOT IN (SELECT user_id FROM banned);
    ```
    
    #### Mangle
    ```mangle
    Decl user(Id.Type<atom>).
    Decl banned(UserId.Type<atom>).
    Decl not_banned(Id.Type<atom>).
    
    not_banned(Id) :-
      user(Id),
      not banned(Id).
    ```
    
    ### HAVING
    
    #### SQL
    ```sql
    SELECT dept_id, COUNT(*) AS cnt
    FROM employees
    GROUP BY dept_id
    HAVING COUNT(*) > 10;
    ```
    
    #### Mangle
    ```mangle
    Decl employee(Id.Type<atom>, DeptId.Type<atom>).
    Decl large_dept(DeptId.Type<atom>, Count.Type<int>).
    
    large_dept(DeptId, Count) :-
      employee(Id, DeptId)
      |> do fn:group_by(DeptId),
      let Count = fn:count(Id),
      Count > 10.
    ```
    
    **Change**: Filter on aggregate result directly in rule body.
    
    ### UNION
    
    #### SQL
    ```sql
    SELECT name FROM employees
    UNION
    SELECT name FROM contractors;
    ```
    
    #### Mangle
    ```mangle
    Decl employee(Name.Type<string>).
    Decl contractor(Name.Type<string>).
    Decl all_workers(Name.Type<string>).
    
    all_workers(Name) :- employee(Name).
    all_workers(Name) :- contractor(Name).
    ```
    
    **Change**: Multiple rules create union automatically.
    
    ### UPDATE/DELETE
    
    #### SQL
    ```sql
    UPDATE users SET status = 'inactive' WHERE last_login < '2024-01-01';
    DELETE FROM users WHERE status = 'banned';
    ```
    
    #### Mangle
    ```mangle
    # Mangle does NOT support updates/deletes
    # Compute new state instead
    
    Decl user(Id.Type<atom>, Status.Type<atom>).
    Decl last_login(Id.Type<atom>, Date.Type<string>).
    Decl new_status(Id.Type<atom>, Status.Type<atom>).
    
    # Compute updated status
    new_status(Id, /inactive) :-
      user(Id, _),
      last_login(Id, Date),
      Date < "2024-01-01".
    
    new_status(Id, Status) :-
      user(Id, Status),
      last_login(Id, Date),
      Date >= "2024-01-01".
    ```
    
    ---
    
    ## Key Differences Summary
    
    | Feature | Soufflé | Prolog | SQL | Mangle |
    |---------|---------|--------|-----|--------|
    | **Variables** | lowercase | Uppercase | N/A | UPPERCASE |
    | **Atoms** | `symbol` | lowercase | VARCHAR | `/atom` |
    | **Negation** | `!` | `\+` | `NOT` | `not` |
    | **Aggregation** | `sum X` | `findall` | `SUM()` | `fn:sum()` |
    | **Lists** | `[H|T]` | `[H|T]` | N/A | `:match_cons` |
    | **Structs** | `[...]` | Compound terms | N/A | `{...}` |
    | **Cut** | N/A | `!` | N/A | Not supported |
    | **Update** | N/A | `assert/retract` | `UPDATE` | Not supported |
    
    ## Migration Checklist
    
    ### From Soufflé
    - [ ] Replace `.decl` with `Decl`
    - [ ] Uppercase all variables
    - [ ] Add `/` prefix to atoms (symbols)
    - [ ] Change `!` to `not`
    - [ ] Rewrite aggregations with `|>` and `fn:*`
    - [ ] Replace records `[...]` with structs `{...}`
    
    ### From Prolog
    - [ ] Add `Decl` declarations for all predicates
    - [ ] Uppercase all variables
    - [ ] Add `/` prefix to atoms
    - [ ] Remove `!` (cut), use explicit guards
    - [ ] Replace `is` with `=` and use `fn:*` functions
    - [ ] Replace `findall` with `fn:collect`
    - [ ] Rewrite list syntax: `[H|T]` → `:match_cons`
    - [ ] Remove `assert`/`retract` (immutable facts)
    
    ### From SQL
    - [ ] Rewrite `SELECT` as rules with filters
    - [ ] Rewrite `JOIN` as rules with shared variables
    - [ ] Rewrite `GROUP BY` with `|>` and `fn:group_by`
    - [ ] Rewrite `HAVING` as filters after aggregation
    - [ ] Rewrite `UNION` as multiple rules
    - [ ] Rewrite `NOT IN` as negation
    - [ ] Compute new state instead of `UPDATE`/`DELETE`
    
    ## Example: Full Migration (SQL → Mangle)
    
    ### SQL Schema and Query
    ```sql
    CREATE TABLE employees (id INT, name VARCHAR, dept_id INT, salary INT);
    CREATE TABLE departments (dept_id INT, dept_name VARCHAR);
    
    -- Find departments with average salary > $100k
    SELECT d.dept_name, AVG(e.salary) AS avg_sal
    FROM employees e
    JOIN departments d ON e.dept_id = d.dept_id
    GROUP BY d.dept_id, d.dept_name
    HAVING AVG(e.salary) > 100000;
    ```
    
    ### Mangle Equivalent
    ```mangle
    Decl employee(Id.Type<int>, Name.Type<string>, DeptId.Type<int>, Salary.Type<int>).
    Decl department(DeptId.Type<int>, DeptName.Type<string>).
    Decl high_avg_dept(DeptName.Type<string>, AvgSal.Type<float>).
    
    high_avg_dept(DeptName, AvgSal) :-
      employee(EId, EName, DeptId, Salary),
      department(DeptId, DeptName)
      |> do fn:group_by(DeptId, DeptName),
      let AvgSal = fn:mean(Salary),
      AvgSal > 100000.0.
    ```
    
    **Steps**:
    1. Declare predicates for tables
    2. Join via shared variable `DeptId`
    3. Group by department
    4. Compute average
    5. Filter with `HAVING` condition
