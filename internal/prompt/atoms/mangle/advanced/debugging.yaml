# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: advanced/debugging.md

- id: "language/mangle/docs/advanced/debugging"
  category: "language"
  subcategory: "mangle"
  description: "Debugging Mangle Programs"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Debugging Mangle Programs
    
    ## Common Debugging Scenarios
    
    1. **Rule doesn't fire** (expected facts not derived)
    2. **Too many results** (over-generation)
    3. **Infinite loop** (program never terminates)
    4. **Wrong results** (logic error)
    5. **Stratification error** (cyclic negation)
    6. **Type mismatch** (atom vs string confusion)
    
    ## Debugging Technique 1: Tracing
    
    Add trace predicates to track rule execution.
    
    ### Example: Debug Why Rule Doesn't Fire
    
    ```mangle
    Decl employee(Id.Type<atom>, Name.Type<string>, Dept.Type<atom>).
    Decl manager(Id.Type<atom>).
    Decl high_paid_manager(Id.Type<atom>).
    
    # Facts
    employee(/e1, "Alice", /eng).
    manager(/e1).
    
    # Rule that should fire but doesn't
    high_paid_manager(Id) :-
      employee(Id, Name, Dept),
      manager(Id),
      employee_salary(Id, Salary),  # Problem: this predicate doesn't exist!
      Salary > 100000.
    
    # Add trace predicates
    Decl trace_employee_check(Id.Type<atom>).
    Decl trace_manager_check(Id.Type<atom>).
    Decl trace_salary_check(Id.Type<atom>).
    
    trace_employee_check(Id) :- employee(Id, _, _).
    trace_manager_check(Id) :- manager(Id).
    trace_salary_check(Id) :- employee_salary(Id, _).
    
    # Query traces:
    # trace_employee_check(?Id) → {/e1}
    # trace_manager_check(?Id) → {/e1}
    # trace_salary_check(?Id) → {} (EMPTY! Missing data!)
    ```
    
    **Diagnosis**: `employee_salary` predicate has no facts.
    
    ## Debugging Technique 2: Incremental Rule Building
    
    Test each clause of a rule separately.
    
    ### Example
    ```mangle
    # Complex rule
    result(X) :-
      clause1(X),
      clause2(X),
      clause3(X),
      clause4(X).
    
    # Debug: Test each clause
    debug_clause1(X) :- clause1(X).
    debug_clause2(X) :- clause2(X).
    debug_clause3(X) :- clause3(X).
    debug_clause4(X) :- clause4(X).
    
    # Query each:
    # debug_clause1(?X) → {a, b, c}
    # debug_clause2(?X) → {a, b}
    # debug_clause3(?X) → {a}
    # debug_clause4(?X) → {} (EMPTY! Problem here!)
    ```
    
    **Diagnosis**: Clause 4 has no matching facts.
    
    ## Debugging Technique 3: Print Intermediate Values
    
    Add debug predicates that capture intermediate values.
    
    ### Example
    ```mangle
    Decl salary(Id.Type<atom>, Amount.Type<int>).
    salary(/e1, 80000).
    salary(/e2, 120000).
    
    # Rule with computation
    Decl bonus(Id.Type<atom>, Amount.Type<int>).
    bonus(Id, Bonus) :-
      salary(Id, Salary),
      Bonus = fn:mult(Salary, 0.1).  # 10% bonus
    
    # Debug: Capture intermediate values
    Decl debug_salary(Id.Type<atom>, Salary.Type<int>).
    debug_salary(Id, Salary) :- salary(Id, Salary).
    
    # Query:
    # debug_salary(?Id, ?Salary) → {/e1, 80000}, {/e2, 120000}
    # bonus(?Id, ?Bonus) → {/e1, 8000}, {/e2, 12000}
    
    # If bonus had wrong values, you'd check the computation step-by-step
    ```
    
    ## Debugging Technique 4: Count Results
    
    Check how many results each predicate produces.
    
    ### Example
    ```mangle
    Decl item(Id.Type<atom>).
    item(/i1). item(/i2). item(/i3).
    
    # Count items
    count_items(Count) :-
      item(Id)
      |> do fn:group_by(),
      let Count = fn:count(Id).
    
    # Query: count_items(?Count) → {3}
    # Expected 5 items? Missing data!
    ```
    
    ## Debugging Technique 5: Negation Debugging
    
    Negation failures are silent. Make them explicit.
    
    ### Example
    ```mangle
    Decl user(Id.Type<atom>).
    Decl active(Id.Type<atom>).
    Decl inactive(Id.Type<atom>).
    
    user(/u1). user(/u2).
    active(/u1).
    
    # Rule using negation
    inactive(Id) :-
      user(Id),
      not active(Id).
    
    # Query: inactive(?Id) → {/u2}
    
    # Debug: Check what's being negated
    Decl debug_active(Id.Type<atom>).
    debug_active(Id) :- active(Id).
    
    # Query: debug_active(?Id) → {/u1}
    # So negation should succeed for /u2 ✓
    ```
    
    ### Example: Negation Not Working
    ```mangle
    # BUG: Expected inactive users, got none
    inactive_users(Id) :-
      not active(Id),  # WRONG: Id is unbound!
      user(Id).
    
    # Fix: Bind Id first
    inactive_users_fixed(Id) :-
      user(Id),
      not active(Id).
    ```
    
    ## Debugging Technique 6: Stratification Check
    
    If you get a stratification error, build a dependency graph.
    
    ### Example
    ```mangle
    # Stratification error
    p(X) :- not q(X).
    q(X) :- r(X).
    r(X) :- not p(X).  # Cycle!
    
    # Dependency graph:
    # p → q → r → p (cycle with negation)
    ```
    
    **Fix**: Break the cycle (see `stratification_deep.md`).
    
    ## Debugging Technique 7: Query with Specific Values
    
    Instead of querying with wildcards, test specific values.
    
    ### Example
    ```mangle
    Decl edge(From.Type<atom>, To.Type<atom>).
    edge(/a, /b).
    edge(/b, /c).
    
    Decl path(From.Type<atom>, To.Type<atom>).
    path(X, Y) :- edge(X, Y).
    path(X, Z) :- edge(X, Y), path(Y, Z).
    
    # General query (might be slow)
    # path(?X, ?Y) → {/a, /b}, {/b, /c}, {/a, /c}
    
    # Specific query (faster, more focused)
    # path(/a, /c) → TRUE (exists)
    # path(/c, /a) → FALSE (doesn't exist)
    ```
    
    ## Debugging Technique 8: Check Variable Binding
    
    Ensure all variables are bound before use.
    
    ### Example
    ```mangle
    # BUG: X is used before being bound
    bad_rule(X) :-
      Y = fn:plus(X, 1),  # X is unbound here!
      data(X).
    
    # Fix: Bind X first
    good_rule(X) :-
      data(X),            # Bind X
      Y = fn:plus(X, 1).  # Now X is bound
    ```
    
    ## Debugging Technique 9: Visualize Data Flow
    
    For complex rules, trace which facts lead to which derived facts.
    
    ### Example
    ```mangle
    Decl a(X.Type<int>).
    Decl b(X.Type<int>).
    Decl c(X.Type<int>).
    
    a(1). a(2).
    b(2). b(3).
    
    c(X) :- a(X), b(X).
    
    # Data flow:
    # a(1) + b(?) → no match
    # a(2) + b(2) → c(2) ✓
    # a(?) + b(3) → no match
    #
    # Result: c(2)
    ```
    
    **Visualization**:
    ```
    a(1) ────┐
             ├──X──> (no match)
    b(2) ────┘
    
    a(2) ────┐
             ├──X──> c(2) ✓
    b(2) ────┘
    
    a(?) ────┐
             ├──X──> (no match)
    b(3) ────┘
    ```
    
    ## Debugging Technique 10: Minimize Failing Case
    
    If a query returns wrong results, create a minimal test case.
    
    ### Example: Complex Rule Fails
    ```mangle
    # Complex rule with 10 clauses
    big_rule(X) :-
      clause1(X), clause2(X), clause3(X), clause4(X), clause5(X),
      clause6(X), clause7(X), clause8(X), clause9(X), clause10(X).
    
    # Minimize: Test with just 2 clauses
    minimal_test(X) :-
      clause1(X), clause2(X).
    
    # If this works, add clause3:
    minimal_test2(X) :-
      clause1(X), clause2(X), clause3(X).
    
    # Continue until you find the failing clause
    ```
    
    ## Common Bugs and Fixes
    
    ### Bug 1: Atom vs. String Confusion
    ```mangle
    # BUG: "active" is a string, should be /active (atom)
    user_status(Id, "active") :- active_user(Id).
    
    # FIX
    user_status(Id, /active) :- active_user(Id).
    ```
    
    ### Bug 2: Missing Base Case
    ```mangle
    # BUG: No base case, infinite recursion
    path(X, Z) :- edge(X, Y), path(Y, Z).
    
    # FIX: Add base case
    path(X, Y) :- edge(X, Y).
    path(X, Z) :- edge(X, Y), path(Y, Z).
    ```
    
    ### Bug 3: Wrong Variable Scope
    ```mangle
    # BUG: Name is local to first clause, not available in second
    get_name(Id, Name) :- user(Id, Name).
    get_email(Id, Email) :- contact(Name, Email).  # Name is unbound!
    
    # FIX: Thread variable through
    get_user_email(Id, Email) :-
      user(Id, Name),
      contact(Name, Email).
    ```
    
    ### Bug 4: Cartesian Product
    ```mangle
    # BUG: Generates all pairs of users and products
    purchases(User, Product) :-
      user(User),
      product(Product).  # WRONG: No relationship!
    
    # FIX: Use actual purchase relation
    purchases(User, Product) :-
      purchase_record(User, Product).
    ```
    
    ### Bug 5: Empty Aggregation
    ```mangle
    # BUG: If no employees, no result (expected 0)
    total_salary(Total) :-
      employee(Id, Salary)
      |> do fn:group_by(),
      let Total = fn:sum(Salary).
    
    # FIX: Provide default
    total_salary(Total) :- total_salary_agg(Total).
    total_salary(0) :- not total_salary_agg(_).
    
    total_salary_agg(Total) :-
      employee(Id, Salary)
      |> do fn:group_by(),
      let Total = fn:sum(Salary).
    ```
    
    ## Logging and Instrumentation
    
    ### Go-Side Logging
    
    ```go
    func DebugPredicate(query engine.Query, cb func(engine.Fact)) error {
        log.Printf("DebugPredicate called with args: %v", query.Args)
    
        // Process query
        result := computeResult(query)
    
        log.Printf("DebugPredicate returning %d results", len(result))
    
        for _, fact := range result {
            cb(fact)
        }
    
        return nil
    }
    ```
    
    ### Mangle-Side Trace Facts
    
    ```mangle
    Decl trace(Rule.Type<atom>, Step.Type<atom>, Value.Type<string>).
    
    # Add trace facts in rules
    complex_rule(X) :-
      clause1(X),
      trace(/complex_rule, /clause1_passed, fn:to_string(X)),
      clause2(X),
      trace(/complex_rule, /clause2_passed, fn:to_string(X)),
      clause3(X).
    
    # Query traces to see execution path
    # trace(?Rule, ?Step, ?Value)
    ```
    
    ## Debugging Checklist
    
    - [ ] All variables are bound before use
    - [ ] Base cases exist for recursive rules
    - [ ] Negation is safe (variables bound before `not`)
    - [ ] No cyclic negation (stratification valid)
    - [ ] Atoms use `/` prefix, strings use `"`
    - [ ] Aggregations handle empty input
    - [ ] Functions receive correct argument types
    - [ ] Expected facts exist in database
    - [ ] Query is using correct predicate names
    - [ ] Rules have periods (`.`) at the end
    
    ## Interactive Debugging Session Example
    
    ```mangle
    # Problem: Why doesn't high_value_customer/1 produce any results?
    
    Decl customer(Id.Type<atom>).
    Decl purchase(CustomerId.Type<atom>, Amount.Type<int>).
    Decl high_value_customer(Id.Type<atom>).
    
    customer(/c1).
    customer(/c2).
    purchase(/c1, 100).
    purchase(/c1, 200).
    
    # Rule
    high_value_customer(Id) :-
      customer(Id),
      total_spent(Id, Total),
      Total > 500.
    
    total_spent(Id, Total) :-
      purchase(Id, Amount)
      |> do fn:group_by(Id),
      let Total = fn:sum(Amount).
    
    # Debug session:
    # Query: customer(?Id)
    # Result: {/c1, /c2}  ✓
    
    # Query: purchase(?Id, ?Amt)
    # Result: {/c1, 100}, {/c1, 200}  ✓
    
    # Query: total_spent(?Id, ?Total)
    # Result: {/c1, 300}  ✓
    
    # Query: total_spent(/c1, ?Total), ?Total > 500
    # Result: {} (300 is not > 500)
    
    # DIAGNOSIS: Threshold too high! Customer has $300, not $500+
    ```
    
    **Fix**: Lower threshold or add more purchase data.
    
    ## Tools
    
    ### 1. Query REPL (if available)
    ```
    mangle> customer(?Id)
    {/c1, /c2}
    
    mangle> total_spent(?Id, ?Total)
    {/c1, 300}
    ```
    
    ### 2. Fact Inspector
    ```go
    // Dump all facts
    for _, fact := range store.AllFacts() {
        fmt.Printf("%s(%s)\n", fact.Predicate, formatArgs(fact.Args))
    }
    ```
    
    ### 3. Rule Coverage
    Track which rules fired:
    ```mangle
    Decl rule_fired(RuleName.Type<atom>).
    
    rule1(X) :-
      clause(X),
      rule_fired(/rule1).
    
    rule2(X) :-
      clause(X),
      rule_fired(/rule2).
    
    # Query: rule_fired(?Name)
    # See which rules actually executed
    ```
    
    ## Summary
    
    | Problem | Debugging Technique |
    |---------|---------------------|
    | Rule doesn't fire | Trace each clause, check fact existence |
    | Too many results | Count results, check for Cartesian products |
    | Infinite loop | Check recursion base case, add depth limit |
    | Wrong results | Test clauses incrementally, log intermediate values |
    | Stratification error | Build dependency graph, find cycles |
    | Type mismatch | Check atom (`/x`) vs. string (`"x"`) |
    | Negation fails | Ensure variables bound before `not` |
    | Empty results | Check aggregation, provide defaults |
