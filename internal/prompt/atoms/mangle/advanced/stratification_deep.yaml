# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: advanced/stratification_deep.md

- id: "language/mangle/docs/advanced/stratification_deep"
  category: "language"
  subcategory: "mangle"
  description: "Mangle Stratification: Complete Theory"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle Stratification: Complete Theory
    
    ## What is Stratification?
    
    **Stratification** is a property of logic programs that determines whether they have a well-defined, unique minimal model in the presence of **negation**.
    
    **Key Insight**: You cannot compute a predicate that depends on its own negation.
    
    ## The Problem: Cyclic Negation
    
    ### Example: The Liar's Paradox
    ```mangle
    # This statement is false.
    false(X) :- not false(X).
    ```
    
    **Question**: Is `false(/statement)` true or false?
    - If true, then `not false(/statement)` is false, so the rule makes it false. Contradiction.
    - If false, then `not false(/statement)` is true, so the rule makes it true. Contradiction.
    
    **Mangle's response**: This program is **not stratified** and will be **rejected** at compile time.
    
    ## Stratification Definition
    
    A program is **stratified** if you can partition predicates into **layers** (strata) such that:
    
    1. **Positive dependencies** can go to the same or lower strata
    2. **Negative dependencies** can ONLY go to strictly lower strata
    
    ### Dependency Types
    
    - **Positive dependency**: `p(X) :- q(X).` → p depends positively on q
    - **Negative dependency**: `p(X) :- not q(X).` → p depends negatively on q
    
    ## Stratification Algorithm
    
    ### Step 1: Build Dependency Graph
    
    Nodes = Predicates
    Edges = Dependencies (labeled + or -)
    
    #### Example Program
    ```mangle
    Decl a(X.Type<int>).
    Decl b(X.Type<int>).
    Decl c(X.Type<int>).
    Decl d(X.Type<int>).
    
    # Rules
    a(X) :- b(X).           # a → b (positive)
    b(X) :- c(X).           # b → c (positive)
    c(X) :- not d(X).       # c → d (negative)
    d(X) :- data(X).        # d → data (positive)
    ```
    
    **Dependency graph**:
    ```
    a --+-> b --+-> c --(-)--> d --+-> data
    ```
    
    ### Step 2: Detect Cycles with Negative Edges
    
    **Stratified** ⇔ No cycles contain a negative edge
    
    In the example above:
    - No cycles exist → **Stratified** ✅
    
    **Strata assignment**:
    1. Stratum 0: `data` (base facts)
    2. Stratum 1: `d`
    3. Stratum 2: `c`
    4. Stratum 3: `b`
    5. Stratum 4: `a`
    
    ### Step 3: Evaluation Order
    
    Evaluate strata from lowest to highest:
    1. Compute stratum 0 (base facts)
    2. Compute stratum 1 (can use stratum 0)
    3. Compute stratum 2 (can use strata 0-1, negation safe)
    4. ...and so on
    
    ## Examples: Stratified Programs
    
    ### Example 1: Safe Negation
    ```mangle
    Decl employee(Id.Type<atom>, Name.Type<string>).
    Decl manager(Id.Type<atom>).
    Decl non_manager(Id.Type<atom>).
    
    # Base facts (stratum 0)
    employee(/e1, "Alice").
    employee(/e2, "Bob").
    manager(/e1).
    
    # Stratum 1: manager (no dependencies)
    # (already base facts)
    
    # Stratum 2: non_manager (depends negatively on manager)
    non_manager(Id) :-
      employee(Id, Name),
      not manager(Id).
    ```
    
    **Dependency graph**:
    ```
    employee (stratum 0)
    manager (stratum 0)
    non_manager (stratum 1) --(-)--> manager
    ```
    
    **Stratified** ✅
    
    ### Example 2: Layered Permissions
    ```mangle
    Decl user(Id.Type<atom>).
    Decl admin(Id.Type<atom>).
    Decl banned(Id.Type<atom>).
    Decl active_user(Id.Type<atom>).
    Decl safe_user(Id.Type<atom>).
    
    # Stratum 0: Base facts
    user(/u1).
    user(/u2).
    admin(/u1).
    banned(/u3).
    
    # Stratum 1: active_user (negates banned)
    active_user(Id) :-
      user(Id),
      not banned(Id).
    
    # Stratum 2: safe_user (negates admin)
    safe_user(Id) :-
      active_user(Id),
      not admin(Id).
    ```
    
    **Dependency graph**:
    ```
    user (stratum 0)
    admin (stratum 0)
    banned (stratum 0)
    active_user (stratum 1) --(-)--> banned
    safe_user (stratum 2) --(-)--> admin
    safe_user (stratum 2) --+-> active_user
    ```
    
    **Stratified** ✅
    
    ## Examples: Non-Stratified Programs (INVALID)
    
    ### Example 1: Direct Cyclic Negation
    ```mangle
    # WRONG: p depends on its own negation
    p(X) :- not p(X).
    ```
    
    **Dependency graph**:
    ```
    p --(-)--> p  (cycle with negation)
    ```
    
    **NOT stratified** ❌
    
    ### Example 2: Mutual Cyclic Negation
    ```mangle
    # WRONG: Cycle through negation
    p(X) :- not q(X).
    q(X) :- not p(X).
    ```
    
    **Dependency graph**:
    ```
    p --(-)--> q --(-)--> p  (cycle with negation)
    ```
    
    **NOT stratified** ❌
    
    ### Example 3: Indirect Cyclic Negation
    ```mangle
    a(X) :- b(X).
    b(X) :- not c(X).
    c(X) :- a(X).
    ```
    
    **Dependency graph**:
    ```
    a --+-> b --(-)--> c --+-> a  (cycle contains negation)
    ```
    
    **NOT stratified** ❌
    
    ## Fixing Non-Stratified Programs
    
    ### Strategy 1: Remove Cyclic Dependency
    
    #### Before (Non-Stratified)
    ```mangle
    # Trying to define "not admin" and "admin" mutually
    non_admin(X) :- user(X), not admin(X).
    admin(X) :- user(X), not non_admin(X).
    ```
    
    #### After (Stratified)
    ```mangle
    # Admin is base fact
    Decl admin(Id.Type<atom>).
    admin(/u1).
    
    # Non-admin derives from admin
    non_admin(X) :- user(X), not admin(X).
    ```
    
    ### Strategy 2: Break Cycle with Explicit Stratum
    
    #### Before (Non-Stratified)
    ```mangle
    can_edit(User, Doc) :-
      owner(User, Doc).
    
    can_edit(User, Doc) :-
      shared(Doc, User),
      not blocked(User, Doc).
    
    blocked(User, Doc) :-
      not can_edit(User, Doc),
      attempted_edit(User, Doc).
    ```
    
    **Problem**: `can_edit` → `blocked` → `can_edit` (negative cycle)
    
    #### After (Stratified)
    ```mangle
    # Stratum 0: Base permissions
    owner_can_edit(User, Doc) :- owner(User, Doc).
    
    # Stratum 1: Shared permissions (no negation)
    shared_can_edit(User, Doc) :-
      shared(Doc, User).
    
    # Stratum 2: Blocked status (negates stratum 1)
    blocked(User, Doc) :-
      not owner_can_edit(User, Doc),
      not shared_can_edit(User, Doc),
      attempted_edit(User, Doc).
    
    # Stratum 3: Final permission (negates stratum 2)
    can_edit(User, Doc) :-
      owner_can_edit(User, Doc).
    
    can_edit(User, Doc) :-
      shared_can_edit(User, Doc),
      not blocked(User, Doc).
    ```
    
    ## Detecting Stratification Violations
    
    ### Manual Check
    
    1. List all predicates
    2. For each rule, note positive and negative dependencies
    3. Build dependency graph
    4. Check for cycles containing negative edges
    
    ### Automated Check (Tarjan's Algorithm)
    
    ```go
    // Pseudocode for stratification check
    
    type Edge struct {
        From, To string
        Negative bool
    }
    
    func IsStratified(edges []Edge) bool {
        // Build strongly connected components (SCCs)
        sccs := TarjanSCC(edges)
    
        // Check each SCC for negative edges
        for _, scc := range sccs {
            if HasNegativeEdgeInSCC(scc, edges) {
                return false  // Not stratified
            }
        }
        return true
    }
    
    func HasNegativeEdgeInSCC(scc []string, edges []Edge) bool {
        for _, edge := range edges {
            if InSCC(edge.From, scc) && InSCC(edge.To, scc) && edge.Negative {
                return true
            }
        }
        return false
    }
    ```
    
    ## Stratification and Aggregation
    
    Aggregation also creates stratification constraints.
    
    ### Rule
    If predicate `p` uses aggregation over predicate `q`, then `p` must be in a **strictly higher stratum** than `q`.
    
    #### Example
    ```mangle
    Decl employee(Id.Type<atom>, Dept.Type<atom>, Salary.Type<int>).
    Decl dept_total(Dept.Type<atom>, Total.Type<int>).
    
    # Stratum 0: Base facts
    employee(/e1, /engineering, 100000).
    employee(/e2, /engineering, 120000).
    
    # Stratum 1: Aggregation (must be higher than employee)
    dept_total(Dept, Total) :-
      employee(Id, Dept, Salary)
      |> do fn:group_by(Dept),
      let Total = fn:sum(Salary).
    ```
    
    ### Invalid: Recursive Aggregation
    ```mangle
    # WRONG: Cannot aggregate over yourself
    recursive_sum(N, Total) :-
      recursive_sum(M, SubTotal),
      M < N
      |> do fn:group_by(N),
      let Total = fn:sum(SubTotal).
    ```
    
    **Problem**: `recursive_sum` depends on itself through aggregation → infinite stratum needed.
    
    ## Stratification Checklist
    
    - [ ] No predicate depends on its own negation (directly)
    - [ ] No predicate depends on its own negation (indirectly through a cycle)
    - [ ] All negative dependencies go to lower strata
    - [ ] Aggregations go to strictly higher strata than their input
    - [ ] Dependency graph has no cycles containing negative edges
    
    ## Well-Founded Semantics (Advanced)
    
    Some systems support **well-founded semantics**, which allows certain non-stratified programs by treating some facts as "undefined".
    
    **Mangle does NOT support well-founded semantics.** All programs must be stratified.
    
    ## Example: Full Stratification Analysis
    
    ### Program
    ```mangle
    Decl node(Id.Type<atom>).
    Decl edge(From.Type<atom>, To.Type<atom>).
    Decl reachable(From.Type<atom>, To.Type<atom>).
    Decl unreachable(From.Type<atom>, To.Type<atom>).
    Decl isolated(Id.Type<atom>).
    
    # Stratum 0: Base facts
    node(/a). node(/b). node(/c).
    edge(/a, /b).
    
    # Stratum 1: Reachability (positive recursion, same stratum OK)
    reachable(X, Y) :- edge(X, Y).
    reachable(X, Z) :- reachable(X, Y), edge(Y, Z).
    
    # Stratum 2: Unreachable (negates stratum 1)
    unreachable(X, Y) :-
      node(X),
      node(Y),
      not reachable(X, Y),
      X != Y.
    
    # Stratum 3: Isolated nodes (negates stratum 1)
    isolated(X) :-
      node(X),
      not reachable(X, _),
      not reachable(_, X).
    ```
    
    **Dependency graph**:
    ```
    node (stratum 0)
    edge (stratum 0)
    reachable (stratum 1) --+-> edge
                           --+-> reachable (positive cycle: OK)
    unreachable (stratum 2) --(-)--> reachable
    isolated (stratum 3) --(-)--> reachable
    ```
    
    **Stratified** ✅
    
    **Evaluation order**:
    1. Load `node` and `edge` facts
    2. Compute `reachable` to fixpoint
    3. Compute `unreachable` (reachable is now fixed)
    4. Compute `isolated` (reachable is now fixed)
    
    ## Summary
    
    | Concept | Rule |
    |---------|------|
    | **Stratified** | No cycles contain negative edges |
    | **Positive dependency** | Can be cyclic |
    | **Negative dependency** | Must go to strictly lower stratum |
    | **Aggregation** | Must go to strictly higher stratum than input |
    | **Evaluation** | Bottom-up, one stratum at a time |
    | **Fixpoint** | Computed within each stratum |
    
    **Golden Rule**: Never negate a predicate that can recursively call itself.
