# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: advanced/termination.md

- id: "language/mangle/docs/advanced/termination"
  category: "language"
  subcategory: "mangle"
  description: "Mangle Termination Analysis"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle Termination Analysis
    
    ## Why Termination Matters
    
    Mangle programs can easily create infinite loops. Unlike procedural languages with explicit while/for loops, recursion in logic programming can be subtle and hard to detect.
    
    **Critical Rule**: Every recursive predicate MUST have a provable termination condition.
    
    ## Termination Proofs
    
    ### 1. Well-Founded Ordering
    
    A recursive rule terminates if there exists a **well-founded ordering** where each recursive call operates on a "smaller" input.
    
    #### Example: Transitive Closure (Terminates)
    ```mangle
    # Base case
    ancestor(X, Y) :- parent(X, Y).
    
    # Recursive case
    ancestor(X, Z) :- parent(X, Y), ancestor(Y, Z).
    ```
    
    **Why it terminates**: The `parent` relation is finite and acyclic (assuming no time-travel genealogy). Each recursive call moves one step closer to a base case.
    
    #### Example: Countdown (Terminates)
    ```mangle
    Decl countdown(N.Type<int>).
    
    countdown(0).  # Base case
    
    countdown(N) :-
      N1 = fn:plus(N, -1),
      countdown(N1),
      N > 0.  # Guard ensures N decreases
    ```
    
    **Well-founded ordering**: Natural numbers with > relation. Each step decreases N.
    
    ### 2. Structural Recursion on Lists
    
    Recursion on list structure always terminates if you're always operating on the tail.
    
    #### Example: List Length (Terminates)
    ```mangle
    Decl list_length(List.Type<list<int>>, Len.Type<int>).
    
    list_length([], 0).  # Empty list
    
    list_length(List, Len) :-
      :match_cons(List, Head, Tail),
      list_length(Tail, TailLen),  # Tail is strictly smaller
      Len = fn:plus(TailLen, 1).
    ```
    
    **Why it terminates**: Each recursive call operates on the tail, which is strictly smaller than the original list.
    
    ### 3. Bounded Depth Recursion
    
    Explicitly limit recursion depth.
    
    #### Example: Depth-Limited Search
    ```mangle
    Decl reachable_within(Start.Type<atom>, End.Type<atom>, MaxDepth.Type<int>).
    
    # Base case: direct edge
    reachable_within(X, Y, D) :-
      edge(X, Y),
      D >= 1.
    
    # Recursive case with depth limit
    reachable_within(X, Z, D) :-
      D > 1,  # Must have budget left
      edge(X, Y),
      D1 = fn:minus(D, 1),
      reachable_within(Y, Z, D1).
    ```
    
    **Termination argument**: Depth decreases with each recursive call and is bounded below by 1.
    
    ## Non-Terminating Patterns (DANGER)
    
    ### 1. The Infinite Generator
    ```mangle
    # WRONG: Generates all natural numbers (never stops)
    natural(0).
    natural(N) :-
      natural(M),
      N = fn:plus(M, 1).
    ```
    
    **Fix**: Add an upper bound
    ```mangle
    # CORRECT: Generate numbers up to limit
    natural_bounded(0, Max) :- Max >= 0.
    natural_bounded(N, Max) :-
      natural_bounded(M, Max),
      N = fn:plus(M, 1),
      N <= Max.
    ```
    
    ### 2. Mutual Recursion Without Progress
    ```mangle
    # WRONG: Ping-pongs forever
    even(0).
    even(N) :- odd(M), N = fn:plus(M, 1).
    
    odd(N) :- even(M), N = fn:plus(M, 1).
    ```
    
    **Problem**: No base case for odd, and no decreasing measure.
    
    **Fix**: Add base case and decreasing measure
    ```mangle
    # CORRECT: Count down
    even(0).
    even(N) :- N > 0, M = fn:minus(N, 1), odd(M).
    
    odd(1).
    odd(N) :- N > 1, M = fn:minus(N, 1), even(M).
    ```
    
    ### 3. Recursive Negation (Stratification Violation)
    ```mangle
    # WRONG: Cyclic dependency through negation
    p(X) :- not q(X).
    q(X) :- not p(X).
    ```
    
    **Problem**: Cannot compute p without q, cannot compute q without p.
    
    **Fix**: Remove cyclic negation (see stratification.md).
    
    ### 4. Self-Referring Rules Without Base Case
    ```mangle
    # WRONG: No base case
    loop(X) :- loop(X).
    ```
    
    **Fix**: Always provide a base case
    ```mangle
    # CORRECT: Base case grounds the recursion
    starts_at(0).
    loop(X) :- starts_at(X).
    loop(Y) :- loop(X), Y = fn:plus(X, 1), Y < 100.
    ```
    
    ## Termination Analysis Techniques
    
    ### 1. Dependency Graph Analysis
    
    Build a graph where:
    - Nodes = Predicates
    - Edges = Calls (predicate A calls predicate B)
    
    **Termination conditions**:
    - No cycles → Always terminates
    - Cycles exist → Check if each cycle has a decreasing measure
    
    #### Example
    ```mangle
    # Predicates: a, b, c
    a(X) :- b(X).
    b(X) :- c(X).
    c(X) :- data(X).  # Base data, no recursion
    
    # Dependency graph: a → b → c → data
    # No cycles → Terminates
    ```
    
    ### 2. Size-Change Principle
    
    For each recursive call, track whether arguments:
    - Decrease (↓)
    - Stay same (=)
    - Increase (↑)
    
    **Termination**: If every cycle has at least one ↓ and no ↑.
    
    #### Example: Ackermann Function (Does NOT terminate in general)
    ```mangle
    # Ackermann function (notoriously non-primitive recursive)
    ack(0, N, Result) :- Result = fn:plus(N, 1).
    ack(M, 0, Result) :-
      M > 0,
      M1 = fn:minus(M, 1),
      ack(M1, 1, Result).  # M decreases
    ack(M, N, Result) :-
      M > 0, N > 0,
      M1 = fn:minus(M, 1),
      N1 = fn:minus(N, 1),
      ack(M, N1, Temp),    # N decreases, M same (BAD)
      ack(M1, Temp, Result).  # M decreases, but Temp can be HUGE
    ```
    
    **Analysis**: Second clause has M=, N↓, which doesn't guarantee termination because the intermediate Temp can grow unbounded.
    
    ### 3. Ranking Functions
    
    Assign a numeric "rank" to each recursive call that strictly decreases.
    
    #### Example: Fibonacci (Terminates with Memoization)
    ```mangle
    Decl fib(N.Type<int>, Result.Type<int>).
    
    fib(0, 0).
    fib(1, 1).
    fib(N, Result) :-
      N > 1,
      N1 = fn:minus(N, 1),
      N2 = fn:minus(N, 2),
      fib(N1, F1),  # Rank = N-1
      fib(N2, F2),  # Rank = N-2
      Result = fn:plus(F1, F2).
    ```
    
    **Rank function**: r(N) = N. Each recursive call has rank < N.
    
    ## Gas Limits (Practical Termination Enforcement)
    
    When formal proof is hard, enforce computational budgets.
    
    ### 1. Step Counter
    ```mangle
    Decl step_count(Count.Type<int>).
    Decl max_steps(Max.Type<int>).
    
    # Initialize
    step_count(0) :- true.
    max_steps(10000) :- true.
    
    # Increment on each operation
    step_count(N) :-
      previous_step(M),
      N = fn:plus(M, 1).
    
    # Halt if exceeded
    budget_exceeded() :-
      step_count(Current),
      max_steps(Max),
      Current > Max.
    
    # Guard recursive rules
    safe_recursion(X) :-
      not budget_exceeded(),
      recursive_predicate(X).
    ```
    
    ### 2. Depth Tracking
    ```mangle
    Decl recursion_depth(Pred.Type<atom>, Depth.Type<int>).
    Decl max_depth(Depth.Type<int>).
    
    max_depth(50).
    
    # Track depth for each predicate
    current_depth(Pred, D) :-
      recursion_depth(Pred, D).
    
    # Enforce limit
    depth_exceeded(Pred) :-
      current_depth(Pred, D),
      max_depth(Max),
      D > Max.
    
    # Guarded recursive rule
    ancestor_safe(X, Z, Depth) :-
      Depth < 50,  # Explicit check
      parent(X, Y),
      Depth1 = fn:plus(Depth, 1),
      ancestor_safe(Y, Z, Depth1).
    ```
    
    ### 3. Timeout (External)
    
    In Go, wrap evaluation with a timeout:
    
    ```go
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    done := make(chan error, 1)
    go func() {
        done <- engine.EvalProgram(ctx, program, store)
    }()
    
    select {
    case err := <-done:
        // Completed
    case <-ctx.Done():
        // Timeout: program did not terminate in time
        return fmt.Errorf("evaluation timeout")
    }
    ```
    
    ## Termination Checklist
    
    For every recursive predicate, verify:
    
    - [ ] **Base case exists**: At least one non-recursive clause
    - [ ] **Recursive calls make progress**: Arguments decrease in some well-founded ordering
    - [ ] **Bounds are enforced**: No unbounded generators
    - [ ] **No cyclic negation**: Stratification is valid (see stratification.md)
    - [ ] **Mutual recursion terminates**: Each cycle has a decreasing measure
    - [ ] **Gas limits** (optional): Depth/step counters for safety
    
    ## Examples: Terminating vs. Non-Terminating
    
    ### Terminates
    ```mangle
    # Sum of list
    sum_list([], 0).
    sum_list(List, Sum) :-
      :match_cons(List, Head, Tail),
      sum_list(Tail, TailSum),  # Tail is smaller
      Sum = fn:plus(Head, TailSum).
    ```
    
    ### Does NOT Terminate
    ```mangle
    # WRONG: Generates infinite list
    infinite_list([0 | Tail]) :- infinite_list(Tail).
    ```
    
    ### Terminates with Guard
    ```mangle
    # Generate list up to N
    list_up_to(N, []) :- N < 0.
    list_up_to(N, [N | Tail]) :-
      N >= 0,
      N1 = fn:minus(N, 1),
      list_up_to(N1, Tail).
    ```
    
    ## Recursive Patterns Summary
    
    | Pattern | Termination | Example |
    |---------|-------------|---------|
    | Structural recursion on finite data | ✅ Always | List traversal |
    | Transitive closure on acyclic graph | ✅ Always | ancestor/2 on tree |
    | Transitive closure on cyclic graph | ⚠️ Depends | Needs visited set |
    | Countdown with base case | ✅ Always | factorial(N) |
    | Mutual recursion with progress | ✅ Always | even/odd parity |
    | Unbounded generator | ❌ Never | natural(N) without bound |
    | Cyclic negation | ❌ Never | p(X) :- not q(X), q(X) :- not p(X) |
    
    ## Advanced: Semi-Decidability
    
    Some predicates are **semi-decidable**: they terminate on "yes" answers but may not terminate on "no" answers.
    
    #### Example: Graph Reachability
    ```mangle
    # Terminates if path exists, may not terminate if path doesn't exist
    reachable(X, Y) :- edge(X, Y).
    reachable(X, Z) :- edge(X, Y), reachable(Y, Z).
    ```
    
    **Solution**: Use bounded depth search or visited set tracking.
    
    ```mangle
    # Bounded: always terminates
    reachable_bounded(X, Y, 0) :- edge(X, Y).
    reachable_bounded(X, Z, D) :-
      D > 0,
      edge(X, Y),
      D1 = fn:minus(D, 1),
      reachable_bounded(Y, Z, D1).
    ```
