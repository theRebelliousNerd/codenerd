# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: advanced/external_predicates_advanced.md

- id: "language/mangle/docs/advanced/external_predicates_advanced"
  category: "language"
  subcategory: "mangle"
  description: "Mangle External Predicates: Advanced Patterns"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle External Predicates: Advanced Patterns
    
    ## What Are External Predicates?
    
    External predicates are implemented in Go and called from Mangle. They allow:
    - Accessing external systems (databases, APIs, file I/O)
    - Performing complex computations not expressible in Mangle
    - Interfacing with the host application
    
    ## External Predicate Signature (Go)
    
    ```go
    // External predicate function signature
    func MyPredicate(query engine.Query, callback func(engine.Fact)) error {
        // Extract arguments from query
        // Perform computation
        // Invoke callback for each result
        return nil
    }
    ```
    
    ## Basic Example
    
    ### Mangle Declaration
    ```mangle
    Decl external_data(Key.Type<atom>, Value.Type<string>).
    ```
    
    ### Go Implementation
    ```go
    func ExternalData(query engine.Query, cb func(engine.Fact)) error {
        // Mock external data source
        data := map[string]string{
            "api_key": "secret123",
            "db_host": "localhost",
        }
    
        // Extract argument from query
        keyArg := query.Args[0]
    
        if keyArg.IsWildcard() {
            // Return all key-value pairs
            for k, v := range data {
                fact := engine.NewFact(
                    "external_data",
                    engine.NewAtom(k),
                    engine.NewString(v),
                )
                cb(fact)
            }
        } else {
            // Return specific key
            key := keyArg.AsAtom().Value
            if val, exists := data[key]; exists {
                fact := engine.NewFact(
                    "external_data",
                    engine.NewAtom(key),
                    engine.NewString(val),
                )
                cb(fact)
            }
        }
    
        return nil
    }
    
    // Register
    engine.RegisterExternalPredicate("external_data", ExternalData)
    ```
    
    ### Mangle Usage
    ```mangle
    # Query specific key
    config(Value) :-
      external_data(/api_key, Value).
    
    # Query all keys
    all_configs(Key, Value) :-
      external_data(Key, Value).
    ```
    
    ## Pattern 1: Caching External Results
    
    External calls can be expensive. Cache results in Mangle facts.
    
    ### Strategy: One-time Fetch
    ```go
    var cachedData []engine.Fact
    var cacheMutex sync.Mutex
    var cacheInitialized bool
    
    func CachedExternalData(query engine.Query, cb func(engine.Fact)) error {
        cacheMutex.Lock()
        defer cacheMutex.Unlock()
    
        if !cacheInitialized {
            // Fetch from external source once
            data := fetchFromExternalAPI()  // Expensive call
    
            for k, v := range data {
                fact := engine.NewFact("cached_external_data",
                    engine.NewAtom(k), engine.NewString(v))
                cachedData = append(cachedData, fact)
            }
            cacheInitialized = true
        }
    
        // Serve from cache
        keyArg := query.Args[0]
        if keyArg.IsWildcard() {
            for _, fact := range cachedData {
                cb(fact)
            }
        } else {
            key := keyArg.AsAtom().Value
            for _, fact := range cachedData {
                if fact.Args[0].AsAtom().Value == key {
                    cb(fact)
                }
            }
        }
    
        return nil
    }
    ```
    
    ### Mangle Usage
    ```mangle
    # First call fetches from API, subsequent calls use cache
    lookup(Key, Value) :-
      cached_external_data(Key, Value).
    ```
    
    ## Pattern 2: Lazy Evaluation
    
    Only fetch data when actually needed.
    
    ```go
    func LazyFetch(query engine.Query, cb func(engine.Fact)) error {
        keyArg := query.Args[0]
    
        if keyArg.IsWildcard() {
            return fmt.Errorf("lazy predicates require specific key")
        }
    
        key := keyArg.AsAtom().Value
    
        // Only fetch this specific key
        value := fetchSingleKey(key)  // Targeted fetch
    
        fact := engine.NewFact("lazy_fetch",
            engine.NewAtom(key),
            engine.NewString(value))
        cb(fact)
    
        return nil
    }
    ```
    
    ### Mangle Usage
    ```mangle
    # Only fetches /api_key, not all data
    specific_config(Value) :-
      lazy_fetch(/api_key, Value).
    ```
    
    ## Pattern 3: Error Handling
    
    External predicates can fail. Handle errors gracefully.
    
    ```go
    func FalliblePredicate(query engine.Query, cb func(engine.Fact)) error {
        key := query.Args[0].AsAtom().Value
    
        value, err := riskyOperation(key)
        if err != nil {
            // Option 1: Return error (stops evaluation)
            return fmt.Errorf("external predicate failed: %w", err)
    
            // Option 2: Return no results (predicate fails silently)
            // return nil
    
            // Option 3: Return error fact
            errorFact := engine.NewFact("error",
                engine.NewAtom(key),
                engine.NewString(err.Error()))
            cb(errorFact)
            return nil
        }
    
        fact := engine.NewFact("fallible_predicate",
            engine.NewAtom(key),
            engine.NewString(value))
        cb(fact)
        return nil
    }
    ```
    
    ### Mangle Usage
    ```mangle
    # Option 1: Stops if error
    result(Value) :-
      fallible_predicate(/key, Value).
    
    # Option 3: Handle error explicitly
    result(Value) :-
      fallible_predicate(/key, Value),
      not error(/key, _).
    
    error_message(Key, Msg) :-
      error(Key, Msg).
    ```
    
    ## Pattern 4: Side Effects (Dangerous!)
    
    External predicates should be **pure** (no side effects), but sometimes necessary.
    
    ```go
    var sideEffectCounter int
    var counterMutex sync.Mutex
    
    func SideEffectPredicate(query engine.Query, cb func(engine.Fact)) error {
        counterMutex.Lock()
        defer counterMutex.Unlock()
    
        // DANGER: Side effect!
        sideEffectCounter++
        log.Printf("Called %d times", sideEffectCounter)
    
        fact := engine.NewFact("side_effect",
            engine.NewInt(sideEffectCounter))
        cb(fact)
    
        return nil
    }
    ```
    
    **Problems**:
    - Non-deterministic (depends on call order)
    - Can be called multiple times due to backtracking
    - Breaks logical semantics
    
    **Solution**: Use carefully, document heavily, or redesign.
    
    ### Better Approach: Explicit Action Queue
    ```mangle
    # Declare intent, execute later
    Decl action_intent(Action.Type<atom>, Args.Type<struct>).
    
    # Mangle declares what should happen
    action_intent(/send_email, { /to: "user@example.com", /subject: "Hello" }).
    action_intent(/log_event, { /level: /info, /message: "Processing complete" }).
    
    # Go executor reads action queue and executes
    ```
    
    ## Pattern 5: Streaming Large Results
    
    For large datasets, stream results instead of loading all into memory.
    
    ```go
    func StreamResults(query engine.Query, cb func(engine.Fact)) error {
        // Open database connection
        rows, err := db.Query("SELECT id, name FROM users")
        if err != nil {
            return err
        }
        defer rows.Close()
    
        // Stream results one at a time
        for rows.Next() {
            var id, name string
            if err := rows.Scan(&id, &name); err != nil {
                return err
            }
    
            fact := engine.NewFact("user_from_db",
                engine.NewAtom(id),
                engine.NewString(name))
            cb(fact)  // Callback immediately, no buffering
        }
    
        return rows.Err()
    }
    ```
    
    ### Mangle Usage
    ```mangle
    # Processes users one at a time, doesn't load all into memory
    high_value_users(Id, Name) :-
      user_from_db(Id, Name),
      user_total_spent(Id, Total),
      Total > 10000.
    ```
    
    ## Pattern 6: Time-Sensitive Data
    
    External predicates that depend on current time.
    
    ```go
    func CurrentTime(query engine.Query, cb func(engine.Fact)) error {
        now := time.Now().Unix()
    
        fact := engine.NewFact("current_time",
            engine.NewInt(int(now)))
        cb(fact)
    
        return nil
    }
    
    func IsRecent(query engine.Query, cb func(engine.Fact)) error {
        timestamp := query.Args[0].AsInt().Value
        now := time.Now().Unix()
    
        if now - int64(timestamp) < 3600 {  // Within last hour
            fact := engine.NewFact("is_recent", query.Args[0])
            cb(fact)
        }
    
        return nil
    }
    ```
    
    ### Mangle Usage
    ```mangle
    Decl event(Id.Type<atom>, Timestamp.Type<int>).
    event(/e1, 1700000000).
    
    recent_events(Id) :-
      event(Id, Timestamp),
      is_recent(Timestamp).
    ```
    
    **Warning**: Non-deterministic! Results change over time.
    
    ## Pattern 7: Argument Type Checking
    
    Validate arguments before processing.
    
    ```go
    func SafePredicate(query engine.Query, cb func(engine.Fact)) error {
        if len(query.Args) != 2 {
            return fmt.Errorf("expected 2 arguments, got %d", len(query.Args))
        }
    
        // Check argument types
        if !query.Args[0].IsAtom() {
            return fmt.Errorf("arg 0 must be atom, got %T", query.Args[0])
        }
    
        if query.Args[1].IsWildcard() {
            // OK, output parameter
        } else if !query.Args[1].IsString() {
            return fmt.Errorf("arg 1 must be string or wildcard, got %T", query.Args[1])
        }
    
        // Proceed with safe arguments
        key := query.Args[0].AsAtom().Value
        value := fetchValue(key)
    
        fact := engine.NewFact("safe_predicate",
            query.Args[0],
            engine.NewString(value))
        cb(fact)
    
        return nil
    }
    ```
    
    ## Pattern 8: Context-Aware Predicates
    
    Use Go context for cancellation and timeouts.
    
    ```go
    func ContextAwarePredicate(ctx context.Context, query engine.Query, cb func(engine.Fact)) error {
        // Long-running operation
        for i := 0; i < 1000000; i++ {
            // Check for cancellation periodically
            select {
            case <-ctx.Done():
                return ctx.Err()  // Cancelled or timeout
            default:
                // Continue processing
            }
    
            // Compute result
            fact := engine.NewFact("result", engine.NewInt(i))
            cb(fact)
        }
    
        return nil
    }
    ```
    
    **Note**: Requires engine support for context propagation.
    
    ## Pattern 9: Composite Results (Structs)
    
    Return complex data structures.
    
    ```go
    func UserProfile(query engine.Query, cb func(engine.Fact)) error {
        userId := query.Args[0].AsAtom().Value
    
        // Fetch complex profile
        profile := fetchUserProfile(userId)
    
        // Build struct
        structValue := engine.NewStruct(map[string]engine.Value{
            "name": engine.NewString(profile.Name),
            "age": engine.NewInt(profile.Age),
            "roles": engine.NewList(
                engine.NewAtom("admin"),
                engine.NewAtom("user"),
            ),
        })
    
        fact := engine.NewFact("user_profile",
            query.Args[0],
            structValue)
        cb(fact)
    
        return nil
    }
    ```
    
    ### Mangle Usage
    ```mangle
    user_name(Id, Name) :-
      user_profile(Id, Profile),
      :match_field(Profile, /name, Name).
    ```
    
    ## Pattern 10: Virtual Aggregation
    
    Implement aggregation in Go for efficiency.
    
    ```go
    func CountMatches(query engine.Query, cb func(engine.Fact)) error {
        pattern := query.Args[0].AsString().Value
    
        // Efficient counting in Go
        count := 0
        rows, _ := db.Query("SELECT COUNT(*) FROM items WHERE name LIKE ?", pattern)
        rows.Next()
        rows.Scan(&count)
        rows.Close()
    
        fact := engine.NewFact("count_matches",
            query.Args[0],
            engine.NewInt(count))
        cb(fact)
    
        return nil
    }
    ```
    
    **Benefit**: Avoids loading all data into Mangle just to count.
    
    ## Best Practices
    
    ### 1. Keep External Predicates Pure
    ```go
    // BAD: Mutates global state
    var globalCounter int
    func BadPredicate(query engine.Query, cb func(engine.Fact)) error {
        globalCounter++  // Side effect!
        // ...
    }
    
    // GOOD: Pure function
    func GoodPredicate(query engine.Query, cb func(engine.Fact)) error {
        // Only reads input, produces output via callback
        // No side effects
    }
    ```
    
    ### 2. Document Performance Characteristics
    ```go
    // SlowExternalAPI fetches data from remote API.
    // WARNING: Can take 5-10 seconds. Cache results if calling multiple times.
    func SlowExternalAPI(query engine.Query, cb func(engine.Fact)) error {
        // ...
    }
    ```
    
    ### 3. Fail Fast
    ```go
    func ValidatedPredicate(query engine.Query, cb func(engine.Fact)) error {
        // Validate arguments immediately
        if len(query.Args) != 2 {
            return fmt.Errorf("invalid arguments")
        }
    
        // Early return on errors
        data, err := fetchData()
        if err != nil {
            return err
        }
    
        // Process data
        // ...
    }
    ```
    
    ### 4. Use Specific Queries When Possible
    ```go
    func OptimizedPredicate(query engine.Query, cb func(engine.Fact)) error {
        if query.Args[0].IsWildcard() {
            // Must fetch all data (expensive)
            return fetchAll(cb)
        } else {
            // Can fetch specific item (cheap)
            key := query.Args[0].AsAtom().Value
            return fetchOne(key, cb)
        }
    }
    ```
    
    ### 5. Limit Result Set Size
    ```go
    func BoundedResults(query engine.Query, cb func(engine.Fact)) error {
        const maxResults = 1000
    
        count := 0
        for _, item := range fetchItems() {
            if count >= maxResults {
                log.Warn("Result set truncated at %d", maxResults)
                break
            }
    
            cb(engine.NewFact("item", engine.NewAtom(item)))
            count++
        }
    
        return nil
    }
    ```
    
    ## Testing External Predicates
    
    ```go
    func TestExternalPredicate(t *testing.T) {
        // Create mock query
        query := engine.Query{
            Predicate: "my_predicate",
            Args: []engine.Value{
                engine.NewAtom("test_key"),
                engine.Wildcard(),
            },
        }
    
        // Collect results
        var results []engine.Fact
        callback := func(fact engine.Fact) {
            results = append(results, fact)
        }
    
        // Execute
        err := MyPredicate(query, callback)
    
        // Assert
        assert.NoError(t, err)
        assert.Len(t, results, 1)
        assert.Equal(t, "expected_value", results[0].Args[1].AsString().Value)
    }
    ```
    
    ## Checklist
    
    - [ ] External predicate is pure (no side effects)
    - [ ] Arguments are validated before processing
    - [ ] Errors are handled and returned appropriately
    - [ ] Performance characteristics are documented
    - [ ] Caching is used for expensive operations
    - [ ] Results are streamed for large datasets
    - [ ] Wildcard vs. specific queries are optimized differently
    - [ ] Result set size is bounded
    - [ ] Unit tests cover edge cases
    - [ ] Thread-safety is ensured (use mutexes if needed)
