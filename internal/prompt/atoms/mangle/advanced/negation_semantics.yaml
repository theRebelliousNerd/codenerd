# AUTOGENERATED FROM MARKDOWN: this file was converted from a .md atom doc
# Source: advanced/negation_semantics.md

- id: "language/mangle/docs/advanced/negation_semantics"
  category: "language"
  subcategory: "mangle"
  description: "Mangle Negation Semantics"
  priority: 30
  is_mandatory: false
  languages: ["/mangle"]
  content: |
    # Mangle Negation Semantics
    
    ## Closed World Assumption (CWA)
    
    Mangle operates under the **Closed World Assumption**:
    
    **If a fact is not provable, it is assumed to be FALSE.**
    
    This is opposite to the **Open World Assumption** used in OWL/RDF, where absence of information means "unknown".
    
    ## Negation-as-Failure
    
    Mangle implements **negation-as-failure (NAF)**:
    
    `not p(X)` succeeds if and only if `p(X)` **fails to be proven**.
    
    ### Example
    ```mangle
    Decl employee(Id.Type<atom>, Name.Type<string>).
    Decl manager(Id.Type<atom>).
    Decl non_manager(Id.Type<atom>).
    
    # Facts
    employee(/e1, "Alice").
    employee(/e2, "Bob").
    manager(/e1).
    
    # Rule using negation
    non_manager(Id) :-
      employee(Id, Name),
      not manager(Id).
    ```
    
    **Query**: `non_manager(Id)?`
    
    **Result**: `{/e2}` (Bob is not a manager)
    
    **Why**: `manager(/e2)` cannot be proven, so `not manager(/e2)` succeeds.
    
    ## CWA vs. OWA
    
    | Assumption | Missing Fact Means | Example Use Case |
    |------------|-------------------|------------------|
    | **CWA** (Mangle) | FALSE | Databases, programming |
    | **OWA** (RDF) | UNKNOWN | Semantic web, incomplete knowledge |
    
    ### Example: The Difference
    
    **Scenario**: We know Alice is a manager. We have no information about Bob.
    
    #### Under CWA (Mangle)
    ```mangle
    manager(/alice).
    
    # Query: not manager(/bob)
    # Result: TRUE (Bob is not a manager, because we don't have that fact)
    ```
    
    #### Under OWA (Hypothetical)
    ```mangle
    manager(/alice).
    
    # Query: not manager(/bob)
    # Result: UNKNOWN (We don't know if Bob is a manager or not)
    ```
    
    **Mangle only uses CWA.** There is no "UNKNOWN" truth value.
    
    ## Safety Rules for Negation
    
    ### Rule 1: All Variables in Negation Must Be Bound
    
    **Unsafe** (WRONG):
    ```mangle
    # WRONG: X is not bound before negation
    result(X) :- not forbidden(X).
    ```
    
    **Why wrong**: What values should X take? Without a domain, this is unbounded.
    
    **Safe** (CORRECT):
    ```mangle
    # CORRECT: X is bound by candidate/1 first
    result(X) :-
      candidate(X),      # X gets a value from here
      not forbidden(X).  # Now we can check if X is forbidden
    ```
    
    ### Rule 2: Negation Must Be Stratified
    
    See `stratification_deep.md` for full details.
    
    **Core principle**: You cannot negate a predicate that depends on itself (directly or indirectly).
    
    **Unsafe** (WRONG):
    ```mangle
    # WRONG: Cyclic negation
    p(X) :- not q(X).
    q(X) :- not p(X).
    ```
    
    **Safe** (CORRECT):
    ```mangle
    # CORRECT: q is in lower stratum
    base_data(X) :- source(X).
    q(X) :- base_data(X), filter(X).
    p(X) :- candidate(X), not q(X).
    ```
    
    ## Negation Patterns
    
    ### 1. Set Difference
    
    Compute A - B (elements in A but not in B).
    
    ```mangle
    Decl all_users(Id.Type<atom>).
    Decl active_users(Id.Type<atom>).
    Decl inactive_users(Id.Type<atom>).
    
    # Facts
    all_users(/u1). all_users(/u2). all_users(/u3).
    active_users(/u1). active_users(/u2).
    
    # Set difference: all - active = inactive
    inactive_users(Id) :-
      all_users(Id),
      not active_users(Id).
    
    # Result: {/u3}
    ```
    
    ### 2. Absence Check
    
    Check if a relationship does NOT exist.
    
    ```mangle
    Decl user(Id.Type<atom>).
    Decl login(UserId.Type<atom>, Date.Type<string>).
    Decl never_logged_in(Id.Type<atom>).
    
    # Facts
    user(/u1). user(/u2).
    login(/u1, "2024-01-15").
    
    # Users who never logged in
    never_logged_in(Id) :-
      user(Id),
      not login(Id, _).  # No login record exists
    
    # Result: {/u2}
    ```
    
    ### 3. Universal Quantification (All)
    
    "All X satisfy property P" = "There is no X that violates P"
    
    ```mangle
    Decl employee(Id.Type<atom>, Dept.Type<atom>).
    Decl training_complete(Id.Type<atom>).
    Decl dept_fully_trained(Dept.Type<atom>).
    
    # Facts
    employee(/e1, /eng). employee(/e2, /eng).
    training_complete(/e1). training_complete(/e2).
    
    # Department is fully trained if no employee lacks training
    dept_fully_trained(Dept) :-
      employee(_, Dept),  # Department has at least one employee
      not untrained_employee(Dept).
    
    untrained_employee(Dept) :-
      employee(Id, Dept),
      not training_complete(Id).
    ```
    
    **Logic**: ∀x ∈ Dept. trained(x) ≡ ¬∃x ∈ Dept. ¬trained(x)
    
    ### 4. Exclusion Constraints
    
    "If A holds, then B must NOT hold."
    
    ```mangle
    Decl conflict(A.Type<atom>, B.Type<atom>).
    Decl assigned(Task.Type<atom>, Person.Type<atom>).
    Decl valid_assignment(Task.Type<atom>, Person.Type<atom>).
    
    # Facts
    conflict(/alice, /bob).  # Alice and Bob can't work together
    assigned(/task1, /alice).
    assigned(/task2, /bob).
    
    # Valid if no conflicting person is assigned to same task
    valid_assignment(Task, Person) :-
      assigned(Task, Person),
      not conflicting_assignment(Task, Person).
    
    conflicting_assignment(Task, P1) :-
      assigned(Task, P1),
      assigned(Task, P2),
      conflict(P1, P2).
    ```
    
    ### 5. Integrity Constraints (Violations)
    
    "This should NEVER happen."
    
    ```mangle
    Decl account(Id.Type<atom>, Balance.Type<int>).
    Decl violation_negative_balance(Id.Type<atom>, Balance.Type<int>).
    
    # Facts
    account(/acc1, 1000).
    account(/acc2, -50).  # Violation!
    
    # Detect violations
    violation_negative_balance(Id, Balance) :-
      account(Id, Balance),
      Balance < 0.
    
    # Global integrity check
    system_has_violations() :-
      violation_negative_balance(_, _).
    ```
    
    ## Double Negation
    
    `not not p(X)` is **not equivalent** to `p(X)` in Mangle.
    
    ### Why?
    
    Under CWA:
    - `p(X)` = "X can be proven true"
    - `not p(X)` = "X fails to be proven true"
    - `not not p(X)` = "X does not fail to be proven true" = `p(X)`
    
    Actually, in Mangle, `not not p(X)` **reduces to** `p(X)` in practice, but this is not meaningful in queries.
    
    ### Example
    ```mangle
    Decl data(X.Type<int>).
    data(1).
    data(2).
    
    # These are equivalent
    result1(X) :- data(X).
    result2(X) :- not not data(X).
    
    # Both produce: {1, 2}
    ```
    
    **Best practice**: Never use double negation. It's redundant and confusing.
    
    ## Negation and the Anonymous Variable
    
    The anonymous variable `_` in negation means "there exists at least one".
    
    ### Example: "Has at least one child"
    ```mangle
    Decl parent(Parent.Type<atom>, Child.Type<atom>).
    Decl has_children(Parent.Type<atom>).
    
    parent(/alice, /bob).
    parent(/alice, /charlie).
    
    # Has at least one child
    has_children(P) :- parent(P, _).
    
    # Result: {/alice}
    ```
    
    ### Example: "Has NO children"
    ```mangle
    Decl childless(Parent.Type<atom>).
    
    childless(P) :-
      person(P),
      not parent(P, _).  # No child exists
    
    # Means: "there does NOT exist any child of P"
    ```
    
    ## Negation and Inequality
    
    Combining negation with inequality (`!=`).
    
    ### Example: "All values are distinct"
    ```mangle
    Decl value(X.Type<int>).
    Decl all_distinct().
    
    value(1). value(2). value(3).
    
    # All distinct if no two values are the same
    all_distinct() :-
      not has_duplicate().
    
    has_duplicate() :-
      value(X),
      value(Y),
      X = Y,
      # Need to ensure we're not comparing the same fact to itself
      # In Mangle, this requires additional grounding
      false.  # Placeholder; real implementation needs fact IDs
    
    # Better approach: use aggregation
    distinct_count(Count) :-
      value(X)
      |> do fn:group_by(),
      let Count = fn:count_distinct(X).
    
    total_count(Count) :-
      value(X)
      |> do fn:group_by(),
      let Count = fn:count(X).
    
    all_distinct() :-
      distinct_count(D),
      total_count(T),
      D = T.
    ```
    
    ## Negation Performance
    
    Negation can be expensive. Optimize by:
    
    1. **Bind variables before negation**
       ```mangle
       # BAD: Generates all X, then filters
       result(X) :- huge_table(X), not forbidden(X).
    
       # GOOD: Filter first
       result(X) :- candidate(X), not forbidden(X).
       ```
    
    2. **Use positive filtering when possible**
       ```mangle
       # Instead of: "not in set B"
       not_in_b(X) :- all(X), not b(X).
    
       # Better: "in set A" (if A and B are disjoint)
       in_a(X) :- a(X).
       ```
    
    3. **Compute negation once, reuse**
       ```mangle
       # BAD: Repeated negation checks
       rule1(X) :- data(X), not expensive(X).
       rule2(X) :- data(X), not expensive(X).
    
       # GOOD: Materialize once
       not_expensive(X) :- data(X), not expensive(X).
       rule1(X) :- not_expensive(X).
       rule2(X) :- not_expensive(X).
       ```
    
    ## Common Pitfalls
    
    ### Pitfall 1: Expecting OWA Behavior
    ```mangle
    # User's intent: "I don't know if Alice is a manager"
    # Mangle's interpretation: "Alice is NOT a manager"
    
    # Query: not manager(/alice)
    # Result: TRUE (because manager(/alice) is not in the database)
    ```
    
    **Solution**: Explicitly model "unknown" if needed.
    
    ```mangle
    Decl manager_status(Id.Type<atom>, Status.Type<atom>).
    
    manager_status(/alice, /unknown).
    manager_status(/bob, /yes).
    
    # Now can distinguish unknown from no
    ```
    
    ### Pitfall 2: Unsafe Variables
    ```mangle
    # WRONG: X is unbound
    bad_rule(X) :- not forbidden(X).
    
    # CORRECT: Bind X first
    good_rule(X) :- universe(X), not forbidden(X).
    ```
    
    ### Pitfall 3: Negating Empty Results
    ```mangle
    Decl item(Id.Type<atom>).
    # No facts!
    
    # Query: not item(/missing)
    # Result: TRUE (item(/missing) fails, so negation succeeds)
    
    # But there are NO items at all!
    ```
    
    **Solution**: Check existence first.
    ```mangle
    has_items() :- item(_).
    
    safe_check(X) :-
      has_items(),
      candidate(X),
      not item(X).
    ```
    
    ## Summary Table
    
    | Operation | Mangle Syntax | Meaning |
    |-----------|---------------|---------|
    | Negation | `not p(X)` | p(X) fails to be proven |
    | Set difference | `a(X), not b(X)` | X in a but not in b |
    | Absence check | `not exists(X)` | No X exists |
    | Universal quantification | `not violates(X)` | All X satisfy property |
    | Exclusion | `a(X), not b(X)` | a and b are mutually exclusive |
    
    ## Checklist
    
    Before using negation:
    
    - [ ] All variables in negation are bound by positive atoms
    - [ ] The predicate being negated is in a lower stratum
    - [ ] Performance: negation is applied after filtering
    - [ ] You intended CWA semantics (missing = false, not unknown)
    - [ ] No double negation (`not not p`)
    - [ ] Negation is necessary (can't use positive filtering instead)
