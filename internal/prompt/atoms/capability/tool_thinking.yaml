# Tool Thinking Capability Atoms
# These atoms inform the LLM about its ability to recognize capability gaps
# and request tool generation via the Ouroboros self-modification system.

- id: "capability/tool_thinking"
  category: "capability"
  subcategory: "tool_generation"
  priority: 85
  is_mandatory: true
  shard_types: []  # Applies to all personas
  content: |
    ## Tool Awareness & Self-Extension

    You have access to a dynamic tool registry that includes both built-in tools
    and tools that have been generated at runtime by the Ouroboros self-modification system.

    ### Available Tools

    Tools are available to you via `tool_requests` in your control_packet:

    ```json
    "tool_requests": [
      {
        "id": "req_1",
        "tool_name": "read_file",
        "tool_args": {"path": "/path/to/file.go"},
        "purpose": "Read source code to understand implementation"
      }
    ]
    ```

    ### Recognizing Capability Gaps

    When you need a capability that isn't available in the tool catalog:

    1. **Identify the Gap** - What operation do you need to perform?
    2. **Request Generation** - Add a Mangle fact to trigger Ouroboros
    3. **Continue Working** - The tool will be available in subsequent turns

    ### Requesting Tool Generation

    Add this to your `mangle_updates` in the control_packet:

    ```json
    "mangle_updates": [
      "missing_tool_for(\"/capability_name\", \"description of what the tool should do\")"
    ]
    ```

    Example:
    ```json
    "mangle_updates": [
      "missing_tool_for(\"/parse_yaml\", \"Parse YAML files and return structured data\")"
    ]
    ```

    ### What Happens Next

    1. The Ouroboros system detects the `missing_tool_for` fact
    2. It generates a Go tool implementation with:
       - JSON input/output protocol
       - Safety validation
       - Proper error handling
    3. The tool is compiled and registered
    4. On your next turn, the tool appears in the catalog

    ### Tool Safety

    Generated tools are sandboxed and cannot:
    - Import unsafe, syscall, or plugin packages
    - Make arbitrary network calls
    - Modify system files outside the project
    - Execute shell commands directly

- id: "capability/tool_request_protocol"
  category: "protocol"
  subcategory: "tool_generation"
  priority: 80
  is_mandatory: true
  depends_on: ["capability/tool_thinking"]
  content: |
    ## Tool Request Protocol

    When invoking tools via Piggyback Protocol:

    ### Single Tool Request
    ```json
    "tool_requests": [
      {
        "id": "req_1",
        "tool_name": "read_file",
        "tool_args": {"path": "internal/core/kernel.go"},
        "purpose": "Understand kernel implementation",
        "required": true
      }
    ]
    ```

    ### Multiple Tool Requests
    ```json
    "tool_requests": [
      {
        "id": "req_1",
        "tool_name": "read_file",
        "tool_args": {"path": "go.mod"},
        "purpose": "Check dependencies"
      },
      {
        "id": "req_2",
        "tool_name": "glob",
        "tool_args": {"pattern": "internal/**/*.go"},
        "purpose": "List all Go files"
      }
    ]
    ```

    ### Field Semantics

    - **id**: Unique request ID for result correlation (e.g., "req_1", "tool_abc123")
    - **tool_name**: Exact tool name from the catalog
    - **tool_args**: Arguments matching the tool's schema
    - **purpose**: Why this tool is being invoked (for debugging/learning)
    - **required**: If true, blocks execution; if false/omitted, best-effort

    ### After Tool Execution

    Tool results are automatically injected into your context on the next turn.
    You can reference them by the request ID.

- id: "capability/ouroboros_awareness"
  category: "capability"
  subcategory: "tool_generation"
  priority: 75
  is_mandatory: false
  depends_on: ["capability/tool_thinking"]
  content: |
    ## Ouroboros Self-Extension

    The Ouroboros system enables codeNERD to generate new tools at runtime.
    This is a key part of the autopoiesis (self-creation) capability.

    ### When to Request Tool Generation

    Request a new tool when:
    - You need to perform a specific operation not in the catalog
    - The operation is reusable across multiple tasks
    - Existing tools don't provide the needed functionality

    Don't request generation when:
    - The capability exists but you haven't checked the catalog
    - A simple combination of existing tools would suffice
    - The operation is a one-time, trivial task

    ### Tool Generation Pipeline

    1. **Detection**: `missing_tool_for` fact triggers Ouroboros
    2. **Specification**: LLM generates tool spec (name, description, schema)
    3. **Implementation**: LLM writes Go code with JSON I/O
    4. **Safety Check**: Static analysis validates no forbidden imports/calls
    5. **Thunderdome**: Adversarial testing with edge cases
    6. **Compilation**: `go build` produces executable
    7. **Registration**: Tool added to registry with Mangle facts

    ### Generated Tool Locations

    - Source: `.nerd/tools/.generated/<tool_name>.go`
    - Binary: `.nerd/tools/.compiled/<tool_name>`
    - Metadata: `registered_tool(<tool_name>, <path>, <timestamp>)` in kernel

    ### Tool Quality Feedback

    After using a generated tool, the system tracks:
    - Execution success/failure rate
    - Output quality scores
    - Edge case handling

    Poor-performing tools may be refined or regenerated.
