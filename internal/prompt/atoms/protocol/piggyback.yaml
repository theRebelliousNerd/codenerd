# Piggyback Protocol Atoms
# These atoms define the dual-channel output format required by all shards

- id: "protocol/piggyback/envelope"
  category: "protocol"
  subcategory: "envelope"
  priority: 100
  is_mandatory: true
  content: |
    ## OUTPUT PROTOCOL: PIGGYBACK ENVELOPE (MANDATORY)

    You MUST output a JSON object with this exact structure. No exceptions.

    ```json
    {
      "control_packet": {
        "intent_classification": {
          "category": "/mutation|/query|/instruction",
          "verb": "/action_verb",
          "target": "target_path_or_concept",
          "constraint": "any constraints",
          "confidence": 0.0-1.0
        },
        "mangle_updates": [
          "predicate(arg1, arg2)."
        ],
        "memory_operations": [
          {"op": "promote_to_long_term|forget|store_vector|note", "key": "...", "value": "..."}
        ],
        "reasoning_trace": "Step-by-step reasoning...",
        "context_feedback": {
          "overall_usefulness": 0.8,
          "helpful_facts": ["file_topology", "test_state"],
          "noise_facts": ["dom_node"],
          "missing_context": "optional: what would have helped"
        }
      },
      "surface_response": "Human-readable response to the user"
    }
    ```

- id: "protocol/piggyback/thought_first"
  category: "protocol"
  subcategory: "ordering"
  priority: 95
  is_mandatory: true
  depends_on: ["protocol/piggyback/envelope"]
  content: |
    ## CRITICAL: THOUGHT-FIRST ORDERING

    The control_packet MUST be fully formed BEFORE you write the surface_response.

    **Think first, speak second.**

    1. Analyze the task
    2. Determine the intent classification
    3. Identify Mangle updates needed
    4. Form your reasoning trace
    5. ONLY THEN write the surface_response

    The reasoning_trace in control_packet must demonstrate your complete analysis
    BEFORE the surface_response is generated. This is not optional.

- id: "protocol/piggyback/reasoning_trace"
  category: "protocol"
  subcategory: "reasoning"
  priority: 90
  is_mandatory: true
  depends_on: ["protocol/piggyback/envelope"]
  content: |
    ## REASONING TRACE REQUIREMENTS

    The reasoning_trace field must demonstrate systematic analysis.

    ### MINIMUM LENGTH
    50 words minimum. If your reasoning is shorter, you have not thought enough.

    ### REQUIRED ELEMENTS
    1. What inputs/context were analyzed?
    2. What decision points were encountered?
    3. What alternatives were considered?
    4. Why was the chosen approach selected?
    5. What confidence level and why?

    ### FORMAT
    Use numbered steps to show your thought process:
    "1. Analyzed inputs: X, Y, Z. 2. Identified constraint: A. 3. Selected approach: B because C. 4. Confidence: 0.85 due to D."

- id: "protocol/piggyback/mangle_updates"
  category: "protocol"
  subcategory: "mangle"
  priority: 85
  is_mandatory: false
  depends_on: ["protocol/piggyback/envelope"]
  content: |
    ## MANGLE UPDATE PROTOCOL

    The mangle_updates array contains facts to be asserted to the kernel.

    ### SYNTAX RULES
    - Each entry is a valid Mangle predicate
    - Atoms start with / (e.g., /coder, /fix, /high)
    - Strings are quoted with double quotes
    - Every statement ends with a period
    - Variables are UPPERCASE (but you emit facts, not rules)

    ### COMMON PREDICATES
    ```
    # Task completion
    task_completed("task_id", /success).
    task_completed("task_id", /failure).

    # File operations
    file_modified("path/to/file.go").
    file_created("path/to/new.go").

    # Diagnostics
    diagnostic_found(/error, "description", "file:line").
    test_result("test_name", /pass).

    # Learning
    pattern_observed("pattern_type", "context").
    ```

- id: "protocol/piggyback/memory_ops"
  category: "protocol"
  subcategory: "memory"
  priority: 80
  is_mandatory: false
  depends_on: ["protocol/piggyback/envelope"]
  content: |
    ## MEMORY OPERATIONS PROTOCOL

    The memory_operations array manages long-term knowledge.

    ### OPERATION TYPES

    **promote_to_long_term**: Elevate a fact to persistent storage
    ```json
    {"op": "promote_to_long_term", "key": "user_preference/indent", "value": "tabs"}
    ```

    **forget**: Remove a fact from memory (rare, use carefully)
    ```json
    {"op": "forget", "key": "obsolete_pattern"}
    ```

    **store_vector**: Store content with embedding for semantic search
    ```json
    {"op": "store_vector", "key": "code_snippet/auth_pattern", "value": "...code..."}
    ```

    **note**: Short-term observation for session context
    ```json
    {"op": "note", "key": "current_focus", "value": "refactoring auth module"}
    ```

    ### USAGE GUIDELINES
    - Use sparingly: not every response needs memory operations
    - Be specific with keys: use hierarchical naming (category/subcategory/item)
    - Include enough context in values for future retrieval

- id: "protocol/piggyback/self_correction"
  category: "protocol"
  subcategory: "correction"
  priority: 75
  is_mandatory: false
  depends_on: ["protocol/piggyback/envelope"]
  content: |
    ## SELF-CORRECTION PROTOCOL

    If you detect issues in your analysis, you MUST self-correct before finalizing.

    ### SELF-CORRECTION TRIGGERS
    - Conflicting constraints detected
    - Low confidence in initial assessment (< 0.70)
    - Multiple valid interpretations exist
    - New information contradicts earlier reasoning

    ### SELF-CORRECTION FORMAT
    Include in control_packet:
    ```json
    {
      "self_correction": {
        "original_assessment": "Initial thought...",
        "correction_trigger": "What caused reconsideration",
        "final_assessment": "Corrected conclusion",
        "reason": "Why the correction was necessary"
      }
    }
    ```

    ### EXAMPLE
    ```json
    {
      "self_correction": {
        "original_assessment": "/transport layer based on handler.go name",
        "correction_trigger": "Found sql.DB import",
        "final_assessment": "/integration layer - wiring code",
        "reason": "File imports both HTTP and SQL, indicating integration/main.go pattern"
      }
    }
    ```

- id: "protocol/piggyback/context_feedback"
  category: "protocol"
  subcategory: "feedback"
  priority: 70
  is_mandatory: false
  depends_on: ["protocol/piggyback/envelope"]
  content: |
    ## CONTEXT FEEDBACK PROTOCOL (Encouraged on Every Turn)

    Help improve future context selection by rating the usefulness of provided facts.
    This creates a feedback loop that learns which predicates help for each task type.

    ### WHEN TO INCLUDE
    Include context_feedback on EVERY turn. This provides continuous learning signal
    to improve spreading activation scoring over time.

    ### CONTEXT FEEDBACK FORMAT
    Include in control_packet:
    ```json
    {
      "context_feedback": {
        "overall_usefulness": 0.8,
        "helpful_facts": ["file_topology", "test_state", "symbol_graph"],
        "noise_facts": ["dom_node", "browser_state"],
        "missing_context": "needed dependency graph for this refactoring"
      }
    }
    ```

    ### FIELD DESCRIPTIONS

    **overall_usefulness** (0.0-1.0): How useful was the provided context?
    - 1.0 = Exactly what was needed, couldn't have done better
    - 0.7-0.9 = Very helpful, had most of what was needed
    - 0.4-0.6 = Somewhat useful, but had to work around gaps
    - 0.1-0.3 = Mostly irrelevant, only a few useful facts
    - 0.0 = Completely irrelevant context

    **helpful_facts** (array of predicate names): Which predicates were useful?
    - Use predicate type names, not specific instances
    - Examples: "file_topology", "test_state", "error_context", "symbol_graph"
    - Only list predicates that meaningfully contributed to your response

    **noise_facts** (array of predicate names): Which predicates were irrelevant?
    - Predicates that added tokens but no value
    - Examples: "dom_node" when doing Go debugging, "browser_state" for CLI work
    - Helps prune future context windows

    **missing_context** (string, optional): What would have helped?
    - Describe what information you wished you had
    - Examples: "needed call graph for this function", "needed test coverage data"
    - Helps identify gaps in spreading activation

    ### EXAMPLES BY TASK TYPE

    **Debugging a test failure:**
    ```json
    {
      "context_feedback": {
        "overall_usefulness": 0.85,
        "helpful_facts": ["test_state", "error_context", "file_topology"],
        "noise_facts": ["browser_state", "campaign_context"],
        "missing_context": "stack trace from the actual panic"
      }
    }
    ```

    **Code review:**
    ```json
    {
      "context_feedback": {
        "overall_usefulness": 0.7,
        "helpful_facts": ["symbol_graph", "file_topology", "diagnostic_found"],
        "noise_facts": ["session_context", "dom_node"],
        "missing_context": "git blame for recently changed lines"
      }
    }
    ```

    **Research task:**
    ```json
    {
      "context_feedback": {
        "overall_usefulness": 0.6,
        "helpful_facts": ["project_context", "dependency_link"],
        "noise_facts": ["test_state", "error_context"],
        "missing_context": "API documentation for external dependencies"
      }
    }
    ```
