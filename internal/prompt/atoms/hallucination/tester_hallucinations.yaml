# Tester Shard Hallucination Prevention Atoms
# These atoms prevent common failure modes specific to test generation

- id: "hallucination/tester/missing_assertions"
  category: "hallucination"
  subcategory: "prevention"
  priority: 95
  is_mandatory: true
  shard_types: ["/tester"]
  content: |
    ## HALLUCINATION PREVENTION: MISSING ASSERTIONS

    You will be tempted to write tests without meaningful assertions.

    ### WRONG
    ```go
    func TestUserCreate(t *testing.T) {
        user := NewUser("test")
        _ = user  // No assertion!
    }
    ```

    ### CORRECT
    ```go
    func TestUserCreate(t *testing.T) {
        user := NewUser("test")
        if user.Name != "test" {
            t.Errorf("expected name 'test', got %q", user.Name)
        }
    }
    ```

    ### MITIGATION
    - Every test MUST have at least one assertion
    - Use t.Error, t.Errorf, t.Fatal, or t.Fatalf
    - Or use testify: assert.Equal, require.NoError
    - A test without assertions is not a test

- id: "hallucination/tester/testing_implementation"
  category: "hallucination"
  subcategory: "prevention"
  priority: 90
  is_mandatory: true
  shard_types: ["/tester"]
  content: |
    ## HALLUCINATION PREVENTION: TESTING IMPLEMENTATION DETAILS

    You will be tempted to test HOW instead of WHAT.

    ### WRONG
    ```go
    func TestUserSave(t *testing.T) {
        // Testing that SQL is called with specific query
        mock.ExpectQuery("INSERT INTO users.*").WillReturnRows(...)
    }
    ```

    ### CORRECT
    ```go
    func TestUserSave(t *testing.T) {
        // Testing that user is persisted and retrievable
        err := repo.Save(ctx, user)
        require.NoError(t, err)

        retrieved, err := repo.Get(ctx, user.ID)
        require.NoError(t, err)
        assert.Equal(t, user.Name, retrieved.Name)
    }
    ```

    ### MITIGATION
    - Test behavior, not implementation
    - Tests should survive refactoring
    - Ask: "If I change HOW this works, should the test fail?"
    - Only test the public contract

- id: "hallucination/tester/flaky_tests"
  category: "hallucination"
  subcategory: "prevention"
  priority: 90
  is_mandatory: true
  shard_types: ["/tester"]
  content: |
    ## HALLUCINATION PREVENTION: FLAKY TESTS

    You will be tempted to write tests that depend on external state.

    ### WRONG
    ```go
    func TestTimeout(t *testing.T) {
        start := time.Now()
        DoSomething()
        if time.Since(start) > 100*time.Millisecond {
            t.Error("too slow")  // Flaky on slow CI
        }
    }
    ```

    ### CORRECT
    ```go
    func TestTimeout(t *testing.T) {
        clock := NewMockClock()
        ctx := WithClock(context.Background(), clock)

        done := make(chan struct{})
        go func() {
            DoSomethingWithContext(ctx)
            close(done)
        }()

        clock.Advance(100 * time.Millisecond)
        // Deterministic timeout behavior
    }
    ```

    ### MITIGATION
    - Mock time-dependent operations
    - Mock network calls
    - Use deterministic inputs
    - Seed random number generators

- id: "hallucination/tester/ignored_errors"
  category: "hallucination"
  subcategory: "prevention"
  priority: 95
  is_mandatory: true
  shard_types: ["/tester"]
  content: |
    ## HALLUCINATION PREVENTION: IGNORED ERRORS IN TESTS

    You will be tempted to ignore errors in test setup.

    ### WRONG
    ```go
    func TestUserProcess(t *testing.T) {
        user, _ := CreateUser()  // Error ignored!
        Process(user)
    }
    ```

    ### CORRECT
    ```go
    func TestUserProcess(t *testing.T) {
        user, err := CreateUser()
        require.NoError(t, err, "setup: failed to create user")

        err = Process(user)
        require.NoError(t, err)
    }
    ```

    ### MITIGATION
    - Use require.NoError for setup errors (fatal on failure)
    - Use assert.NoError for test assertions (continues on failure)
    - Never use _ for error returns in tests
    - Failed setup should fail the test immediately

- id: "hallucination/tester/happy_path_bias"
  category: "hallucination"
  subcategory: "prevention"
  priority: 90
  is_mandatory: true
  shard_types: ["/tester"]
  content: |
    ## HALLUCINATION PREVENTION: HAPPY PATH BIAS

    You will be tempted to only test successful scenarios.

    ### WRONG
    ```go
    func TestParseInt(t *testing.T) {
        result, _ := ParseInt("123")
        assert.Equal(t, 123, result)
    }
    // Missing: empty string, invalid chars, overflow, nil
    ```

    ### CORRECT
    ```go
    func TestParseInt(t *testing.T) {
        tests := []struct {
            name    string
            input   string
            want    int
            wantErr bool
        }{
            {"valid integer", "123", 123, false},
            {"empty string", "", 0, true},
            {"invalid chars", "abc", 0, true},
            {"overflow", "999999999999999999999", 0, true},
            {"negative", "-42", -42, false},
        }
        // ... run tests
    }
    ```

    ### MITIGATION
    - For every happy path test, write at least one sad path test
    - Test nil, empty, boundary, and error cases
    - Ask: "How can this function fail?"

- id: "hallucination/tester/dependent_test"
  category: "hallucination"
  subcategory: "prevention"
  priority: 95
  is_mandatory: true
  shard_types: ["/tester"]
  content: |
    ## HALLUCINATION PREVENTION: DEPENDENT TESTS

    You will be tempted to write tests that depend on each other.

    ### WRONG
    ```go
    func TestCreateUser(t *testing.T) {
        testUser = CreateUser("test")  // Global state
    }

    func TestGetUser(t *testing.T) {
        user := GetUser(testUser.ID)  // Depends on TestCreateUser
    }
    ```

    ### CORRECT
    ```go
    func TestCreateUser(t *testing.T) {
        user := CreateUser("test")
        assert.NotEmpty(t, user.ID)
    }

    func TestGetUser(t *testing.T) {
        // Each test sets up its own state
        user := CreateUser("test")
        retrieved := GetUser(user.ID)
        assert.Equal(t, user.ID, retrieved.ID)
    }
    ```

    ### MITIGATION
    - Tests must pass when run in any order
    - Each test creates its own data
    - Use t.Cleanup for teardown
    - Never use global test state

- id: "hallucination/tester/global_pollution"
  category: "hallucination"
  subcategory: "prevention"
  priority: 90
  is_mandatory: true
  shard_types: ["/tester"]
  content: |
    ## HALLUCINATION PREVENTION: GLOBAL POLLUTION

    You will be tempted to modify global state without cleanup.

    ### WRONG
    ```go
    func TestWithEnvVar(t *testing.T) {
        os.Setenv("CONFIG_PATH", "/test")  // Modified global state!
        result := LoadConfig()
        // ENV var left polluted for other tests
    }
    ```

    ### CORRECT
    ```go
    func TestWithEnvVar(t *testing.T) {
        original := os.Getenv("CONFIG_PATH")
        t.Cleanup(func() {
            os.Setenv("CONFIG_PATH", original)
        })

        os.Setenv("CONFIG_PATH", "/test")
        result := LoadConfig()
    }
    ```

    ### MITIGATION
    - Save state before, restore after (even on failure)
    - Use t.Cleanup for automatic teardown
    - Use defer for cleanup in helper functions
    - Run tests with -shuffle=on to catch pollution

- id: "hallucination/tester/assertion_copypaste"
  category: "hallucination"
  subcategory: "prevention"
  priority: 85
  is_mandatory: true
  shard_types: ["/tester"]
  content: |
    ## HALLUCINATION PREVENTION: ASSERTION COPY-PASTE

    You will be tempted to copy assertions without adapting them.

    ### WRONG
    ```go
    func TestParseJSON(t *testing.T) {
        tests := []struct{ name, input, want string }{
            {"valid", `{"name":"a"}`, "a"},
            {"empty", `{}`, "a"},  // Copy-paste error! Should be ""
        }
        for _, tt := range tests {
            result := ParseJSON(tt.input)
            assert.Equal(t, tt.want, result.Name)
        }
    }
    ```

    ### CORRECT
    Review each test case individually and ensure the expected value
    matches the scenario being tested.

    ### MITIGATION
    - Review each assertion individually
    - Name test cases descriptively
    - Verify expected values match the scenario
    - Run tests to ensure they can actually fail

- id: "hallucination/tester/brittle_mock"
  category: "hallucination"
  subcategory: "prevention"
  priority: 85
  is_mandatory: true
  shard_types: ["/tester"]
  content: |
    ## HALLUCINATION PREVENTION: BRITTLE MOCK

    You will be tempted to create mocks that are too specific.

    ### WRONG
    ```go
    mock.ExpectQuery("SELECT id, name, email FROM users WHERE id = ?").
        WithArgs("123").
        WillReturnRows(...)
    // Breaks if column order changes or new column added
    ```

    ### CORRECT
    ```go
    mock.ExpectQuery("SELECT .* FROM users WHERE").
        WithArgs("123").
        WillReturnRows(...)
    // Survives minor SQL changes
    ```

    ### MITIGATION
    - Use flexible matching, not exact string comparison
    - Test behavior, not implementation details
    - Mock at the interface level when possible
    - Ask: "Will this test survive a refactor?"
