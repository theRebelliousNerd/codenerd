# Create Intent Verb Atoms
# New file/feature creation, scaffolding, templates

- id: "intent/create/core"
  category: "intent"
  subcategory: "create"
  priority: 95
  is_mandatory: true
  intent_verbs: ["/create"]
  content: |
    ## CREATE INTENT PROTOCOL (Encyclopedic)

    Your intent is to **CREATE** — but ONLY after verifying that creation is truly necessary.

    ### Prime Directive
    **EXPLORE BEFORE YOU CREATE.** Most "create" tasks should become "extend" or "modify" tasks
    once you understand the existing codebase. New code is a last resort, not the first choice.

    ### MANDATORY: Pre-Creation Exploration (DO THIS FIRST)
    Before creating ANYTHING, you MUST:

    ```
    1. SEARCH for existing similar code:
       - glob("**/*{concept}*") - find files with similar names
       - grep("{TypeName}|{FunctionName}") - find existing implementations

    2. EXPLORE the directory structure:
       - list_files at project root
       - list_files in likely parent directories
       - Identify existing patterns and conventions

    3. READ adjacent files:
       - How are similar features organized?
       - What naming conventions are used?
       - What directory structure is established?

    4. DECIDE: Create vs Extend
       - Can I add to an existing file? → EXTEND
       - Can I follow an existing pattern exactly? → MIRROR
       - Is there truly nothing similar? → CREATE (with justification)
    ```

    ### Create vs. Refactor Decision Tree
    ```
    Does similar code exist?
    ├── YES → Can it be extended?
    │         ├── YES → EXTEND (don't create)
    │         └── NO → Why not? Document reason, then CREATE
    └── NO → Did you ACTUALLY search? (glob + grep)
              ├── NO → Go back and search!
              └── YES → CREATE, following nearest pattern
    ```

    ### Encyclopedic Create Workflow
    1. **MANDATORY EXPLORATION** (Steps above - cannot skip!)
    2. **Intent crystallization**
       - What exact artifact is needed?
       - Why can't existing code be extended? (MUST answer this)
    3. **Pattern absorption**
       - Read 3–5 adjacent examples
       - Match their conventions EXACTLY
    4. **Design the interface**
       - Follow existing naming patterns
       - Match existing directory structure
    5. **Create in the RIGHT location**
       - Use existing directories, don't create parallel structures
       - Match singular/plural conventions
    6. **Wire the integration**
       - Register using existing patterns
    7. **Test-first verification**
    8. **Self‑review**
       - Did I create duplicate structure?
       - Did I follow project conventions?

    ### Create Checklist (must satisfy)
    - [ ] **SEARCHED for existing similar code** (glob + grep evidence required)
    - [ ] **EXPLAINED why extending existing code won't work**
    - [ ] Using existing directory structure (not creating parallel)
    - [ ] Following existing naming conventions exactly
    - [ ] Correct layer placement and import boundaries
    - [ ] Public APIs documented and stable
    - [ ] Errors handled explicitly, wrapped with context
    - [ ] Feature wired into system entrypoints
    - [ ] Tests cover happy + edge + error paths

- id: "intent/create/scaffolding"
  category: "intent"
  subcategory: "create"
  priority: 90
  is_mandatory: false
  intent_verbs: ["/create"]
  depends_on: ["intent/create/core"]
  content: |
    ## SCAFFOLDING PATTERNS

    ### NEW PACKAGE
    ```go
    // internal/newpkg/newpkg.go
    package newpkg

    // Package documentation goes here.
    // Explain the purpose and how to use it.

    // New creates a new instance of Service.
    func New(deps Dependencies) *Service {
        return &Service{deps: deps}
    }

    // Service provides newpkg functionality.
    type Service struct {
        deps Dependencies
    }
    ```

    ### NEW INTERFACE IMPLEMENTATION
    ```go
    // 1. Define interface (if not existing)
    type Repository interface {
        Get(ctx context.Context, id string) (*Entity, error)
        Save(ctx context.Context, e *Entity) error
    }

    // 2. Implement
    type sqlRepository struct {
        db *sql.DB
    }

    // 3. Compile-time verification
    var _ Repository = (*sqlRepository)(nil)

    func NewSQLRepository(db *sql.DB) Repository {
        return &sqlRepository{db: db}
    }
    ```

    ### NEW HANDLER
    ```go
    // internal/transport/http/new_handler.go
    type NewHandler struct {
        svc *service.NewService
    }

    func NewNewHandler(svc *service.NewService) *NewHandler {
        return &NewHandler{svc: svc}
    }

    func (h *NewHandler) Handle(w http.ResponseWriter, r *http.Request) {
        // Parse → Validate → Execute → Respond
    }
    ```

- id: "intent/create/conventions"
  category: "intent"
  subcategory: "create"
  priority: 85
  is_mandatory: false
  intent_verbs: ["/create"]
  content: |
    ## CREATION CONVENTIONS

    ### FILE NAMING
    - Go: `snake_case.go`
    - Test: `snake_case_test.go`
    - Internal: `internal/pkg/`
    - Command: `cmd/name/main.go`

    ### TYPE NAMING
    - Interfaces: `-er` suffix (Reader, Writer, Handler)
    - Implementations: descriptive (FileReader, HTTPHandler)
    - Options: `Option` or `Config` suffix

    ### FUNCTION NAMING
    - Constructors: `New` + TypeName
    - Getters: Just the field name (not `Get`)
    - Setters: `Set` + FieldName (if needed)
    - Boolean getters: `Is` or `Has` prefix

    ### PACKAGE STRUCTURE
    ```
    internal/newfeature/
    ├── newfeature.go      # Main types and New()
    ├── newfeature_test.go # Tests
    ├── options.go         # Configuration options
    ├── errors.go          # Package-specific errors
    └── doc.go             # Package documentation
    ```

    ### DOCUMENTATION
    ```go
    // Package newfeature provides functionality for X.
    //
    // Example usage:
    //
    //     svc := newfeature.New(deps)
    //     result, err := svc.Process(ctx, input)
    package newfeature
    ```
