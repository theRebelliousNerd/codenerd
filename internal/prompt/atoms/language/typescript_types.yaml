# TypeScript Type System - Encyclopedic Reference
# Comprehensive guidance for unions, intersections, narrowing, discriminated unions, conditionals, mapped types

- id: "language/typescript/types/fundamentals"
  category: "language"
  subcategory: "typescript"
  priority: 88
  is_mandatory: false
  shard_types: ["/coder", "/reviewer"]
  languages: ["/typescript"]
  content: |
    ## TYPE SYSTEM FUNDAMENTALS

    ### Union Types (`|`)
    ```typescript
    type StringOrNumber = string | number;
    type Status = "pending" | "approved" | "rejected"; // Literal union

    // Narrowing required before use
    function process(value: StringOrNumber) {
      if (typeof value === "string") {
        return value.toUpperCase(); // string operations available
      }
      return value.toFixed(2); // number operations available
    }
    ```

    ### Intersection Types (`&`)
    ```typescript
    type Timestamped = { createdAt: Date; updatedAt: Date };
    type Named = { name: string };
    type NamedTimestamped = Named & Timestamped;
    // Has: name, createdAt, updatedAt
    ```

    ### `Object` vs `object` vs `{}`

    | Type | Includes | Excludes | Use Case |
    |------|----------|----------|----------|
    | `Object` | ALL values (including primitives) | `null`, `undefined` | **NEVER use** |
    | `object` | Objects, arrays, functions | Primitives | When you need "any object" |
    | `{}` | ALL values except null/undefined | `null`, `undefined` | Rarely - avoid |

    ```typescript
    // Object - accepts primitives (BAD)
    function bad(value: Object): void {}
    bad(42);      // OK - number gets boxed

    // object - rejects primitives (GOOD)
    function good(value: object): void {}
    good(42);      // ERROR
    good({});      // OK

    // BEST: Use Record or specific interfaces
    function best(value: Record<string, unknown>): void {}
    ```

  content_concise: |
    ## Type Fundamentals
    - Union `|`: One of several types, requires narrowing
    - Intersection `&`: Combines types
    - Use `object` not `Object` for "any object"
    - Prefer `Record<string, unknown>` over `{}`

- id: "language/typescript/types/narrowing"
  category: "language"
  subcategory: "typescript"
  priority: 89
  is_mandatory: false
  shard_types: ["/coder", "/reviewer"]
  languages: ["/typescript"]
  content: |
    ## TYPE NARROWING AND GUARDS

    ### Built-in Type Guards

    | Guard | Use Case | Limitation |
    |-------|----------|------------|
    | `typeof` | Primitive types | string, number, boolean, symbol, function, object, bigint, undefined only |
    | `instanceof` | Class instances | Doesn't work with interfaces |
    | `in` | Property existence | Requires string literal property name |
    | `===` / `!==` | Literal narrowing | Only narrows to literal values |

    ```typescript
    // typeof - for primitives
    function format(value: string | number): string {
      if (typeof value === "string") {
        return value.trim();
      }
      return value.toFixed(2);
    }

    // instanceof - for classes
    function processError(err: Error | string): string {
      if (err instanceof Error) {
        return err.message;
      }
      return err;
    }

    // in operator - for property existence
    type Fish = { swim: () => void };
    type Bird = { fly: () => void };

    function move(animal: Fish | Bird) {
      if ("swim" in animal) {
        animal.swim();
      } else {
        animal.fly();
      }
    }
    ```

    ### User-Defined Type Guards (CRITICAL PATTERN)
    ```typescript
    // Return type is `value is Type` - this makes it a type guard
    function isString(value: unknown): value is string {
      return typeof value === "string";
    }

    function isError(value: unknown): value is Error {
      return value instanceof Error;
    }

    // CRITICAL: Array.filter doesn't narrow without type guard!
    const mixed: (string | number)[] = [1, "a", 2, "b"];

    // WITHOUT type guard - filter does NOT narrow:
    const stillMixed = mixed.filter(x => typeof x === "string");
    // Type is still (string | number)[]!

    // WITH type guard - properly narrowed:
    const strings: string[] = mixed.filter(isString); // string[]
    ```

  content_concise: |
    ## Type Narrowing
    - `typeof`: primitives only (string, number, boolean, etc.)
    - `instanceof`: class instances only
    - `in`: property existence
    - User-defined guards: `(value: unknown): value is T`
    - CRITICAL: Use type guards with `.filter()` to narrow arrays

- id: "language/typescript/types/discriminated_unions"
  category: "language"
  subcategory: "typescript"
  priority: 90
  is_mandatory: false
  shard_types: ["/coder", "/reviewer"]
  languages: ["/typescript"]
  content: |
    ## DISCRIMINATED UNIONS (CRITICAL PATTERN)

    Use a literal type property (discriminant) to narrow union types.

    ### The Pattern
    ```typescript
    interface Square {
      kind: "square";  // Discriminant property
      size: number;
    }

    interface Rectangle {
      kind: "rectangle";
      width: number;
      height: number;
    }

    interface Circle {
      kind: "circle";
      radius: number;
    }

    type Shape = Square | Rectangle | Circle;

    function area(s: Shape): number {
      switch (s.kind) {
        case "square":
          return s.size * s.size;
        case "rectangle":
          return s.width * s.height;
        case "circle":
          return Math.PI * s.radius ** 2;
      }
    }
    ```

    ### Exhaustiveness Checking with `never`
    ```typescript
    function assertNever(x: never): never {
      throw new Error(`Unexpected value: ${x}`);
    }

    function areaExhaustive(s: Shape): number {
      switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.width * s.height;
        case "circle": return Math.PI * s.radius ** 2;
        default: return assertNever(s); // Compile error if case missing!
      }
    }
    ```

    ### API Response Pattern
    ```typescript
    type ApiResponse<T> =
      | { status: "success"; data: T }
      | { status: "error"; error: string }
      | { status: "loading" };

    function handleResponse<T>(response: ApiResponse<T>): T | null {
      switch (response.status) {
        case "success":
          return response.data;
        case "error":
          console.error(response.error);
          return null;
        case "loading":
          return null;
      }
    }
    ```

    ### Redux Action Pattern
    ```typescript
    type Action =
      | { type: "ADD_TODO"; payload: { text: string } }
      | { type: "TOGGLE_TODO"; payload: { id: number } }
      | { type: "DELETE_TODO"; payload: { id: number } };

    function reducer(state: State, action: Action): State {
      switch (action.type) {
        case "ADD_TODO":
          return { ...state, todos: [...state.todos, action.payload] };
        case "TOGGLE_TODO":
          // action.payload is { id: number } here
          return toggleTodo(state, action.payload.id);
        case "DELETE_TODO":
          return deleteTodo(state, action.payload.id);
      }
    }
    ```

  content_concise: |
    ## Discriminated Unions
    - Add literal `kind`/`type` property to each variant
    - Switch on discriminant for type-safe narrowing
    - Use `assertNever(x: never)` for exhaustiveness checking
    - Perfect for: API responses, Redux actions, state machines

- id: "language/typescript/types/conditional"
  category: "language"
  subcategory: "typescript"
  priority: 85
  is_mandatory: false
  shard_types: ["/coder", "/reviewer"]
  languages: ["/typescript"]
  content: |
    ## CONDITIONAL TYPES

    **Syntax:** `T extends U ? X : Y`

    ### Basic Patterns
    ```typescript
    // Basic conditional
    type IsString<T> = T extends string ? true : false;

    // Extract array element type
    type ElementType<T> = T extends (infer U)[] ? U : T;
    type A = ElementType<string[]>; // string
    type B = ElementType<number>;   // number

    // Extract function return type
    type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

    // Extract function parameters
    type MyParameters<T> = T extends (...args: infer P) => any ? P : never;
    ```

    ### Distributive Conditional Types
    ```typescript
    // Distributes over unions automatically
    type NotString<T> = T extends string ? never : T;
    type Result = NotString<string | number | boolean>;
    // number | boolean (string filtered out)

    // Filtering with never
    type OnlyStrings<T> = T extends string ? T : never;
    type Strings = OnlyStrings<string | number | boolean>;
    // string
    ```

    ### The `infer` Keyword
    ```typescript
    // CRITICAL: infer only works inside conditional extends clause

    // Extract Promise inner type
    type Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T;

    // Extract first element of tuple
    type First<T> = T extends [infer F, ...any[]] ? F : never;
    type F = First<[1, 2, 3]>; // 1

    // Extract last element
    type Last<T> = T extends [...any[], infer L] ? L : never;
    type L = Last<[1, 2, 3]>; // 3

    // Multiple infer positions
    // Co-variant positions -> union
    type Foo<T> = T extends { a: infer U; b: infer U } ? U : never;
    type T1 = Foo<{ a: string; b: number }>; // string | number
    ```

  content_concise: |
    ## Conditional Types
    - Syntax: `T extends U ? X : Y`
    - `infer` keyword to extract types
    - Distributes over unions automatically
    - Use `never` to filter from unions

- id: "language/typescript/types/mapped"
  category: "language"
  subcategory: "typescript"
  priority: 84
  is_mandatory: false
  shard_types: ["/coder", "/reviewer"]
  languages: ["/typescript"]
  content: |
    ## MAPPED TYPES

    ### Basic Mapped Types
    ```typescript
    // Make all properties optional
    type Partial<T> = {
      [P in keyof T]?: T[P];
    };

    // Make all properties readonly
    type Readonly<T> = {
      readonly [P in keyof T]: T[P];
    };

    // Make all properties required
    type Required<T> = {
      [P in keyof T]-?: T[P];
    };
    ```

    ### Key Remapping with `as` Clause (TS 4.1+)
    ```typescript
    type Getters<T> = {
      [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
    };

    interface Person {
      name: string;
      age: number;
    }

    type PersonGetters = Getters<Person>;
    // { getName: () => string; getAge: () => number; }

    // Filter keys using never
    type RemoveKind<T> = {
      [K in keyof T as Exclude<K, "kind">]: T[K];
    };
    ```

    ### Template Literal Types
    ```typescript
    // Basic template literal
    type Greeting = `Hello, ${string}`;
    const g: Greeting = "Hello, World"; // OK

    // Union expansion
    type Color = "red" | "blue";
    type Size = "small" | "large";
    type Variant = `${Size}-${Color}`;
    // "small-red" | "small-blue" | "large-red" | "large-blue"

    // Event handlers pattern
    type Event = "click" | "hover" | "scroll";
    type EventHandlers = {
      [K in Event as `on${Capitalize<K>}`]: () => void;
    };
    // { onClick: () => void; onHover: () => void; onScroll: () => void; }
    ```

    ### Built-in String Manipulation
    ```typescript
    type Upper = Uppercase<"hello">;     // "HELLO"
    type Lower = Lowercase<"HELLO">;     // "hello"
    type Cap = Capitalize<"hello">;      // "Hello"
    type Uncap = Uncapitalize<"Hello">;  // "hello"
    ```

  content_concise: |
    ## Mapped Types
    - `[P in keyof T]`: Iterate over properties
    - `as` clause for key remapping
    - Template literals: `` `${Size}-${Color}` ``
    - Built-ins: `Uppercase`, `Lowercase`, `Capitalize`

- id: "language/typescript/types/satisfies_const"
  category: "language"
  subcategory: "typescript"
  priority: 86
  is_mandatory: false
  shard_types: ["/coder", "/reviewer"]
  languages: ["/typescript"]
  content: |
    ## SATISFIES AND CONST ASSERTIONS

    ### The `satisfies` Operator (TS 4.9+)
    Validate a value matches a type WITHOUT widening the inferred type.

    ```typescript
    // Problem with `as`
    const colors1 = {
      red: [255, 0, 0],
      green: "#00ff00",
    } as Record<string, string | number[]>;
    // colors1.red is now string | number[] (widened!)

    // Solution with `satisfies`
    const colors2 = {
      red: [255, 0, 0],
      green: "#00ff00",
    } satisfies Record<string, string | number[]>;
    // colors2.red is number[] (precise type preserved!)
    // colors2.green is string (precise type preserved!)

    colors2.red.map(x => x); // OK - knows it's an array
    colors2.green.toUpperCase(); // OK - knows it's a string

    // Catch typos in object keys
    type Colors = "red" | "green" | "blue";
    const palette = {
      red: "#ff0000",
      gren: "#00ff00", // ERROR: typo caught!
    } satisfies Record<Colors, string>;
    ```

    ### Const Assertions
    ```typescript
    // Without as const - types widen
    const obj1 = { x: 10, y: 20 }; // { x: number, y: number }
    const arr1 = [1, 2, 3];        // number[]

    // With as const - literal types preserved
    const obj2 = { x: 10, y: 20 } as const;
    // { readonly x: 10, readonly y: 20 }

    const arr2 = [1, 2, 3] as const;
    // readonly [1, 2, 3]

    // Useful for literal union derivation
    const STATUSES = ["pending", "approved", "rejected"] as const;
    type Status = typeof STATUSES[number];
    // "pending" | "approved" | "rejected"

    // Prevents mutation
    arr2.push(4); // ERROR: Property 'push' does not exist
    ```

    ### Combining `satisfies` and `as const`
    ```typescript
    const config = {
      api: "https://example.com",
      timeout: 5000,
      retries: 3,
    } as const satisfies {
      api: string;
      timeout: number;
      retries: number;
    };
    // Type is readonly AND validated
    ```

  content_concise: |
    ## satisfies and as const
    - `satisfies`: Validate type without widening
    - `as const`: Preserve literal types, make readonly
    - `satisfies` catches typos in object keys
    - Combine: `{...} as const satisfies Type`
