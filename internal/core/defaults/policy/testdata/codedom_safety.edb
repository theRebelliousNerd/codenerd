# Test Data for CodeDOM Safety
# Scenario: A mix of safe and unsafe edit attempts

# 1. Goroutine Leak Risk
# async_worker is a goroutine function
code_element("fn:async_worker", /function, "worker.go", 10, 20).
go_goroutine("fn:async_worker").
# It does NOT use context (missing go_uses_context)
is_async_context("fn:async_worker").
# User attempts to modify it
element_modified("fn:async_worker", "session1", 123456).

# 2. Safe Async Function
# safe_worker is a goroutine function
code_element("fn:safe_worker", /function, "safe.go", 10, 20).
go_goroutine("fn:safe_worker").
# It uses context
go_uses_context("fn:safe_worker").
is_async_context("fn:safe_worker").
# User attempts to modify it
element_modified("fn:safe_worker", "session1", 123456).


# 3. Generated Code Modification
generated_code("gen.go", /protobuf, "Code generated by protoc-gen-go. DO NOT EDIT.").
code_element("fn:gen_func", /function, "gen.go", 5, 10).
# User attempts to modify it
element_modified("fn:gen_func", "session1", 123456).

# 4. Public Function without Tests
code_element("fn:public_api", /function, "api.go", 10, 20).
element_visibility("fn:public_api", /public).
# missing has_test_coverage
element_modified("fn:public_api", "session1", 123456).

# 5. Mangle Recursion Risk
mg_recursive_rule("rule:recurse").
# Need to declare it as a code_element for safe_to_edit to work
code_element("rule:recurse", /rule, "policy.mg", 1, 1).
element_modified("rule:recurse", "session1", 123456).
