# Cortex 1.5.0 Executive Policy (IDB)
# Version: 1.5.0
# Philosophy: Logic determines Reality; the Model merely describes it.

# =============================================================================
# SECTION 1: SPREADING ACTIVATION (Context Selection)
# =============================================================================
# Per §8.1: Energy flows from the user's intent through the graph of known facts

# 1. Base Activation (Recency) - High priority for new facts
activation(Fact, 100) :- new_fact(Fact).

# 2. Spreading Activation (Dependency)
# Energy flows from goals to required tools
activation(Tool, 80) :-
    active_goal(Goal),
    tool_capabilities(Tool, Cap),
    goal_requires(Goal, Cap).

# 3. Intent-driven activation
activation(Target, 90) :-
    user_intent(_, _, _, Target, _).

# 4. File modification spreads to dependents
activation(Dep, 70) :-
    modified(File),
    dependency_link(Dep, File, _).

# 5. Context Pruning - Only high-activation facts enter working memory
context_atom(Fact) :-
    activation(Fact, Score),
    Score > 30.

# =============================================================================
# SECTION 2: STRATEGY SELECTION (§3.1)
# =============================================================================
# Different coding tasks require different logical loops

# TDD Repair Loop for bug fixes
active_strategy(/tdd_repair_loop) :-
    user_intent(_, _, /fix, _, _),
    diagnostic(/error, _, _, _, _).

active_strategy(/tdd_repair_loop) :-
    user_intent(_, _, /debug, _, _).

# Exploration for queries
active_strategy(/breadth_first_survey) :-
    user_intent(_, /query, /explore, _, _).

active_strategy(/breadth_first_survey) :-
    user_intent(_, /query, /explain, _, _).

# Code generation for scaffolding
active_strategy(/project_init) :-
    user_intent(_, /mutation, /scaffold, _, _).

active_strategy(/project_init) :-
    user_intent(_, /mutation, /init, _, _).

# Refactor guard for modifications
active_strategy(/refactor_guard) :-
    user_intent(_, /mutation, /refactor, _, _).

# =============================================================================
# SECTION 3: TDD REPAIR LOOP (§3.2)
# =============================================================================
# State machine: Write -> Test -> Analyze -> Fix

# State Transitions
next_action(/read_error_log) :-
    test_state(/failing),
    retry_count(N), N < 3.

next_action(/analyze_root_cause) :-
    test_state(/log_read).

next_action(/generate_patch) :-
    test_state(/cause_found).

next_action(/run_tests) :-
    test_state(/patch_applied).

next_action(/run_tests) :-
    test_state(/unknown),
    user_intent(_, _, /test, _, _).

# Surrender Logic - Escalate after 3 retries
next_action(/escalate_to_user) :-
    test_state(/failing),
    retry_count(N), N >= 3.

# Success state
next_action(/complete) :-
    test_state(/passing).

# =============================================================================
# SECTION 4: FOCUS RESOLUTION & CLARIFICATION (§1.2)
# =============================================================================

# Clarification threshold - block execution if confidence < 0.85
clarification_needed(Ref) :-
    focus_resolution(Ref, _, _, Score),
    Score < 0.85.

# Block action derivation when clarification is needed
next_action(/interrogative_mode) :-
    clarification_needed(_).

# Ambiguity detection
ambiguity_detected(Param) :-
    ambiguity_flag(Param, _, _).

next_action(/interrogative_mode) :-
    ambiguity_detected(_).

# =============================================================================
# SECTION 5: IMPACT ANALYSIS & REFACTORING GUARD (§3.3)
# =============================================================================

# Direct impact
impacted(X) :-
    dependency_link(X, Y, _),
    modified(Y).

# Transitive closure (recursive impact)
impacted(X) :-
    dependency_link(X, Z, _),
    impacted(Z).

# Unsafe to refactor if impacted code lacks test coverage
unsafe_to_refactor(Target) :-
    impacted(Target),
    !test_coverage(Target).

# Block refactoring when unsafe
block_refactor(Target, "uncovered_dependency") :-
    unsafe_to_refactor(Target).

# =============================================================================
# SECTION 6: COMMIT BARRIER (§2.2)
# =============================================================================

# Cannot commit if there are errors
block_commit("Build Broken") :-
    diagnostic(/error, _, _, _, _).

block_commit("Tests Failing") :-
    test_state(/failing).

# Helper for safe negation
has_block_commit() :-
    block_commit(_).

# Safe to commit
safe_to_commit() :-
    !has_block_commit().

# =============================================================================
# SECTION 7: CONSTITUTIONAL LOGIC / SAFETY (§5.0)
# =============================================================================

# Default deny - permitted must be positively derived
permitted(Action) :-
    safe_action(Action).

permitted(Action) :-
    dangerous_action(Action),
    admin_override(User),
    signed_approval(Action).

# Dangerous action patterns - marked by explicit facts
# dangerous_action is derived from danger_marker facts
# (String matching to be implemented via custom builtins)

# Network policy - allowlist approach
allowed_domain("github.com").
allowed_domain("pypi.org").
allowed_domain("crates.io").
allowed_domain("npmjs.com").
allowed_domain("pkg.go.dev").

# Note: network_permitted and security_violation require string matching
# which will be implemented via custom Go builtins at runtime

# =============================================================================
# SECTION 8: SHARD DELEGATION (§7.0)
# =============================================================================

# Delegate to researcher for init/explore
delegate_task(/researcher, "Initialize codebase analysis", /pending) :-
    user_intent(_, _, /init, _, _).

delegate_task(/researcher, Task, /pending) :-
    user_intent(_, _, /research, Task, _).

delegate_task(/researcher, Task, /pending) :-
    user_intent(_, /query, /explore, Task, _).

# Delegate to coder for coding tasks
delegate_task(/coder, Task, /pending) :-
    user_intent(_, /mutation, /implement, Task, _).

# Note: Negation with unbound variables is unsafe in Datalog
# Delegate refactoring task only when block_refactor facts don't exist
# This is handled at runtime by checking block_refactor before delegation
delegate_task(/coder, Task, /pending) :-
    user_intent(_, /mutation, /refactor, Task, _).

# Delegate to tester for test tasks
delegate_task(/tester, Task, /pending) :-
    user_intent(_, _, /test, Task, _).

delegate_task(/tester, "Generate tests for impacted code", /pending) :-
    impacted(File),
    !test_coverage(File).

# Delegate to reviewer for review tasks
delegate_task(/reviewer, Task, /pending) :-
    user_intent(_, _, /review, Task, _).

# =============================================================================
# SECTION 9: BROWSER PHYSICS (§9.0)
# =============================================================================

# Spatial reasoning - element to the left
left_of(A, B) :-
    geometry(A, Ax, _, _, _),
    geometry(B, Bx, _, _, _),
    Ax < Bx.

# Element above another
above(A, B) :-
    geometry(A, _, Ay, _, _),
    geometry(B, _, By, _, _),
    Ay < By.

# Honeypot detection via CSS properties
honeypot_detected(ID) :-
    computed_style(ID, "display", "none").

honeypot_detected(ID) :-
    computed_style(ID, "visibility", "hidden").

honeypot_detected(ID) :-
    computed_style(ID, "opacity", "0").

honeypot_detected(ID) :-
    geometry(ID, _, _, 0, _).

honeypot_detected(ID) :-
    geometry(ID, _, _, _, 0).

# Safe interactive elements (not honeypots)
safe_interactable(ID) :-
    interactable(ID, _),
    !honeypot_detected(ID).

# Target checkbox to the left of label text
target_checkbox(CheckID, LabelText) :-
    dom_node(CheckID, /input, _),
    attr(CheckID, "type", "checkbox"),
    visible_text(TextID, LabelText),
    left_of(CheckID, TextID).

# =============================================================================
# SECTION 10: TOOL CAPABILITY MAPPING & ACTION MAPPING
# =============================================================================

# Tool capabilities for spreading activation
tool_capabilities(/fs_read, /read).
tool_capabilities(/fs_write, /write).
tool_capabilities(/exec_cmd, /execute).
tool_capabilities(/browser, /navigate).
tool_capabilities(/browser, /click).
tool_capabilities(/browser, /type).
tool_capabilities(/code_graph, /analyze).
tool_capabilities(/code_graph, /dependencies).

# Goal capability requirements
goal_requires(Goal, /read) :-
    user_intent(_, /query, _, Goal, _).

goal_requires(Goal, /write) :-
    user_intent(_, /mutation, _, Goal, _).

goal_requires(Goal, /execute) :-
    user_intent(_, _, /run, Goal, _).

goal_requires(Goal, /analyze) :-
    user_intent(_, _, /explain, Goal, _).

# Action Mappings: Map intent verbs to executable actions
# Core actions
action_mapping(/explain, /analyze_code).
action_mapping(/read, /fs_read).
action_mapping(/search, /search_files).
action_mapping(/run, /exec_cmd).
action_mapping(/test, /run_tests).

# Code review & analysis actions (delegate to reviewer shard)
action_mapping(/review, /delegate_reviewer).
action_mapping(/security, /delegate_reviewer).
action_mapping(/analyze, /delegate_reviewer).

# Code mutation actions (delegate to coder shard)
action_mapping(/fix, /delegate_coder).
action_mapping(/refactor, /delegate_coder).
action_mapping(/create, /delegate_coder).
action_mapping(/delete, /delegate_coder).
action_mapping(/write, /fs_write).
action_mapping(/document, /delegate_coder).
action_mapping(/commit, /delegate_coder).

# Debug actions
action_mapping(/debug, /delegate_coder).

# Research actions (delegate to researcher shard)
action_mapping(/research, /delegate_researcher).
action_mapping(/explore, /delegate_researcher).

# Autopoiesis/Tool generation actions (delegate to tool_generator shard)
action_mapping(/generate_tool, /delegate_tool_generator).
action_mapping(/refine_tool, /delegate_tool_generator).
action_mapping(/list_tools, /delegate_tool_generator).
action_mapping(/tool_status, /delegate_tool_generator).

# Diff actions
action_mapping(/diff, /show_diff).

# Derive next_action from intent and mapping
next_action(Action) :-
    user_intent(_, _, Verb, _, _),
    action_mapping(Verb, Action).

# Specific file system actions
next_action(/fs_read) :-
    user_intent(_, _, /read, _, _).

next_action(/fs_write) :-
    user_intent(_, _, /write, _, _).

# Review delegation - high confidence triggers immediate delegation
delegate_task(/reviewer, Target, /pending) :-
    user_intent(_, _, /review, Target, _).

delegate_task(/reviewer, Target, /pending) :-
    user_intent(_, _, /security, Target, _).

delegate_task(/reviewer, Target, /pending) :-
    user_intent(_, _, /analyze, Target, _).

# Tool generator delegation - autopoiesis operations
delegate_task(/tool_generator, Target, /pending) :-
    user_intent(_, _, /generate_tool, Target, _).

delegate_task(/tool_generator, Target, /pending) :-
    user_intent(_, _, /refine_tool, Target, _).

delegate_task(/tool_generator, "", /pending) :-
    user_intent(_, _, /list_tools, _, _).

delegate_task(/tool_generator, Target, /pending) :-
    user_intent(_, _, /tool_status, Target, _).

# Auto-delegate when missing capability detected (implicit tool generation)
delegate_task(/tool_generator, Cap, /pending) :-
    missing_tool_for(_, Cap),
    !tool_generation_blocked(Cap).

# =============================================================================
# SECTION 11: ABDUCTIVE REASONING (§8.2)
# =============================================================================

# Abductive reasoning: missing hypotheses are symptoms without known causes
# This rule requires all variables to be bound in the negated atom
# Implementation: We use a helper predicate has_known_cause to track which symptoms have causes
# Then negate against that helper

# Mark symptoms that have known causes
has_known_cause(Symptom) :-
    known_cause(Symptom, _).

# Symptoms without causes need investigation
# Note: Using has_known_cause helper to ensure safe negation
missing_hypothesis(Symptom) :-
    symptom(_, Symptom),
    !has_known_cause(Symptom).

# Trigger clarification for missing hypotheses
next_action(/interrogative_mode) :-
    missing_hypothesis(_).

# =============================================================================
# SECTION 12: AUTOPOIESIS / LEARNING (§8.3)
# =============================================================================

# Detect repeated rejection pattern
preference_signal(Pattern) :-
    rejection_count(Pattern, N),
    N >= 3.

# Promote to long-term memory
promote_to_long_term(FactType, FactValue) :-
    preference_signal(Pattern),
    derived_rule(Pattern, FactType, FactValue).

# Autopoiesis: Missing Tool Detection
# Helper: derive when we HAVE a capability (for safe negation)
has_capability(Cap) :-
    tool_capabilities(_, Cap).

# Derive missing_tool_for if user intent requires a capability we don't have
missing_tool_for(IntentID, Cap) :-
    user_intent(IntentID, _, _, _, _),
    goal_requires(_, Cap),
    !has_capability(Cap).

# Trigger tool generation if tool is missing
next_action(/generate_tool) :-
    missing_tool_for(_, _).

# =============================================================================
# SECTION 12B: OUROBOROS LOOP - TOOL SELF-GENERATION
# =============================================================================
# The Ouroboros Loop: Detection → Specification → Safety → Compile → Register → Execute
# Named after the ancient symbol of a serpent eating its own tail.

# Tool exists in registry
tool_exists(ToolName) :-
    tool_registered(ToolName, _).

# Tool is ready for execution (compiled and registered)
tool_ready(ToolName) :-
    tool_exists(ToolName),
    tool_hash(ToolName, _).

# Capability is available if any tool provides it
capability_available(Cap) :-
    tool_capability(_, Cap).

# Need new tool when capability missing and user explicitly requests it
explicit_tool_request(Cap) :-
    user_intent(_, /mutation, /generate_tool, Cap, _).

# Need new tool when repeated failures suggest capability gap
capability_gap_detected(Cap) :-
    task_failure_reason(_, "missing_capability", Cap),
    task_failure_count(Cap, N),
    N >= 2.

# Tool generation is permitted (safety gate)
tool_generation_permitted(Cap) :-
    missing_tool_for(_, Cap),
    !tool_generation_blocked(Cap).

# Block tool generation for dangerous capabilities
tool_generation_blocked(Cap) :-
    dangerous_capability(Cap).

# Define dangerous capabilities that should never be auto-generated
dangerous_capability(/exec_arbitrary).
dangerous_capability(/network_unconstrained).
dangerous_capability(/system_admin).
dangerous_capability(/credential_access).

# Ouroboros next actions
next_action(/ouroboros_detect) :-
    capability_gap_detected(_).

next_action(/ouroboros_generate) :-
    tool_generation_permitted(_),
    !has_active_generation().

next_action(/ouroboros_compile) :-
    tool_source_ready(ToolName),
    tool_safety_verified(ToolName),
    !tool_compiled(ToolName).

next_action(/ouroboros_register) :-
    tool_compiled(ToolName),
    !is_tool_registered(ToolName).

# Track active tool generation (prevent parallel generations)
active_generation(ToolName) :-
    generation_state(ToolName, /in_progress).

# Helper for safe negation - true if any generation is in progress
has_active_generation() :-
    active_generation(_).

# Helper for safe negation - true if tool is registered
is_tool_registered(ToolName) :-
    tool_registered(ToolName, _).

# Tool lifecycle states
tool_lifecycle(ToolName, /detected) :-
    missing_tool_for(_, ToolName).

tool_lifecycle(ToolName, /generating) :-
    generation_state(ToolName, /in_progress).

tool_lifecycle(ToolName, /safety_check) :-
    tool_source_ready(ToolName),
    !tool_safety_verified(ToolName).

tool_lifecycle(ToolName, /compiling) :-
    tool_safety_verified(ToolName),
    !tool_compiled(ToolName).

tool_lifecycle(ToolName, /ready) :-
    tool_ready(ToolName).

# =============================================================================
# SECTION 12C: TOOL LEARNING AND OPTIMIZATION
# =============================================================================
# Learning from tool executions to improve future generations.

# Tool quality tracking
tool_quality_poor(ToolName) :-
    tool_learning(ToolName, Executions, SuccessRate, AvgQuality),
    Executions >= 3,
    AvgQuality < 0.5.

tool_quality_acceptable(ToolName) :-
    tool_learning(ToolName, Executions, _, AvgQuality),
    Executions >= 3,
    AvgQuality >= 0.5,
    AvgQuality < 0.8.

tool_quality_good(ToolName) :-
    tool_learning(ToolName, Executions, _, AvgQuality),
    Executions >= 3,
    AvgQuality >= 0.8.

# Trigger refinement for poor quality tools
tool_needs_refinement(ToolName) :-
    tool_quality_poor(ToolName).

tool_needs_refinement(ToolName) :-
    tool_known_issue(ToolName, /pagination),
    tool_learning(ToolName, Executions, _, _),
    Executions >= 2.

tool_needs_refinement(ToolName) :-
    tool_known_issue(ToolName, /incomplete),
    tool_learning(ToolName, Executions, _, _),
    Executions >= 2.

# Next action for refinement
next_action(/refine_tool) :-
    tool_needs_refinement(_),
    !has_active_refinement().

# Prevent parallel refinements
active_refinement(ToolName) :-
    refinement_state(ToolName, /in_progress).

# Helper for safe negation - true if any refinement is in progress
has_active_refinement() :-
    active_refinement(_).

# Learning pattern signals
learning_pattern_detected(ToolName, IssueType) :-
    tool_known_issue(ToolName, IssueType),
    issue_occurrence_count(ToolName, IssueType, Count),
    Count >= 3.

# Promote learnings to tool generation hints
tool_generation_hint(Capability, "add_pagination") :-
    learning_pattern_detected(_, /pagination),
    capability_similar_to(Capability, _).

tool_generation_hint(Capability, "increase_limits") :-
    learning_pattern_detected(_, /incomplete),
    capability_similar_to(Capability, _).

tool_generation_hint(Capability, "add_retry") :-
    learning_pattern_detected(_, /rate_limit),
    capability_similar_to(Capability, _).

# Track refinement success
refinement_effective(ToolName) :-
    tool_refined(ToolName, OldVersion, NewVersion),
    version_quality(ToolName, OldVersion, OldQuality),
    version_quality(ToolName, NewVersion, NewQuality),
    NewQuality > OldQuality.

# Escalate if refinement didn't help
escalate_to_user(ToolName, "refinement_ineffective") :-
    tool_refined(ToolName, _, _),
    tool_quality_poor(ToolName),
    refinement_count(ToolName, Count),
    Count >= 2.

# =============================================================================
# SECTION 13: GIT-AWARE SAFETY / CHESTERTON'S FENCE (§21)
# =============================================================================

# Recent change by another author (within 2 days)
recent_change_by_other(File) :-
    git_history(File, _, Author, Age, _),
    current_user(CurrentUser),
    Author != CurrentUser,
    Age < 2.

# Chesterton's Fence warning - warn before deleting recently-changed code
chesterton_fence_warning(File, "recent_change_by_other") :-
    user_intent(_, /mutation, /delete, File, _),
    recent_change_by_other(File).

chesterton_fence_warning(File, "high_churn_file") :-
    user_intent(_, /mutation, /refactor, File, _),
    churn_rate(File, Freq),
    Freq > 5.0.

# Trigger clarification for Chesterton's Fence
clarification_needed(File) :-
    chesterton_fence_warning(File, _).

# =============================================================================
# SECTION 14: SHADOW MODE / COUNTERFACTUAL REASONING (§22)
# =============================================================================

# Helper for safe negation
has_projection_violation(ActionID) :-
    projection_violation(ActionID, _).

# Safe projection - action passes safety checks in shadow simulation
safe_projection(ActionID) :-
    shadow_state(_, ActionID, /valid),
    !has_projection_violation(ActionID).

# Projection violation detection
projection_violation(ActionID, "test_failure") :-
    simulated_effect(ActionID, "diagnostic", _),
    simulated_effect(ActionID, "diagnostic_severity", /error).

projection_violation(ActionID, "security_violation") :-
    simulated_effect(ActionID, "security_violation", _).

# Block action if projection fails
block_commit("shadow_simulation_failed") :-
    pending_mutation(MutationID, _, _, _),
    !safe_projection(MutationID).

# =============================================================================
# SECTION 15: INTERACTIVE DIFF APPROVAL (§23)
# =============================================================================

# Require approval for dangerous mutations
requires_approval(MutationID) :-
    pending_mutation(MutationID, File, _, _),
    chesterton_fence_warning(File, _).

requires_approval(MutationID) :-
    pending_mutation(MutationID, File, _, _),
    impacted(File).

# Helper for safe negation
is_mutation_approved(MutationID) :-
    mutation_approved(MutationID, _, _).

# Block mutation without approval
next_action(/ask_user) :-
    pending_mutation(MutationID, _, _, _),
    requires_approval(MutationID),
    !is_mutation_approved(MutationID).

# =============================================================================
# SECTION 16: SESSION STATE / CLARIFICATION LOOP (§20)
# =============================================================================

# Resume from clarification
next_action(/resume_task) :-
    session_state(_, /suspended, _),
    focus_clarification(_).

# Clear clarification when answered
# (Handled at runtime - logic marks session as active)

# =============================================================================
# SECTION 17: KNOWLEDGE ATOM INTEGRATION (§24)
# =============================================================================

# Knowledge atoms inform strategy selection
active_strategy(/domain_expert) :-
    knowledge_atom(_, Concept, _, Confidence),
    Confidence > 0.8,
    user_intent(_, _, _, Target, _).
    # When high-confidence knowledge about the domain exists

# =============================================================================
# SECTION 18: SHARD TYPE CLASSIFICATION (§6.1 Taxonomy)
# =============================================================================

# Type 1: System Level - Always on, high reliability
shard_type(/system, /permanent, /high_reliability).

# Type 2: Ephemeral - Fast spawning, RAM only
shard_type(/ephemeral, /spawn_die, /speed_optimized).

# Type 3: Persistent LLM-Created - Background tasks, SQLite
shard_type(/persistent, /long_running, /adaptive).

# Type 4: User Configured - Deep domain knowledge
shard_type(/user, /explicit, /user_defined).

# Model capability mapping for shards
shard_model_config(/system, /high_reasoning).
shard_model_config(/ephemeral, /high_speed).
shard_model_config(/persistent, /balanced).
shard_model_config(/user, /high_reasoning).

# =============================================================================
# SECTION 19: CAMPAIGN ORCHESTRATION POLICY
# =============================================================================
# Long-running, multi-phase goal execution with context management

# -----------------------------------------------------------------------------
# 19.1 Campaign State Machine
# -----------------------------------------------------------------------------

# Current campaign is the one that's active
current_campaign(CampaignID) :-
    campaign(CampaignID, _, _, _, /active).

# Campaign execution strategy activates when a campaign is active
active_strategy(/campaign_execution) :-
    current_campaign(_).

# -----------------------------------------------------------------------------
# 19.2 Phase Eligibility & Sequencing
# -----------------------------------------------------------------------------

# Helper: check if a phase has incomplete hard dependencies
has_incomplete_hard_dep(PhaseID) :-
    phase_dependency(PhaseID, DepPhaseID, /hard),
    campaign_phase(DepPhaseID, _, _, _, Status, _),
    Status != /completed .

# A phase is eligible when all hard dependencies are complete
phase_eligible(PhaseID) :-
    campaign_phase(PhaseID, CampaignID, _, _, /pending, _),
    current_campaign(CampaignID),
    !has_incomplete_hard_dep(PhaseID).

# Helper: check if there's an earlier eligible phase
# Note: Order is bound by looking up PhaseID's order within the rule
has_earlier_phase(PhaseID) :-
    campaign_phase(PhaseID, _, _, Order, _, _),
    phase_eligible(OtherPhaseID),
    OtherPhaseID != PhaseID,
    campaign_phase(OtherPhaseID, _, _, OtherOrder, _, _),
    OtherOrder < Order.

# Current phase: lowest order eligible phase, or the one in progress
current_phase(PhaseID) :-
    campaign_phase(PhaseID, CampaignID, _, _, /in_progress, _),
    current_campaign(CampaignID).

current_phase(PhaseID) :-
    phase_eligible(PhaseID),
    !has_earlier_phase(PhaseID),
    !has_in_progress_phase().

# Helper: check if any phase is in progress
has_in_progress_phase() :-
    campaign_phase(_, CampaignID, _, _, /in_progress, _),
    current_campaign(CampaignID).

# Phase is blocked if it has incomplete hard dependencies
phase_blocked(PhaseID, "hard_dependency_incomplete") :-
    campaign_phase(PhaseID, CampaignID, _, _, /pending, _),
    current_campaign(CampaignID),
    has_incomplete_hard_dep(PhaseID).

# -----------------------------------------------------------------------------
# 19.3 Task Selection & Execution
# -----------------------------------------------------------------------------

# Helper: check if task has blocking dependencies
has_blocking_task_dep(TaskID) :-
    task_dependency(TaskID, BlockerID),
    campaign_task(BlockerID, _, _, Status, _),
    Status != /completed,
    Status != /skipped .

# Helper: check if there's an earlier pending task
has_earlier_task(TaskID, PhaseID) :-
    campaign_task(OtherTaskID, PhaseID, _, /pending, _),
    OtherTaskID != TaskID,
    task_priority(OtherTaskID, OtherPriority),
    task_priority(TaskID, Priority),
    priority_higher(OtherPriority, Priority).

# Priority ordering helper (will be implemented as Go builtin)
# For now, we use simple rules
priority_higher(/critical, /high).
priority_higher(/critical, /normal).
priority_higher(/critical, /low).
priority_higher(/high, /normal).
priority_higher(/high, /low).
priority_higher(/normal, /low).

# Next task: highest priority pending task in current phase without blockers
next_campaign_task(TaskID) :-
    current_phase(PhaseID),
    campaign_task(TaskID, PhaseID, _, /pending, _),
    !has_blocking_task_dep(TaskID).

# Derive next_action based on campaign task type
next_action(/campaign_create_file) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /file_create).

next_action(/campaign_modify_file) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /file_modify).

next_action(/campaign_write_test) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /test_write).

next_action(/campaign_run_test) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /test_run).

next_action(/campaign_research) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /research).

next_action(/campaign_verify) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /verify).

next_action(/campaign_document) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /document).

next_action(/campaign_refactor) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /refactor).

next_action(/campaign_integrate) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, /integrate).

# Auto-spawn researcher shard for research tasks
delegate_task(/researcher, Description, /pending) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, Description, _, /research).

# Auto-spawn coder shard for file creation/modification
delegate_task(/coder, Description, /pending) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, Description, _, /file_create).

delegate_task(/coder, Description, /pending) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, Description, _, /file_modify).

# Auto-spawn tester shard for test tasks
delegate_task(/tester, Description, /pending) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, Description, _, /test_write).

delegate_task(/tester, Description, /pending) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, Description, _, /test_run).

# -----------------------------------------------------------------------------
# 19.4 Context Paging (Phase-Aware Spreading Activation)
# -----------------------------------------------------------------------------

# Boost activation for current phase context
activation(Fact, 150) :-
    current_phase(PhaseID),
    phase_context_atom(PhaseID, Fact, _).

# Boost files matching current task's target
activation(Target, 140) :-
    next_campaign_task(TaskID),
    campaign_task(TaskID, _, _, _, _),
    task_artifact(TaskID, _, Target, _).

# Suppress context from completed phases
activation(Fact, -50) :-
    context_compression(PhaseID, _, _, _),
    phase_context_atom(PhaseID, Fact, _).

# -----------------------------------------------------------------------------
# 19.5 Checkpoint & Verification
# -----------------------------------------------------------------------------

# Helper: check if phase has pending checkpoint
has_pending_checkpoint(PhaseID) :-
    phase_objective(PhaseID, _, _, VerifyMethod),
    VerifyMethod != /none,
    !has_passed_checkpoint(PhaseID, VerifyMethod).

has_passed_checkpoint(PhaseID, CheckType) :-
    phase_checkpoint(PhaseID, CheckType, /true, _, _).

# Helper: check if all phase tasks are complete
has_incomplete_phase_task(PhaseID) :-
    campaign_task(_, PhaseID, _, Status, _),
    Status != /completed,
    Status != /skipped .

all_phase_tasks_complete(PhaseID) :-
    campaign_phase(PhaseID, _, _, _, _, _),
    !has_incomplete_phase_task(PhaseID).

# Trigger checkpoint when all tasks complete but checkpoint pending
next_action(/run_phase_checkpoint) :-
    current_phase(PhaseID),
    all_phase_tasks_complete(PhaseID),
    has_pending_checkpoint(PhaseID).

# Block phase completion if checkpoint failed
phase_blocked(PhaseID, "checkpoint_failed") :-
    phase_checkpoint(PhaseID, _, /false, _, _).

# -----------------------------------------------------------------------------
# 19.6 Replanning Triggers
# -----------------------------------------------------------------------------

# Helper: identify failed tasks (for counting in Go runtime)
failed_campaign_task(CampaignID, TaskID) :-
    current_campaign(CampaignID),
    campaign_task(TaskID, PhaseID, Desc, /failed, TaskType),
    campaign_phase(PhaseID, CampaignID, PhaseName, Seq, Status, Profile).

# Trigger replan on repeated failures (threshold checked in Go runtime)
# The Go runtime counts failed_campaign_task facts and triggers replan if > 3
replan_needed(CampaignID, "task_failure_cascade") :-
    current_campaign(CampaignID),
    failed_campaign_task(CampaignID, TaskID1),
    failed_campaign_task(CampaignID, TaskID2),
    failed_campaign_task(CampaignID, TaskID3),
    TaskID1 != TaskID2,
    TaskID2 != TaskID3,
    TaskID1 != TaskID3.

# Trigger replan if user provides new instruction during campaign
replan_needed(CampaignID, "user_instruction") :-
    current_campaign(CampaignID),
    user_intent(_, /instruction, _, _, _).

# Trigger replan if explicit trigger exists
replan_needed(CampaignID, Reason) :-
    replan_trigger(CampaignID, Reason, _).

# Pause and replan action
next_action(/pause_and_replan) :-
    replan_needed(_, _).

# -----------------------------------------------------------------------------
# 19.7 Campaign Helpers for Safe Negation
# -----------------------------------------------------------------------------

# Helper: true if any phase is eligible to start
has_eligible_phase() :-
    phase_eligible(_).

# Helper: true if any phase is in progress
has_in_progress_phase() :-
    campaign_phase(_, _, _, _, /in_progress, _).

# Helper: true if there's a next campaign task available
has_next_campaign_task() :-
    next_campaign_task(_).

# Helper: check if any phase is not complete
has_incomplete_phase(CampaignID) :-
    campaign_phase(_, CampaignID, _, _, Status, _),
    Status != /completed,
    Status != /skipped .

# Campaign complete when all phases complete
campaign_complete(CampaignID) :-
    current_campaign(CampaignID),
    !has_incomplete_phase(CampaignID).

next_action(/campaign_complete) :-
    campaign_complete(_).

# -----------------------------------------------------------------------------
# 19.8 Campaign Blocking Conditions
# -----------------------------------------------------------------------------

# Campaign blocked if no eligible phases and none in progress
campaign_blocked(CampaignID, "no_eligible_phases") :-
    current_campaign(CampaignID),
    !has_eligible_phase(),
    !has_in_progress_phase(),
    has_incomplete_phase(CampaignID).

# Campaign blocked if all remaining tasks are blocked
campaign_blocked(CampaignID, "all_tasks_blocked") :-
    current_campaign(CampaignID),
    current_phase(PhaseID),
    !has_next_campaign_task(),
    has_incomplete_phase_task(PhaseID).

# -----------------------------------------------------------------------------
# 19.9 Autopoiesis During Campaign
# -----------------------------------------------------------------------------

# Track successful phase types for learning (Go runtime extracts from kernel)
phase_success_pattern(PhaseType) :-
    campaign_phase(PhaseID, CampaignID, PhaseName, Seq, /completed, Profile),
    phase_objective(PhaseID, PhaseType, Desc, Priority),
    phase_checkpoint(PhaseID, CheckpointID, /true, ValidatedAt, ValidatorShard).

# Learn from phase completion - promotes success pattern for phase type
promote_to_long_term(/phase_success, PhaseType) :-
    phase_success_pattern(PhaseType).

# Learn from task failures for future avoidance
campaign_learning(CampaignID, /failure_pattern, TaskType, ErrorMsg, Now) :-
    current_campaign(CampaignID),
    campaign_task(TaskID, _, _, /failed, TaskType),
    task_error(TaskID, _, ErrorMsg),
    current_time(Now).

# -----------------------------------------------------------------------------
# 19.10 Campaign-Aware Tool Permissions
# -----------------------------------------------------------------------------

# During campaigns, only permit tools in the phase's context profile
phase_tool_permitted(Tool) :-
    current_phase(PhaseID),
    campaign_phase(PhaseID, _, _, _, _, ContextProfile),
    context_profile(ContextProfile, _, RequiredTools, _),
    tool_in_list(Tool, RequiredTools).

# Block tools not in phase profile during active campaign
# (This is advisory - Go runtime can override for safety)
# Note: Tool is bound via tool_capabilities before negation check
tool_advisory_block(Tool, "not_in_phase_profile") :-
    current_campaign(_),
    current_phase(_),
    tool_capabilities(Tool, _),
    !phase_tool_permitted(Tool).

# =============================================================================
# SECTION 20: CAMPAIGN START TRIGGER
# =============================================================================

# Trigger campaign mode when user wants to start a campaign
active_strategy(/campaign_planning) :-
    user_intent(_, /mutation, /campaign, _, _).

# Alternative triggers for campaign-like requests
active_strategy(/campaign_planning) :-
    user_intent(_, /mutation, /build, Target, _),
    target_is_large(Target).

active_strategy(/campaign_planning) :-
    user_intent(_, /mutation, /implement, Target, _),
    target_is_complex(Target).

# Heuristics for complexity (implemented in Go builtins)
# target_is_large(Target) - true if target references multiple files/features
# target_is_complex(Target) - true if target requires multiple phases
