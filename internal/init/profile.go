// Package init implements the "nerd init" cold-start initialization system.
package init

import (
	"codenerd/internal/logging"
	"codenerd/internal/prompt"
	"codenerd/internal/store"
	"codenerd/internal/world"
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	_ "github.com/mattn/go-sqlite3" // SQLite driver
)

// buildProjectProfile constructs the project profile from analysis.
func (i *Initializer) buildProjectProfile() ProjectProfile {
	profile := ProjectProfile{
		ProjectID: generateProjectID(i.config.Workspace),
		Name:      filepath.Base(i.config.Workspace),
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// Researcher shard removed - using direct detection methods
	// Profile detection is now file-based only

	// Fallback: file-based language detection if kernel didn't provide it
	if profile.Language == "" || profile.Language == "unknown" {
		profile.Language = i.detectLanguageFromFiles()
	}

	// Detect dependencies for agent recommendations
	profile.Dependencies = i.detectDependencies()

	// Detect build system (B4 enhancement)
	buildSystemInfo := i.detectBuildSystemDetails()
	profile.BuildSystem = buildSystemInfo.Name
	profile.BuildSystemInfo = &buildSystemInfo

	// Detect project type (app vs library) (D2 enhancement)
	profile.ProjectType = i.detectProjectType()

	// Detect entry points (Smart /init detection)
	profile.EntryPoints = i.detectEntryPoints()

	// Set defaults for any missing values
	if profile.Language == "" {
		profile.Language = "unknown"
	}
	if profile.Architecture == "" {
		profile.Architecture = "unknown"
	}

	return profile
}

// saveProfile writes the project profile to disk.
func (i *Initializer) saveProfile(path string, profile ProjectProfile) error {
	data, err := json.MarshalIndent(profile, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// generateFactsFile creates a Mangle facts file for the project.
func (i *Initializer) generateFactsFile(path string, profile ProjectProfile) (int, error) {
	var facts []string

	// Helper to escape strings for Mangle
	escapeString := func(s string) string {
		s = strings.ReplaceAll(s, `\`, `\\`)
		s = strings.ReplaceAll(s, `"`, `\"`)
		s = strings.ReplaceAll(s, "\n", " ")
		s = strings.ReplaceAll(s, "\r", "")
		return s
	}

	// Project identity facts - use escaped strings
	facts = append(facts, fmt.Sprintf(`project_profile("%s", "%s", "%s").`,
		escapeString(profile.ProjectID),
		escapeString(profile.Name),
		escapeString(profile.Description)))

	// Use sanitized name constants for language/framework/architecture
	if profile.Language != "" && profile.Language != "unknown" {
		facts = append(facts, fmt.Sprintf(`project_language(/%s).`, sanitizeForMangle(profile.Language)))
	}

	if profile.Framework != "" && profile.Framework != "unknown" {
		facts = append(facts, fmt.Sprintf(`project_framework(/%s).`, sanitizeForMangle(profile.Framework)))
	}

	if profile.Architecture != "" && profile.Architecture != "unknown" {
		facts = append(facts, fmt.Sprintf(`project_architecture(/%s).`, sanitizeForMangle(profile.Architecture)))
	}

	if profile.BuildSystem != "" {
		facts = append(facts, fmt.Sprintf(`build_system(/%s).`, sanitizeForMangle(profile.BuildSystem)))
	}

	// Pattern facts - sanitize each pattern
	for _, pattern := range profile.Patterns {
		facts = append(facts, fmt.Sprintf(`architectural_pattern(/%s).`, sanitizeForMangle(pattern)))
	}

	// Entry point facts - use escaped strings for paths
	for _, entry := range profile.EntryPoints {
		facts = append(facts, fmt.Sprintf(`entry_point("%s").`, escapeString(entry)))
	}

	// Write facts file
	content := "# codeNERD Project Profile Facts\n"
	content += "# Generated by: nerd init\n"
	content += fmt.Sprintf("# Timestamp: %s\n\n", time.Now().Format(time.RFC3339))

	for _, fact := range facts {
		content += fact + "\n"
	}

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return 0, err
	}

	return len(facts), nil
}

// initPreferences initializes user preferences.
func (i *Initializer) initPreferences() UserPreferences {
	prefs := UserPreferences{
		Verbosity:        "concise",
		ExplanationLevel: "intermediate",
		RequireTests:     false,
		RequireReview:    false,
	}

	// Apply hints if provided
	for _, hint := range i.config.PreferenceHints {
		switch hint {
		case "table_driven_tests":
			prefs.TestStyle = "table_driven"
		case "conventional_commits":
			prefs.CommitStyle = "conventional"
		case "strict":
			prefs.RequireTests = true
			prefs.RequireReview = true
		case "beginner":
			prefs.ExplanationLevel = "beginner"
		case "expert":
			prefs.ExplanationLevel = "expert"
		}
	}

	return prefs
}

// savePreferences writes user preferences to disk.
func (i *Initializer) savePreferences(path string, prefs UserPreferences) error {
	data, err := json.MarshalIndent(prefs, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// populateProjectAtoms creates project-specific prompt atoms based on detected
// language, frameworks, and conventions.
//
// Note: These atoms are currently persisted into `.nerd/knowledge.db` (LocalStore).
// JIT prompt compilation registers `.nerd/prompts/corpus.db` (project) and
// `.nerd/shards/{agent}_knowledge.db` (agent-scoped) databases, so if you want
// these atoms to participate in JIT selection, also ingest them into the corpus DB.
func (i *Initializer) populateProjectAtoms(profile ProjectProfile) error {
	if i.localDB == nil {
		return fmt.Errorf("local database not initialized")
	}

	var atomsToStore []*store.PromptAtom

	// Helper to create an atom
	createAtom := func(id, category, subcategory, content string, languages, frameworks []string, priority int) *store.PromptAtom {
		// Compute token count and hash
		tokenCount := estimateTokens(content)
		contentHash := computeContentHash(id, content)

		atom := &store.PromptAtom{
			AtomID:      id,
			Version:     1,
			Content:     content,
			TokenCount:  tokenCount,
			ContentHash: contentHash,
			Category:    category,
			Subcategory: subcategory,
			Languages:   languages,
			Frameworks:  frameworks,
			Priority:    priority,
			IsMandatory: false,
			CreatedAt:   time.Now(),
		}

		return atom
	}

	// ========================================================================
	// Language-Specific Atoms
	// ========================================================================

	lang := strings.ToLower(profile.Language)
	if lang != "" && lang != "unknown" {
		langConstant := "/" + sanitizeForMangle(lang)

		switch lang {
		case "go", "golang":
			// Go-specific guidance
			goAtom := createAtom(
				"project/go/conventions",
				"language",
				"conventions",
				`## Go Project Conventions

This project is written in Go. Follow these Go-specific best practices:

**Error Handling:**
- Always check and handle errors explicitly
- Use fmt.Errorf with %w verb for error wrapping
- Return errors rather than panicking in library code

**Naming:**
- Use camelCase for local variables
- Use PascalCase for exported functions/types
- Use short, descriptive names (prefer 'i' over 'index' in loops)

**Testing:**
- Write table-driven tests where appropriate
- Use t.Helper() in test helper functions
- Prefer t.Run for subtests

**Concurrency:**
- Use channels for communication between goroutines
- Prefer sync.WaitGroup or errgroup.Group for coordinating goroutines
- Always handle goroutine cleanup to prevent leaks`,
				[]string{langConstant},
				nil,
				70,
			)
			atomsToStore = append(atomsToStore, goAtom)

		case "python":
			pythonAtom := createAtom(
				"project/python/conventions",
				"language",
				"conventions",
				`## Python Project Conventions

This project is written in Python. Follow these Python-specific best practices:

**Code Style:**
- Follow PEP 8 style guidelines
- Use meaningful variable names (snake_case)
- Type hints for function signatures and class attributes

**Error Handling:**
- Use specific exception types
- Provide informative error messages
- Use context managers (with) for resource management

**Testing:**
- Use pytest for testing framework
- Write unit tests with descriptive names
- Use fixtures for test setup

**Dependencies:**
- Keep requirements.txt or pyproject.toml up to date
- Use virtual environments for isolation`,
				[]string{"/" + sanitizeForMangle("python")},
				nil,
				70,
			)
			atomsToStore = append(atomsToStore, pythonAtom)

		case "typescript", "javascript":
			tsAtom := createAtom(
				"project/typescript/conventions",
				"language",
				"conventions",
				`## TypeScript/JavaScript Project Conventions

This project uses TypeScript/JavaScript. Follow these best practices:

**Type Safety:**
- Use strict mode TypeScript settings
- Avoid 'any' type - use unknown or specific types
- Define interfaces for complex objects

**Code Style:**
- Use const/let instead of var
- Prefer arrow functions for callbacks
- Use async/await over raw Promises

**Error Handling:**
- Use try-catch for async operations
- Provide meaningful error messages
- Consider using Result types for error handling

**Testing:**
- Use Jest or Vitest for testing
- Write unit tests for business logic
- Mock external dependencies`,
				[]string{"/" + sanitizeForMangle(lang)},
				nil,
				70,
			)
			atomsToStore = append(atomsToStore, tsAtom)
		}
	}

	// ========================================================================
	// Framework-Specific Atoms
	// ========================================================================

	for _, framework := range profile.Dependencies {
		fwName := strings.ToLower(framework.Name)
		fwConstant := "/" + sanitizeForMangle(fwName)

		switch fwName {
		case "bubbletea", "github.com/charmbracelet/bubbletea":
			bubbleteaAtom := createAtom(
				"project/bubbletea/patterns",
				"framework",
				"tui",
				`## Bubbletea TUI Patterns

This project uses Bubbletea for terminal UI. Follow these patterns:

**Model-Update-View:**
- Implement tea.Model interface with Init, Update, View methods
- Keep state in the model struct
- Return Cmds from Update for async operations

**Message Handling:**
- Use type switches in Update to handle different message types
- Create custom message types for app-specific events
- Use tea.Batch to return multiple commands

**Commands:**
- Use tea.Tick for periodic updates
- Wrap I/O operations in commands
- Handle errors in messages

**Styling:**
- Use Lipgloss for consistent styling
- Define styles at package level
- Keep view rendering pure (no side effects)`,
				nil,
				[]string{fwConstant},
				75,
			)
			atomsToStore = append(atomsToStore, bubbleteaAtom)

		case "gin", "gin-gonic", "github.com/gin-gonic/gin":
			ginAtom := createAtom(
				"project/gin/patterns",
				"framework",
				"webapi",
				`## Gin Web Framework Patterns

This project uses Gin for HTTP APIs. Follow these patterns:

**Router Setup:**
- Group related routes using router.Group()
- Use middleware for cross-cutting concerns (auth, logging, CORS)
- Define clear route hierarchies

**Handler Functions:**
- Use c.BindJSON() for request body parsing
- Return consistent error responses
- Use c.JSON() for response marshaling
- Set appropriate HTTP status codes

**Error Handling:**
- Create custom error types for domain errors
- Use middleware for centralized error handling
- Log errors with sufficient context

**Testing:**
- Use httptest for testing handlers
- Test middleware separately
- Verify status codes and response bodies`,
				nil,
				[]string{fwConstant},
				75,
			)
			atomsToStore = append(atomsToStore, ginAtom)

		case "react":
			reactAtom := createAtom(
				"project/react/patterns",
				"framework",
				"frontend",
				`## React Framework Patterns

This project uses React for frontend development. Follow these patterns:

**Component Structure:**
- Prefer functional components with hooks
- Keep components small and focused
- Extract custom hooks for reusable logic

**State Management:**
- Use useState for local state
- Use useEffect for side effects
- Consider useReducer for complex state
- Use Context API for shared state

**Performance:**
- Use React.memo for expensive components
- Use useMemo and useCallback appropriately
- Avoid unnecessary re-renders

**Error Handling:**
- Use Error Boundaries for component errors
- Handle async errors in effects
- Provide user-friendly error messages`,
				nil,
				[]string{"/" + sanitizeForMangle("react")},
				75,
			)
			atomsToStore = append(atomsToStore, reactAtom)
		}
	}

	// ========================================================================
	// Project Convention Atoms (inferred from project structure)
	// ========================================================================

	// Check if project follows specific patterns
	if len(profile.TestDirectories) > 0 {
		testingAtom := createAtom(
			"project/testing/conventions",
			"methodology",
			"testing",
			fmt.Sprintf(`## Project Testing Conventions

This project has organized test directories: %s

**Testing Standards:**
- Write tests for all new functionality
- Maintain existing test coverage
- Run tests before committing changes
- Keep test files alongside source files

**Test Organization:**
- Use clear test function names that describe what is being tested
- Group related tests together
- Use test fixtures for common setup

**Coverage:**
- Aim for meaningful coverage of business logic
- Don't test trivial getters/setters
- Focus on edge cases and error paths`,
				strings.Join(profile.TestDirectories, ", ")),
			nil,
			nil,
			60,
		)
		atomsToStore = append(atomsToStore, testingAtom)
	}

	// Build system specific guidance
	if profile.BuildSystem != "" && profile.BuildSystem != "unknown" {
		buildAtom := createAtom(
			"project/build/system",
			"domain",
			"build",
			fmt.Sprintf(`## Build System

This project uses %s for building.

**Build Commands:**
- Follow existing build scripts and configurations
- Update build config when adding dependencies
- Verify builds pass before committing

**Dependencies:**
- Keep dependency declarations up to date
- Document any special build requirements
- Use version pinning for stability`,
				profile.BuildSystem),
			nil,
			nil,
			50,
		)
		atomsToStore = append(atomsToStore, buildAtom)
	}

	// Architecture pattern guidance
	if len(profile.Patterns) > 0 {
		patternsContent := "## Architectural Patterns\n\nThis project follows these patterns:\n\n"
		for _, pattern := range profile.Patterns {
			patternsContent += fmt.Sprintf("- **%s**: Follow this pattern consistently across the codebase\n", pattern)
		}

		archAtom := createAtom(
			"project/architecture/patterns",
			"domain",
			"architecture",
			patternsContent,
			nil,
			nil,
			65,
		)
		atomsToStore = append(atomsToStore, archAtom)
	}

	// ========================================================================
	// Store All Atoms
	// ========================================================================

	storedCount := 0
	for _, atom := range atomsToStore {
		if err := i.localDB.StorePromptAtom(atom); err != nil {
			// Log error but continue with other atoms
			fmt.Printf("   ⚠ Failed to store atom %s: %v\n", atom.AtomID, err)
		} else {
			storedCount++
		}
	}

	fmt.Printf("   ✓ Populated %d project-specific prompt atoms\n", storedCount)
	return nil
}

// estimateTokens estimates token count for content (chars/4 approximation)
func estimateTokens(content string) int {
	if content == "" {
		return 0
	}
	return (len(content) + 3) / 4
}

// computeContentHash computes a content hash for deduplication
func computeContentHash(id, content string) string {
	// Simple hash combining id and content
	// In production, use crypto/sha256
	combined := id + ":" + content
	return fmt.Sprintf("%x", len(combined)) // Simplified for now
}

// initSessionState creates the initial session state file.
func (i *Initializer) initSessionState(path string) error {
	state := SessionState{
		SessionID:    generateSessionID(),
		StartedAt:    time.Now(),
		LastActiveAt: time.Now(),
		TurnCount:    0,
		Suspended:    false,
	}

	data, err := json.MarshalIndent(state, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadProjectProfile loads the project profile from .nerd/profile.json
func LoadProjectProfile(workspace string) (*ProjectProfile, error) {
	path := filepath.Join(workspace, ".nerd", "profile.json")
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var profile ProjectProfile
	if err := json.Unmarshal(data, &profile); err != nil {
		return nil, err
	}

	return &profile, nil
}

// LoadPreferences loads user preferences from .nerd/preferences.json
func LoadPreferences(workspace string) (*UserPreferences, error) {
	path := filepath.Join(workspace, ".nerd", "preferences.json")
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var prefs UserPreferences
	if err := json.Unmarshal(data, &prefs); err != nil {
		return nil, err
	}

	return &prefs, nil
}

// LoadSessionState loads the session state from .nerd/session.json
func LoadSessionState(workspace string) (*SessionState, error) {
	path := filepath.Join(workspace, ".nerd", "session.json")
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var state SessionState
	if err := json.Unmarshal(data, &state); err != nil {
		return nil, err
	}

	return &state, nil
}

// SaveSessionState saves the session state to disk.
func SaveSessionState(workspace string, state *SessionState) error {
	path := filepath.Join(workspace, ".nerd", "session.json")
	data, err := json.MarshalIndent(state, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// SaveSessionHistory saves the conversation history to the sessions folder.
func SaveSessionHistory(workspace string, sessionID string, messages []ChatMessage) error {
	sessionsDir := filepath.Join(workspace, ".nerd", "sessions")
	if err := os.MkdirAll(sessionsDir, 0755); err != nil {
		return fmt.Errorf("failed to create sessions directory: %w", err)
	}

	historyFile := filepath.Join(sessionsDir, sessionID+".json")
	history := SessionHistory{
		SessionID: sessionID,
		Messages:  messages,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// If file exists, preserve CreatedAt
	if existing, err := LoadSessionHistory(workspace, sessionID); err == nil {
		history.CreatedAt = existing.CreatedAt
	}

	data, err := json.MarshalIndent(history, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(historyFile, data, 0644)
}

// LoadSessionHistory loads the conversation history for a session.
func LoadSessionHistory(workspace string, sessionID string) (*SessionHistory, error) {
	historyFile := filepath.Join(workspace, ".nerd", "sessions", sessionID+".json")
	data, err := os.ReadFile(historyFile)
	if err != nil {
		return nil, err
	}

	var history SessionHistory
	if err := json.Unmarshal(data, &history); err != nil {
		return nil, err
	}
	return &history, nil
}

// ListSessionHistories returns all available session histories.
func ListSessionHistories(workspace string) ([]string, error) {
	sessionsDir := filepath.Join(workspace, ".nerd", "sessions")
	entries, err := os.ReadDir(sessionsDir)
	if err != nil {
		if os.IsNotExist(err) {
			return []string{}, nil
		}
		return nil, err
	}

	var sessions []string
	for _, entry := range entries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".json") {
			sessions = append(sessions, strings.TrimSuffix(entry.Name(), ".json"))
		}
	}
	return sessions, nil
}

// GetLatestSession returns the most recent session ID.
func GetLatestSession(workspace string) (string, error) {
	state, err := LoadSessionState(workspace)
	if err != nil {
		return "", err
	}
	return state.SessionID, nil
}

// IsInitialized checks if the workspace has been initialized.
func IsInitialized(workspace string) bool {
	nerdDir := filepath.Join(workspace, ".nerd")
	profilePath := filepath.Join(nerdDir, "profile.json")

	if _, err := os.Stat(profilePath); err == nil {
		return true
	}
	return false
}

// createCodebaseKnowledgeBase creates a knowledge base with project-specific facts.
func (i *Initializer) createCodebaseKnowledgeBase(ctx context.Context, nerdDir string, profile ProjectProfile, scanResult *world.ScanResult) (string, int, error) {
	kbPath := filepath.Join(nerdDir, "shards", "codebase_knowledge.db")

	// Create the knowledge store
	codebaseDB, err := store.NewLocalStore(kbPath)
	if err != nil {
		return "", 0, fmt.Errorf("failed to create codebase KB: %w", err)
	}
	if err := i.ensureEmbeddingEngine(); err != nil {
		return "", 0, err
	}
	codebaseDB.SetEmbeddingEngine(i.embedEngine)
	defer codebaseDB.Close()

	atomCount := 0

	// Store project identity
	if err := codebaseDB.StoreKnowledgeAtom("project_identity", fmt.Sprintf(
		"This is %s, a %s project. %s",
		profile.Name, profile.Language, profile.Description), 1.0); err == nil {
		atomCount++
	}

	// Store language and framework
	if profile.Language != "" && profile.Language != "unknown" {
		if err := codebaseDB.StoreKnowledgeAtom("primary_language", profile.Language, 1.0); err == nil {
			atomCount++
		}
	}
	if profile.Framework != "" && profile.Framework != "unknown" {
		if err := codebaseDB.StoreKnowledgeAtom("framework", profile.Framework, 0.95); err == nil {
			atomCount++
		}
	}

	// Store file topology summary
	if scanResult != nil {
		summary := fmt.Sprintf("Project contains %d files in %d directories (%d test files).",
			scanResult.FileCount, scanResult.DirectoryCount, scanResult.TestFileCount)
		if err := codebaseDB.StoreKnowledgeAtom("file_topology_summary", summary, 0.9); err == nil {
			atomCount++
		}

		// Store language breakdown
		for lang, count := range scanResult.Languages {
			content := fmt.Sprintf("Language %s: %d files", lang, count)
			if err := codebaseDB.StoreKnowledgeAtom("language_stats", content, 0.85); err == nil {
				atomCount++
			}
		}
	}

	// Store entry points
	for _, entry := range profile.EntryPoints {
		if err := codebaseDB.StoreKnowledgeAtom("entry_point", entry, 0.95); err == nil {
			atomCount++
		}
	}

	// Store dependencies
	for _, dep := range profile.Dependencies {
		content := fmt.Sprintf("Dependency: %s (%s)", dep.Name, dep.Type)
		if err := codebaseDB.StoreKnowledgeAtom("dependency", content, 0.9); err == nil {
			atomCount++
		}
	}

	// Store architectural patterns
	for _, pattern := range profile.Patterns {
		if err := codebaseDB.StoreKnowledgeAtom("architectural_pattern", pattern, 0.85); err == nil {
			atomCount++
		}
	}

	return kbPath, atomCount, nil
}

// createCampaignKnowledgeBase creates a knowledge base for campaign orchestration.
func (i *Initializer) createCampaignKnowledgeBase(ctx context.Context, nerdDir string, profile ProjectProfile) (string, int, error) {
	kbPath := filepath.Join(nerdDir, "shards", "campaign_knowledge.db")

	campaignDB, err := store.NewLocalStore(kbPath)
	if err != nil {
		return "", 0, fmt.Errorf("failed to create campaign KB: %w", err)
	}
	if err := i.ensureEmbeddingEngine(); err != nil {
		return "", 0, err
	}
	campaignDB.SetEmbeddingEngine(i.embedEngine)
	defer campaignDB.Close()

	atomCount := 0

	// Campaign orchestration concepts
	concepts := []struct{ Key, Value string }{
		{"campaign_identity", "I am the Campaign orchestrator. I manage multi-phase development tasks."},
		{"capability_planning", "I can break complex tasks into phases with dependencies."},
		{"capability_delegation", "I can delegate tasks to specialized shards (Coder, Reviewer, Tester)."},
		{"capability_checkpoints", "I validate phase completion before proceeding."},
		{"capability_replanning", "I can replan when tasks fail or requirements change."},
		{"phase_types", "Common phases: research, design, implement, test, review, integrate."},
		{"safety_rule", "Failed checkpoints block phase advancement."},
		{"safety_rule", "Critical security findings block campaign completion."},
		{"learning_rule", "Successful patterns are promoted to long-term memory."},
		{"learning_rule", "Repeated failures trigger strategy adjustment."},
	}

	for _, concept := range concepts {
		if err := campaignDB.StoreKnowledgeAtom(concept.Key, concept.Value, 0.95); err == nil {
			atomCount++
		}
	}

	// Store project-specific campaign context
	if err := campaignDB.StoreKnowledgeAtom("project_context",
		fmt.Sprintf("Campaigns for %s (%s project)", profile.Name, profile.Language), 0.9); err == nil {
		atomCount++
	}

	// Store build system info for execution
	if profile.BuildSystem != "" {
		if err := campaignDB.StoreKnowledgeAtom("build_system", profile.BuildSystem, 0.9); err == nil {
			atomCount++
		}
	}

	// Research campaign patterns - STUBBED (JIT refactor)
	// Research is now handled on-demand via session.Executor with /researcher persona
	if i.config.LLMClient != nil && !i.config.SkipResearch {
		logging.Boot("Campaign research stubbed (JIT refactor) - using base atoms only")
	}

	return kbPath, atomCount, nil
}

// Helper functions

func generateProjectID(workspace string) string {
	// Simple hash-based ID
	h := uint64(0)
	for _, c := range workspace {
		h = h*31 + uint64(c)
	}
	return fmt.Sprintf("proj_%x", h)[:16]
}

func generateSessionID() string {
	return fmt.Sprintf("sess_%d", time.Now().UnixNano())
}

func cleanNameConstant(s string) string {
	// Remove leading "/" from Mangle name constants
	if len(s) > 0 && s[0] == '/' {
		return s[1:]
	}
	return s
}

// sanitizeForMangle converts a string to a valid Mangle name constant.
// Mangle name constants must be lowercase alphanumeric with underscores.
func sanitizeForMangle(s string) string {
	if s == "" {
		return "unknown"
	}

	// Convert to lowercase
	s = strings.ToLower(s)

	// Replace spaces and special characters with underscores
	var result strings.Builder
	for _, c := range s {
		if (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') {
			result.WriteRune(c)
		} else if c == ' ' || c == '-' || c == '.' || c == '/' {
			result.WriteRune('_')
		}
		// Skip other characters
	}

	// Ensure it doesn't start with a number
	sanitized := result.String()
	if len(sanitized) > 0 && sanitized[0] >= '0' && sanitized[0] <= '9' {
		sanitized = "n" + sanitized
	}

	// Remove consecutive underscores and trim
	for strings.Contains(sanitized, "__") {
		sanitized = strings.ReplaceAll(sanitized, "__", "_")
	}
	sanitized = strings.Trim(sanitized, "_")

	if sanitized == "" {
		return "unknown"
	}

	return sanitized
}

// initializePromptDatabase ensures the .nerd/prompts/corpus.db exists and has the
// prompt atom schema required by the JIT prompt compiler.
func (i *Initializer) initializePromptDatabase(ctx context.Context, nerdDir string) error {
	logging.Boot("Initializing prompt corpus database...")

	// Path to the corpus database
	dbPath := filepath.Join(nerdDir, "prompts", "corpus.db")

	// Ensure directory exists
	dir := filepath.Dir(dbPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", dir, err)
	}

	// Seed from baked defaults if available (never overwrites an existing DB).
	if _, err := prompt.MaterializeDefaultPromptCorpus(dbPath); err != nil {
		return fmt.Errorf("failed to materialize default prompt corpus: %w", err)
	}

	// Open database
	db, err := sql.Open("sqlite3", dbPath)
	if err != nil {
		return fmt.Errorf("failed to open database: %w", err)
	}
	defer db.Close()

	atomLoader := prompt.NewAtomLoader(nil)
	if err := atomLoader.EnsureSchema(ctx, db); err != nil {
		return fmt.Errorf("failed to ensure corpus schema: %w", err)
	}

	// Best-effort: ensure tag rows exist for embedded atoms (older corpora may be missing tags).
	if embedded, err := prompt.LoadEmbeddedCorpus(); err == nil {
		if err := prompt.HydrateAtomContextTags(ctx, db, embedded.All()); err != nil {
			logging.Boot("Warning: failed to hydrate corpus atom tags: %v", err)
		}
	}

	logging.Boot("Prompt corpus database initialized successfully")
	fmt.Println("   ✓ Prompt corpus database ready")
	return nil
}
