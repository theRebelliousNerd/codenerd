// Package init implements the "nerd init" cold-start initialization system.
package init

import (
	"codenerd/internal/store"
	"codenerd/internal/world"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"
)

// buildProjectProfile constructs the project profile from analysis.
func (i *Initializer) buildProjectProfile() ProjectProfile {
	profile := ProjectProfile{
		ProjectID: generateProjectID(i.config.Workspace),
		Name:      filepath.Base(i.config.Workspace),
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// Extract from researcher's analysis if available
	// The researcher shard stores results in its kernel
	if i.researcher != nil {
		// Try to get project type facts
		if kernel := i.researcher.GetKernel(); kernel != nil {
			// Query for project profile facts
			langFacts, _ := kernel.Query("project_language")
			if len(langFacts) > 0 && len(langFacts[0].Args) > 0 {
				profile.Language = cleanNameConstant(fmt.Sprintf("%v", langFacts[0].Args[0]))
			}

			fwFacts, _ := kernel.Query("project_framework")
			if len(fwFacts) > 0 && len(fwFacts[0].Args) > 0 {
				profile.Framework = cleanNameConstant(fmt.Sprintf("%v", fwFacts[0].Args[0]))
			}

			archFacts, _ := kernel.Query("project_architecture")
			if len(archFacts) > 0 && len(archFacts[0].Args) > 0 {
				profile.Architecture = cleanNameConstant(fmt.Sprintf("%v", archFacts[0].Args[0]))
			}

			// Count files
			fileFacts, _ := kernel.Query("file_topology")
			profile.FileCount = len(fileFacts)
		}
	}

	// Fallback: file-based language detection if kernel didn't provide it
	if profile.Language == "" || profile.Language == "unknown" {
		profile.Language = i.detectLanguageFromFiles()
	}

	// Detect dependencies for agent recommendations
	profile.Dependencies = i.detectDependencies()

	// Detect build system (B4 enhancement)
	buildSystemInfo := i.detectBuildSystemDetails()
	profile.BuildSystem = buildSystemInfo.Name
	profile.BuildSystemInfo = &buildSystemInfo

	// Detect project type (app vs library) (D2 enhancement)
	profile.ProjectType = i.detectProjectType()

	// Set defaults for any missing values
	if profile.Language == "" {
		profile.Language = "unknown"
	}
	if profile.Architecture == "" {
		profile.Architecture = "unknown"
	}

	return profile
}

// saveProfile writes the project profile to disk.
func (i *Initializer) saveProfile(path string, profile ProjectProfile) error {
	data, err := json.MarshalIndent(profile, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// generateFactsFile creates a Mangle facts file for the project.
func (i *Initializer) generateFactsFile(path string, profile ProjectProfile) (int, error) {
	var facts []string

	// Helper to escape strings for Mangle
	escapeString := func(s string) string {
		s = strings.ReplaceAll(s, `\`, `\\`)
		s = strings.ReplaceAll(s, `"`, `\"`)
		s = strings.ReplaceAll(s, "\n", " ")
		s = strings.ReplaceAll(s, "\r", "")
		return s
	}

	// Project identity facts - use escaped strings
	facts = append(facts, fmt.Sprintf(`project_profile("%s", "%s", "%s").`,
		escapeString(profile.ProjectID),
		escapeString(profile.Name),
		escapeString(profile.Description)))

	// Use sanitized name constants for language/framework/architecture
	if profile.Language != "" && profile.Language != "unknown" {
		facts = append(facts, fmt.Sprintf(`project_language(/%s).`, sanitizeForMangle(profile.Language)))
	}

	if profile.Framework != "" && profile.Framework != "unknown" {
		facts = append(facts, fmt.Sprintf(`project_framework(/%s).`, sanitizeForMangle(profile.Framework)))
	}

	if profile.Architecture != "" && profile.Architecture != "unknown" {
		facts = append(facts, fmt.Sprintf(`project_architecture(/%s).`, sanitizeForMangle(profile.Architecture)))
	}

	if profile.BuildSystem != "" {
		facts = append(facts, fmt.Sprintf(`build_system(/%s).`, sanitizeForMangle(profile.BuildSystem)))
	}

	// Pattern facts - sanitize each pattern
	for _, pattern := range profile.Patterns {
		facts = append(facts, fmt.Sprintf(`architectural_pattern(/%s).`, sanitizeForMangle(pattern)))
	}

	// Entry point facts - use escaped strings for paths
	for _, entry := range profile.EntryPoints {
		facts = append(facts, fmt.Sprintf(`entry_point("%s").`, escapeString(entry)))
	}

	// Write facts file
	content := "# codeNERD Project Profile Facts\n"
	content += "# Generated by: nerd init\n"
	content += fmt.Sprintf("# Timestamp: %s\n\n", time.Now().Format(time.RFC3339))

	for _, fact := range facts {
		content += fact + "\n"
	}

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return 0, err
	}

	return len(facts), nil
}

// initPreferences initializes user preferences.
func (i *Initializer) initPreferences() UserPreferences {
	prefs := UserPreferences{
		Verbosity:        "concise",
		ExplanationLevel: "intermediate",
		RequireTests:     false,
		RequireReview:    false,
	}

	// Apply hints if provided
	for _, hint := range i.config.PreferenceHints {
		switch hint {
		case "table_driven_tests":
			prefs.TestStyle = "table_driven"
		case "conventional_commits":
			prefs.CommitStyle = "conventional"
		case "strict":
			prefs.RequireTests = true
			prefs.RequireReview = true
		case "beginner":
			prefs.ExplanationLevel = "beginner"
		case "expert":
			prefs.ExplanationLevel = "expert"
		}
	}

	return prefs
}

// savePreferences writes user preferences to disk.
func (i *Initializer) savePreferences(path string, prefs UserPreferences) error {
	data, err := json.MarshalIndent(prefs, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// initSessionState creates the initial session state file.
func (i *Initializer) initSessionState(path string) error {
	state := SessionState{
		SessionID:    generateSessionID(),
		StartedAt:    time.Now(),
		LastActiveAt: time.Now(),
		TurnCount:    0,
		Suspended:    false,
	}

	data, err := json.MarshalIndent(state, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadProjectProfile loads the project profile from .nerd/profile.json
func LoadProjectProfile(workspace string) (*ProjectProfile, error) {
	path := filepath.Join(workspace, ".nerd", "profile.json")
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var profile ProjectProfile
	if err := json.Unmarshal(data, &profile); err != nil {
		return nil, err
	}

	return &profile, nil
}

// LoadPreferences loads user preferences from .nerd/preferences.json
func LoadPreferences(workspace string) (*UserPreferences, error) {
	path := filepath.Join(workspace, ".nerd", "preferences.json")
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var prefs UserPreferences
	if err := json.Unmarshal(data, &prefs); err != nil {
		return nil, err
	}

	return &prefs, nil
}

// LoadSessionState loads the session state from .nerd/session.json
func LoadSessionState(workspace string) (*SessionState, error) {
	path := filepath.Join(workspace, ".nerd", "session.json")
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var state SessionState
	if err := json.Unmarshal(data, &state); err != nil {
		return nil, err
	}

	return &state, nil
}

// SaveSessionState saves the session state to disk.
func SaveSessionState(workspace string, state *SessionState) error {
	path := filepath.Join(workspace, ".nerd", "session.json")
	data, err := json.MarshalIndent(state, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// SaveSessionHistory saves the conversation history to the sessions folder.
func SaveSessionHistory(workspace string, sessionID string, messages []ChatMessage) error {
	sessionsDir := filepath.Join(workspace, ".nerd", "sessions")
	if err := os.MkdirAll(sessionsDir, 0755); err != nil {
		return fmt.Errorf("failed to create sessions directory: %w", err)
	}

	historyFile := filepath.Join(sessionsDir, sessionID+".json")
	history := SessionHistory{
		SessionID: sessionID,
		Messages:  messages,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// If file exists, preserve CreatedAt
	if existing, err := LoadSessionHistory(workspace, sessionID); err == nil {
		history.CreatedAt = existing.CreatedAt
	}

	data, err := json.MarshalIndent(history, "", "  ")
	if err != nil {
		return err
	}
	return os.WriteFile(historyFile, data, 0644)
}

// LoadSessionHistory loads the conversation history for a session.
func LoadSessionHistory(workspace string, sessionID string) (*SessionHistory, error) {
	historyFile := filepath.Join(workspace, ".nerd", "sessions", sessionID+".json")
	data, err := os.ReadFile(historyFile)
	if err != nil {
		return nil, err
	}

	var history SessionHistory
	if err := json.Unmarshal(data, &history); err != nil {
		return nil, err
	}
	return &history, nil
}

// ListSessionHistories returns all available session histories.
func ListSessionHistories(workspace string) ([]string, error) {
	sessionsDir := filepath.Join(workspace, ".nerd", "sessions")
	entries, err := os.ReadDir(sessionsDir)
	if err != nil {
		if os.IsNotExist(err) {
			return []string{}, nil
		}
		return nil, err
	}

	var sessions []string
	for _, entry := range entries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".json") {
			sessions = append(sessions, strings.TrimSuffix(entry.Name(), ".json"))
		}
	}
	return sessions, nil
}

// GetLatestSession returns the most recent session ID.
func GetLatestSession(workspace string) (string, error) {
	state, err := LoadSessionState(workspace)
	if err != nil {
		return "", err
	}
	return state.SessionID, nil
}

// IsInitialized checks if the workspace has been initialized.
func IsInitialized(workspace string) bool {
	nerdDir := filepath.Join(workspace, ".nerd")
	profilePath := filepath.Join(nerdDir, "profile.json")

	if _, err := os.Stat(profilePath); err == nil {
		return true
	}
	return false
}

// createCodebaseKnowledgeBase creates a knowledge base with project-specific facts.
func (i *Initializer) createCodebaseKnowledgeBase(ctx context.Context, nerdDir string, profile ProjectProfile, scanResult *world.ScanResult) (string, int, error) {
	kbPath := filepath.Join(nerdDir, "shards", "codebase_knowledge.db")

	// Create the knowledge store
	codebaseDB, err := store.NewLocalStore(kbPath)
	if err != nil {
		return "", 0, fmt.Errorf("failed to create codebase KB: %w", err)
	}
	if err := i.ensureEmbeddingEngine(); err != nil {
		return "", 0, err
	}
	codebaseDB.SetEmbeddingEngine(i.embedEngine)
	defer codebaseDB.Close()

	atomCount := 0

	// Store project identity
	if err := codebaseDB.StoreKnowledgeAtom("project_identity", fmt.Sprintf(
		"This is %s, a %s project. %s",
		profile.Name, profile.Language, profile.Description), 1.0); err == nil {
		atomCount++
	}

	// Store language and framework
	if profile.Language != "" && profile.Language != "unknown" {
		if err := codebaseDB.StoreKnowledgeAtom("primary_language", profile.Language, 1.0); err == nil {
			atomCount++
		}
	}
	if profile.Framework != "" && profile.Framework != "unknown" {
		if err := codebaseDB.StoreKnowledgeAtom("framework", profile.Framework, 0.95); err == nil {
			atomCount++
		}
	}

	// Store file topology summary
	if scanResult != nil {
		summary := fmt.Sprintf("Project contains %d files in %d directories (%d test files).",
			scanResult.FileCount, scanResult.DirectoryCount, scanResult.TestFileCount)
		if err := codebaseDB.StoreKnowledgeAtom("file_topology_summary", summary, 0.9); err == nil {
			atomCount++
		}

		// Store language breakdown
		for lang, count := range scanResult.Languages {
			content := fmt.Sprintf("Language %s: %d files", lang, count)
			if err := codebaseDB.StoreKnowledgeAtom("language_stats", content, 0.85); err == nil {
				atomCount++
			}
		}
	}

	// Store entry points
	for _, entry := range profile.EntryPoints {
		if err := codebaseDB.StoreKnowledgeAtom("entry_point", entry, 0.95); err == nil {
			atomCount++
		}
	}

	// Store dependencies
	for _, dep := range profile.Dependencies {
		content := fmt.Sprintf("Dependency: %s (%s)", dep.Name, dep.Type)
		if err := codebaseDB.StoreKnowledgeAtom("dependency", content, 0.9); err == nil {
			atomCount++
		}
	}

	// Store architectural patterns
	for _, pattern := range profile.Patterns {
		if err := codebaseDB.StoreKnowledgeAtom("architectural_pattern", pattern, 0.85); err == nil {
			atomCount++
		}
	}

	return kbPath, atomCount, nil
}

// createCampaignKnowledgeBase creates a knowledge base for campaign orchestration.
func (i *Initializer) createCampaignKnowledgeBase(ctx context.Context, nerdDir string, profile ProjectProfile) (string, int, error) {
	kbPath := filepath.Join(nerdDir, "shards", "campaign_knowledge.db")

	campaignDB, err := store.NewLocalStore(kbPath)
	if err != nil {
		return "", 0, fmt.Errorf("failed to create campaign KB: %w", err)
	}
	if err := i.ensureEmbeddingEngine(); err != nil {
		return "", 0, err
	}
	campaignDB.SetEmbeddingEngine(i.embedEngine)
	defer campaignDB.Close()

	atomCount := 0

	// Campaign orchestration concepts
	concepts := []struct{ Key, Value string }{
		{"campaign_identity", "I am the Campaign orchestrator. I manage multi-phase development tasks."},
		{"capability_planning", "I can break complex tasks into phases with dependencies."},
		{"capability_delegation", "I can delegate tasks to specialized shards (Coder, Reviewer, Tester)."},
		{"capability_checkpoints", "I validate phase completion before proceeding."},
		{"capability_replanning", "I can replan when tasks fail or requirements change."},
		{"phase_types", "Common phases: research, design, implement, test, review, integrate."},
		{"safety_rule", "Failed checkpoints block phase advancement."},
		{"safety_rule", "Critical security findings block campaign completion."},
		{"learning_rule", "Successful patterns are promoted to long-term memory."},
		{"learning_rule", "Repeated failures trigger strategy adjustment."},
	}

	for _, concept := range concepts {
		if err := campaignDB.StoreKnowledgeAtom(concept.Key, concept.Value, 0.95); err == nil {
			atomCount++
		}
	}

	// Store project-specific campaign context
	if err := campaignDB.StoreKnowledgeAtom("project_context",
		fmt.Sprintf("Campaigns for %s (%s project)", profile.Name, profile.Language), 0.9); err == nil {
		atomCount++
	}

	// Store build system info for execution
	if profile.BuildSystem != "" {
		if err := campaignDB.StoreKnowledgeAtom("build_system", profile.BuildSystem, 0.9); err == nil {
			atomCount++
		}
	}

	// Research campaign patterns if LLM available
	if i.config.LLMClient != nil && !i.config.SkipResearch {
		// Create a dedicated researcher for campaign KB
		campaignResearcher := i.researcher
		if campaignResearcher != nil {
			// Temporarily set the campaign DB
			campaignResearcher.SetLocalDB(campaignDB)

			// Research software development workflows
			campaignResearcher.Execute(ctx, "research docs: software development workflow patterns (brief)")
			atomCount += 5

			// Restore original DB if it exists
			if i.localDB != nil {
				campaignResearcher.SetLocalDB(i.localDB)
			}
		}
	}

	return kbPath, atomCount, nil
}

// Helper functions

func generateProjectID(workspace string) string {
	// Simple hash-based ID
	h := uint64(0)
	for _, c := range workspace {
		h = h*31 + uint64(c)
	}
	return fmt.Sprintf("proj_%x", h)[:16]
}

func generateSessionID() string {
	return fmt.Sprintf("sess_%d", time.Now().UnixNano())
}

func cleanNameConstant(s string) string {
	// Remove leading "/" from Mangle name constants
	if len(s) > 0 && s[0] == '/' {
		return s[1:]
	}
	return s
}

// sanitizeForMangle converts a string to a valid Mangle name constant.
// Mangle name constants must be lowercase alphanumeric with underscores.
func sanitizeForMangle(s string) string {
	if s == "" {
		return "unknown"
	}

	// Convert to lowercase
	s = strings.ToLower(s)

	// Replace spaces and special characters with underscores
	var result strings.Builder
	for _, c := range s {
		if (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') {
			result.WriteRune(c)
		} else if c == ' ' || c == '-' || c == '.' || c == '/' {
			result.WriteRune('_')
		}
		// Skip other characters
	}

	// Ensure it doesn't start with a number
	sanitized := result.String()
	if len(sanitized) > 0 && sanitized[0] >= '0' && sanitized[0] <= '9' {
		sanitized = "n" + sanitized
	}

	// Remove consecutive underscores and trim
	for strings.Contains(sanitized, "__") {
		sanitized = strings.ReplaceAll(sanitized, "__", "_")
	}
	sanitized = strings.Trim(sanitized, "_")

	if sanitized == "" {
		return "unknown"
	}

	return sanitized
}
