#!/usr/bin/env python3
"""
analyze_logs.py - Run Mangle queries on codeNERD log facts

Executes Mangle queries against log facts generated by parse_log.py.
Supports both built-in analysis queries and custom Mangle queries.

Requires: Mangle interpreter (mg) in PATH
Install: GOBIN=~/bin go install github.com/google/mangle/interpreter/mg@latest
"""

import argparse
import json
import os
import re
import subprocess
import sys
import tempfile
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# Built-in analysis queries
BUILTIN_QUERIES = {
    "errors": """
        # All errors across categories
        ?error_entry(Time, Category, Message).
    """,

    "error_counts": """
        # Error count by category
        error_count(C, N) :-
            error_entry(_, C, _) |>
            do fn:group_by(C),
            let N = fn:Count().
        ?error_count(Category, Count).
    """,

    "warnings": """
        # All warnings
        ?warning_entry(Time, Category, Message).
    """,

    "summary": """
        # Summary statistics by category
        summary(Cat, Total, Errors, FirstTime, LastTime) :-
            log_entry(_, Cat, _, _, _, _) |>
            do fn:group_by(Cat),
            let Total = fn:Count(),
            let FirstTime = fn:Min(Time),
            let LastTime = fn:Max(Time),
            error_count(Cat, Errors).
        ?summary(Category, Total, Errors, First, Last).
    """,

    "error_context": """
        # Events within 500ms before each error
        ?error_context(ErrorTime, ErrorCat, PriorTime, PriorCat, PriorMsg).
    """,

    "flow": """
        # Category interaction flow
        ?flow_edge(From, To, Time).
    """,

    "reachability": """
        # All reachable category pairs
        ?reachable(From, To).
    """,

    "correlations": """
        # Correlated events (within 100ms window)
        ?correlated(Time1, Cat1, Time2, Cat2).
    """,

    "first_errors": """
        # First error in each category
        first_error(Cat, MinTime, Msg) :-
            error_entry(Time, Cat, Msg) |>
            do fn:group_by(Cat),
            let MinTime = fn:Min(Time).
        ?first_error(Category, Time, Message).
    """,

    "cascade": """
        # Potential error cascades (errors triggering other errors within 100ms)
        cascade(E1Time, E1Cat, E2Time, E2Cat) :-
            error_entry(E1Time, E1Cat, _),
            error_entry(E2Time, E2Cat, _),
            E2Time > E1Time,
            fn:minus(E2Time, E1Time) < 100.
        ?cascade(Error1Time, Error1Cat, Error2Time, Error2Cat).
    """,

    "root_cause": """
        # Root cause candidates (errors not preceded by other errors)
        cascade(E1Time, E1Cat, E2Time, E2Cat) :-
            error_entry(E1Time, E1Cat, _),
            error_entry(E2Time, E2Cat, _),
            E2Time > E1Time,
            fn:minus(E2Time, E1Time) < 100.
        root_cause(Time, Cat, Msg) :-
            error_entry(Time, Cat, Msg),
            !cascade(_, _, Time, Cat).
        ?root_cause(Time, Category, Message).
    """,
}


def run_mangle_query(facts_file: str, query: str, verbose: bool = False) -> Tuple[int, str, str]:
    """
    Run a Mangle query using the mg interpreter.

    Returns: (exit_code, stdout, stderr)
    """
    # Create a temporary file with the query
    with tempfile.NamedTemporaryFile(mode='w', suffix='.mg', delete=False) as f:
        # Include the facts file
        f.write(f'::load "{facts_file}"\n')
        f.write('\n')
        f.write(query.strip())
        f.write('\n')
        query_file = f.name

    try:
        # Try to find mg interpreter
        mg_path = 'mg'  # Assume it's in PATH

        # Run the query
        result = subprocess.run(
            [mg_path, query_file],
            capture_output=True,
            text=True,
            timeout=60  # 60 second timeout
        )

        if verbose:
            print(f"Query file: {query_file}", file=sys.stderr)
            with open(query_file, 'r') as f:
                print(f"Query content:\n{f.read()}", file=sys.stderr)

        return result.returncode, result.stdout, result.stderr

    except FileNotFoundError:
        return 127, "", "Error: 'mg' interpreter not found. Install with: GOBIN=~/bin go install github.com/google/mangle/interpreter/mg@latest"
    except subprocess.TimeoutExpired:
        return 124, "", "Error: Query timed out after 60 seconds"
    finally:
        # Clean up temp file
        try:
            os.unlink(query_file)
        except:
            pass


def parse_mangle_output(output: str) -> List[Dict]:
    """Parse Mangle query output into structured data."""
    results = []

    # Mangle output format varies, try to parse common patterns
    # Pattern: predicate(arg1, arg2, ...) or {binding1: value1, ...}
    for line in output.strip().split('\n'):
        line = line.strip()
        if not line or line.startswith('#') or line.startswith('::'):
            continue

        # Try to parse as fact
        match = re.match(r'^(\w+)\((.*)\)\.?$', line)
        if match:
            pred = match.group(1)
            args_str = match.group(2)
            # Simple argument parsing (doesn't handle nested structures)
            args = [a.strip().strip('"') for a in args_str.split(',')]
            results.append({'predicate': pred, 'args': args})
            continue

        # Try to parse as binding set
        if line.startswith('{') and line.endswith('}'):
            try:
                # Convert Mangle binding syntax to JSON-like
                json_like = line.replace('/','').replace(': ', '": "').replace('{', '{"').replace(', ', '", "').replace('}', '"}')
                binding = json.loads(json_like)
                results.append({'binding': binding})
            except:
                results.append({'raw': line})
            continue

        # Raw line
        if line:
            results.append({'raw': line})

    return results


def format_results(results: List[Dict], format: str) -> str:
    """Format query results for output."""
    if format == 'json':
        return json.dumps(results, indent=2)

    elif format == 'table':
        if not results:
            return "No results"

        # Try to format as table
        lines = []
        for r in results:
            if 'predicate' in r:
                lines.append(f"{r['predicate']}({', '.join(r['args'])})")
            elif 'binding' in r:
                lines.append(str(r['binding']))
            elif 'raw' in r:
                lines.append(r['raw'])
        return '\n'.join(lines)

    else:  # text
        return '\n'.join(str(r) for r in results)


def run_python_analysis(facts_file: str, analysis: str) -> str:
    """
    Run analysis using Python (fallback when mg not available).
    Parses the Mangle facts file directly and performs analysis.
    """
    # Parse facts from file
    facts = []
    try:
        with open(facts_file, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#') or line.startswith('Decl'):
                    continue
                match = re.match(r'^log_entry\((\d+),\s*/(\w+),\s*/(\w+),\s*"(.*)"\s*,\s*"(.*)"\s*,\s*(\d+)\)\.$', line)
                if match:
                    facts.append({
                        'timestamp': int(match.group(1)),
                        'category': match.group(2),
                        'level': match.group(3),
                        'message': match.group(4),
                        'file': match.group(5),
                        'line': int(match.group(6))
                    })
    except Exception as e:
        return f"Error parsing facts file: {e}"

    if not facts:
        return "No facts found in file"

    # Run analysis
    if analysis == 'errors':
        errors = [f for f in facts if f['level'] == 'error']
        if not errors:
            return "No errors found"
        lines = [f"[{f['timestamp']}] /{f['category']}: {f['message']}" for f in errors]
        return '\n'.join(lines)

    elif analysis == 'error_counts':
        from collections import Counter
        counts = Counter(f['category'] for f in facts if f['level'] == 'error')
        if not counts:
            return "No errors found"
        return '\n'.join(f"/{cat}: {count}" for cat, count in sorted(counts.items(), key=lambda x: -x[1]))

    elif analysis == 'summary':
        from collections import defaultdict
        stats = defaultdict(lambda: {'total': 0, 'errors': 0, 'first': float('inf'), 'last': 0})
        for f in facts:
            cat = f['category']
            stats[cat]['total'] += 1
            if f['level'] == 'error':
                stats[cat]['errors'] += 1
            stats[cat]['first'] = min(stats[cat]['first'], f['timestamp'])
            stats[cat]['last'] = max(stats[cat]['last'], f['timestamp'])

        lines = ["Category | Total | Errors | First | Last"]
        lines.append("-" * 60)
        for cat, s in sorted(stats.items()):
            first_dt = datetime.fromtimestamp(s['first'] / 1000).strftime('%H:%M:%S')
            last_dt = datetime.fromtimestamp(s['last'] / 1000).strftime('%H:%M:%S')
            lines.append(f"/{cat:20} | {s['total']:5} | {s['errors']:6} | {first_dt} | {last_dt}")
        return '\n'.join(lines)

    elif analysis == 'warnings':
        warnings = [f for f in facts if f['level'] == 'warn']
        if not warnings:
            return "No warnings found"
        lines = [f"[{f['timestamp']}] /{f['category']}: {f['message']}" for f in warnings]
        return '\n'.join(lines)

    elif analysis == 'categories':
        cats = set(f['category'] for f in facts)
        return '\n'.join(f"/{c}" for c in sorted(cats))

    else:
        return f"Unknown analysis: {analysis}. Available: errors, error_counts, summary, warnings, categories"


def interactive_mode(facts_file: str):
    """Run interactive REPL for log analysis."""
    print("codeNERD Log Analyzer - Interactive Mode")
    print(f"Loaded: {facts_file}")
    print("\nBuiltin queries:", ', '.join(sorted(BUILTIN_QUERIES.keys())))
    print("Commands: :quit, :help, :builtin <name>, or enter Mangle query")
    print()

    while True:
        try:
            query = input("log> ").strip()
        except (EOFError, KeyboardInterrupt):
            print("\nExiting.")
            break

        if not query:
            continue

        if query == ':quit' or query == ':q':
            break

        if query == ':help' or query == ':h':
            print("\nCommands:")
            print("  :quit, :q          Exit")
            print("  :help, :h          Show this help")
            print("  :builtin <name>    Run builtin query")
            print("  :list              List builtin queries")
            print("  :python <name>     Run Python-based analysis (no mg needed)")
            print("  <query>            Run Mangle query")
            print()
            continue

        if query == ':list' or query == ':l':
            print("\nBuiltin queries:")
            for name, q in sorted(BUILTIN_QUERIES.items()):
                desc = q.strip().split('\n')[0].replace('#', '').strip()
                print(f"  {name:15} - {desc}")
            print()
            continue

        if query.startswith(':builtin ') or query.startswith(':b '):
            name = query.split(None, 1)[1]
            if name in BUILTIN_QUERIES:
                query = BUILTIN_QUERIES[name]
                print(f"Running: {name}")
            else:
                print(f"Unknown builtin: {name}")
                continue

        if query.startswith(':python ') or query.startswith(':p '):
            name = query.split(None, 1)[1]
            result = run_python_analysis(facts_file, name)
            print(result)
            print()
            continue

        # Run the query
        code, stdout, stderr = run_mangle_query(facts_file, query)
        if stderr:
            print(f"Error: {stderr}", file=sys.stderr)
        if stdout:
            print(stdout)
        print()


def main():
    parser = argparse.ArgumentParser(
        description='Run Mangle queries on codeNERD log facts',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
    # Run builtin error analysis
    python analyze_logs.py session.mg --builtin errors

    # Custom query
    python analyze_logs.py session.mg --query "?error_entry(T, C, M)."

    # Interactive mode
    python analyze_logs.py session.mg --interactive

    # Python fallback (no mg interpreter needed)
    python analyze_logs.py session.mg --python summary

Builtin queries: ''' + ', '.join(sorted(BUILTIN_QUERIES.keys()))
    )

    parser.add_argument('facts_file', help='Mangle facts file from parse_log.py')
    parser.add_argument('--query', '-q', help='Mangle query to execute')
    parser.add_argument('--file', '-f', help='Load query from file')
    parser.add_argument('--builtin', '-b', choices=list(BUILTIN_QUERIES.keys()),
                       help='Run a builtin analysis query')
    parser.add_argument('--interactive', '-i', action='store_true',
                       help='Start interactive REPL')
    parser.add_argument('--output', '-o', default='text',
                       choices=['text', 'json', 'table'],
                       help='Output format (default: text)')
    parser.add_argument('--python', '-p',
                       choices=['errors', 'error_counts', 'summary', 'warnings', 'categories'],
                       help='Run Python analysis (no mg needed)')
    parser.add_argument('--verbose', '-v', action='store_true',
                       help='Verbose output')
    parser.add_argument('--explain', action='store_true',
                       help='Show query explanation/derivation trace')

    args = parser.parse_args()

    # Validate facts file
    if not os.path.isfile(args.facts_file):
        print(f"Error: Facts file not found: {args.facts_file}", file=sys.stderr)
        sys.exit(2)

    # Interactive mode
    if args.interactive:
        interactive_mode(args.facts_file)
        return

    # Python analysis mode
    if args.python:
        result = run_python_analysis(args.facts_file, args.python)
        print(result)
        return

    # Determine query
    query = None
    if args.builtin:
        query = BUILTIN_QUERIES[args.builtin]
    elif args.query:
        query = args.query
    elif args.file:
        with open(args.file, 'r') as f:
            query = f.read()
    else:
        print("Error: Specify --query, --builtin, --python, --file, or --interactive", file=sys.stderr)
        sys.exit(1)

    # Add explain directive if requested
    if args.explain:
        query = "::explain\n" + query

    # Run query
    code, stdout, stderr = run_mangle_query(args.facts_file, query, verbose=args.verbose)

    if stderr:
        print(stderr, file=sys.stderr)

    if stdout:
        if args.output == 'text':
            print(stdout)
        else:
            results = parse_mangle_output(stdout)
            print(format_results(results, args.output))

    sys.exit(code)


if __name__ == '__main__':
    main()
