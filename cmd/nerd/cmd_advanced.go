// Package main implements the codeNERD CLI commands.
// This file contains dream state and advanced commands.
package main

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"time"

	"codenerd/internal/core"
	"codenerd/internal/logging"
	coresys "codenerd/internal/system"
	"codenerd/internal/usage"

	"github.com/spf13/cobra"
)

// =============================================================================
// DREAM STATE & ADVANCED COMMANDS
// =============================================================================

// dreamCmd runs dream state multi-agent consultation
var dreamCmd = &cobra.Command{
	Use:   "dream <scenario>",
	Short: "Run dream state multi-agent consultation",
	Long: `Consults multiple shard agents about a hypothetical scenario.
Each agent provides their perspective without executing any changes.
Equivalent to typing "what if <scenario>" or using /dream in the TUI.

Example:
  nerd dream "we migrated from REST to GraphQL"
  nerd dream "implementing caching with Redis"`,
	Args: cobra.MinimumNArgs(1),
	RunE: runDreamState,
}

// shadowCmd runs shadow mode simulation
var shadowCmd = &cobra.Command{
	Use:   "shadow <action>",
	Short: "Simulate an action without executing",
	Long: `Runs a shadow simulation showing what would happen.
No actual changes are made - purely descriptive output.
Equivalent to /shadow in the TUI.

Example:
  nerd shadow "delete all test files"
  nerd shadow "refactor the auth module"`,
	Args: cobra.MinimumNArgs(1),
	RunE: runShadowSimulation,
}

// whatifCmd runs counterfactual query
var whatifCmd = &cobra.Command{
	Use:   "whatif <change>",
	Short: "Run counterfactual analysis",
	Long: `Analyzes what would happen if a change were made.
Uses the Mangle kernel to derive implications.
Equivalent to /whatif in the TUI.

Example:
  nerd whatif "we removed the database connection pooling"
  nerd whatif "error handling was centralized"`,
	Args: cobra.MinimumNArgs(1),
	RunE: runWhatIf,
}

// logicCmd shows kernel facts
var logicCmd = &cobra.Command{
	Use:   "logic [predicate]",
	Short: "Show Mangle kernel facts",
	Long: `Displays facts currently in the Mangle kernel.
Optionally filter by predicate name.
Equivalent to /logic in the TUI.

Example:
  nerd logic              # Show all facts
  nerd logic user_intent  # Show only user_intent facts
  nerd logic shard_result # Show shard results`,
	RunE: runLogicQuery,
}

// agentsCmd lists available agents
var agentsCmd = &cobra.Command{
	Use:   "agents",
	Short: "List available shard agents",
	Long: `Shows all registered shard agents with their capabilities.
Includes both ephemeral and persistent specialists.
Equivalent to /agents in the TUI.`,
	RunE: runAgentsList,
}

// toolCmd manages generated tools
var toolCmd = &cobra.Command{
	Use:   "tool <list|run|info|generate> [args]",
	Short: "Manage generated tools (Ouroboros)",
	Long: `Manage tools generated by the Ouroboros Loop.

Subcommands:
  list              - List all generated tools
  run <name> [in]   - Execute a tool with optional input
  info <name>       - Show tool details and source
  generate <desc>   - Generate a new tool from description

Examples:
  nerd tool list
  nerd tool run json-validator '{"test": 123}'
  nerd tool generate "a tool that validates JSON syntax"`,
	Args: cobra.MinimumNArgs(1),
	RunE: runToolCommand,
}

// jitCmd shows JIT compiler status
var jitCmd = &cobra.Command{
	Use:   "jit",
	Short: "Show JIT prompt compiler status",
	Long: `Displays the JIT Prompt Compiler's current state.
Shows loaded atoms, token budget, and compilation stats.
Equivalent to /jit in the TUI.`,
	RunE: runJITStatus,
}

// runDreamState executes dream state consultation
func runDreamState(cmd *cobra.Command, args []string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	scenario := strings.Join(args, " ")

	fmt.Printf("ðŸŒ™ Dream State Consultation\n")
	fmt.Printf("ðŸ“ Scenario: %s\n", scenario)
	fmt.Println(strings.Repeat("â”€", 60))

	// Resolve API key
	key := apiKey
	if key == "" {
		key = os.Getenv("ZAI_API_KEY")
	}

	// Boot Cortex
	cortex, err := coresys.GetOrBootCortex(ctx, workspace, key, nil)
	if err != nil {
		return fmt.Errorf("failed to boot cortex: %w", err)
	}
	defer cortex.Close()

	// Add usage tracker
	if cortex.UsageTracker != nil {
		ctx = usage.NewContext(ctx, cortex.UsageTracker)
	}

	// Get available shards
	shards := cortex.ShardManager.ListAvailableShards()
	fmt.Printf("ðŸ¤– Consulting %d agents...\n\n", len(shards))

	// Consult each shard in dream mode
	dreamCtx := &core.SessionContext{DreamMode: true}

	for i, shard := range shards {
		// Skip internal/system shards
		if shard.Type == core.ShardTypeSystem {
			continue
		}

		fmt.Printf("[%d] %s (%s)...\n", i+1, shard.Name, shard.Type)

		prompt := fmt.Sprintf("Dream Mode Consultation:\n\nScenario: %s\n\nProvide your perspective on this hypothetical. Do NOT execute any actions - only describe what you would do and the implications.", scenario)

		// Dream mode = low priority (background speculation)
		result, err := cortex.ShardManager.SpawnWithPriority(ctx, shard.Name, prompt, dreamCtx, core.PriorityLow)
		if err != nil {
			fmt.Printf("   âŒ Error: %v\n\n", err)
			continue
		}

		fmt.Printf("   âœ“ Response:\n")
		// Indent the response
		for _, line := range strings.Split(truncateResponse(result, 500), "\n") {
			fmt.Printf("     %s\n", line)
		}
		fmt.Println()
	}

	fmt.Println(strings.Repeat("â”€", 60))
	fmt.Println("âœ… Dream state consultation complete")

	return nil
}

// runShadowSimulation runs shadow mode
func runShadowSimulation(cmd *cobra.Command, args []string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
	defer cancel()

	action := strings.Join(args, " ")

	fmt.Printf("ðŸ‘» Shadow Mode Simulation\n")
	fmt.Printf("ðŸŽ¯ Action: %s\n", action)
	fmt.Println(strings.Repeat("â”€", 60))

	// Resolve API key
	key := apiKey
	if key == "" {
		key = os.Getenv("ZAI_API_KEY")
	}

	// Boot Cortex
	cortex, err := coresys.GetOrBootCortex(ctx, workspace, key, nil)
	if err != nil {
		return fmt.Errorf("failed to boot cortex: %w", err)
	}
	defer cortex.Close()

	// Use coder shard in shadow mode
	shadowCtx := &core.SessionContext{DreamMode: true}
	prompt := fmt.Sprintf("SHADOW MODE - Describe what would happen without executing:\n\n%s\n\nList the files that would be affected, changes that would be made, and potential risks. Do NOT actually make any changes.", action)

	// Shadow mode = normal priority (user CLI command but speculative)
	result, err := cortex.ShardManager.SpawnWithPriority(ctx, "coder", prompt, shadowCtx, core.PriorityNormal)
	if err != nil {
		return fmt.Errorf("shadow simulation failed: %w", err)
	}

	fmt.Println("ðŸ“‹ Simulation Result:")
	fmt.Println(result)

	return nil
}

// runWhatIf runs counterfactual analysis
func runWhatIf(cmd *cobra.Command, args []string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
	defer cancel()

	change := strings.Join(args, " ")

	fmt.Printf("ðŸ”® What-If Analysis\n")
	fmt.Printf("â“ Change: %s\n", change)
	fmt.Println(strings.Repeat("â”€", 60))

	// Resolve API key
	key := apiKey
	if key == "" {
		key = os.Getenv("ZAI_API_KEY")
	}

	// Boot Cortex
	cortex, err := coresys.GetOrBootCortex(ctx, workspace, key, nil)
	if err != nil {
		return fmt.Errorf("failed to boot cortex: %w", err)
	}
	defer cortex.Close()

	// Assert the hypothetical to kernel
	hypFact := core.Fact{
		Predicate: "hypothetical",
		Args:      []interface{}{change},
	}
	if err := cortex.Kernel.Assert(hypFact); err != nil {
		logging.KernelWarn("failed to assert hypothetical fact: %v", err)
	}

	// Query implications
	implications, _ := cortex.Kernel.Query("derives_from_hypothetical")

	fmt.Println("ðŸ“Š Kernel Implications:")
	if len(implications) > 0 {
		for _, imp := range implications {
			fmt.Printf("   - %s\n", imp.String())
		}
	} else {
		fmt.Println("   (no derived implications)")
	}
	fmt.Println()

	// Use researcher for deeper analysis
	prompt := fmt.Sprintf("Analyze the implications of this hypothetical change:\n\n%s\n\nConsider:\n1. What systems would be affected?\n2. What would break?\n3. What would improve?\n4. What risks exist?", change)

	result, err := cortex.ShardManager.Spawn(ctx, "researcher", prompt)
	if err != nil {
		fmt.Printf("Analysis failed: %v\n", err)
	} else {
		fmt.Println("ðŸ“‹ Analysis:")
		fmt.Println(result)
	}

	return nil
}

// runLogicQuery shows kernel facts
func runLogicQuery(cmd *cobra.Command, args []string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	predicate := "*"
	if len(args) > 0 {
		predicate = args[0]
	}

	fmt.Printf("ðŸ§  Mangle Kernel Facts\n")
	fmt.Printf("ðŸ” Query: %s\n", predicate)
	fmt.Println(strings.Repeat("â”€", 60))

	// Resolve API key
	key := apiKey
	if key == "" {
		key = os.Getenv("ZAI_API_KEY")
	}

	// Boot Cortex
	cortex, err := coresys.GetOrBootCortex(ctx, workspace, key, nil)
	if err != nil {
		return fmt.Errorf("failed to boot cortex: %w", err)
	}
	defer cortex.Close()

	// Query facts
	facts, err := cortex.Kernel.Query(predicate)
	if err != nil {
		return fmt.Errorf("query failed: %w", err)
	}

	fmt.Printf("ðŸ“Š Found %d facts:\n\n", len(facts))
	for i, fact := range facts {
		if i >= 50 {
			fmt.Printf("... and %d more\n", len(facts)-50)
			break
		}
		fmt.Printf("  %s\n", fact.String())
	}

	return nil
}

// runAgentsList lists available agents
func runAgentsList(cmd *cobra.Command, args []string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	fmt.Printf("ðŸ¤– Available Shard Agents\n")
	fmt.Println(strings.Repeat("â”€", 60))

	// Resolve API key
	key := apiKey
	if key == "" {
		key = os.Getenv("ZAI_API_KEY")
	}

	// Boot Cortex
	cortex, err := coresys.GetOrBootCortex(ctx, workspace, key, nil)
	if err != nil {
		return fmt.Errorf("failed to boot cortex: %w", err)
	}
	defer cortex.Close()

	// List shards
	shards := cortex.ShardManager.ListAvailableShards()

	// Group by type
	typeGroups := make(map[core.ShardType][]core.ShardInfo)
	for _, shard := range shards {
		typeGroups[shard.Type] = append(typeGroups[shard.Type], shard)
	}

	typeNames := map[core.ShardType]string{
		core.ShardTypeEphemeral:  "Ephemeral (Type A)",
		core.ShardTypePersistent: "Persistent (Type B)",
		core.ShardTypeUser:       "User-Defined (Type U)",
		core.ShardTypeSystem:     "System (Type S)",
	}

	for shardType, shards := range typeGroups {
		fmt.Printf("\n### %s\n", typeNames[shardType])
		for _, shard := range shards {
			knowledgeStr := ""
			if shard.HasKnowledge {
				knowledgeStr = " [+knowledge]"
			}
			fmt.Printf("  - %s%s\n", shard.Name, knowledgeStr)
		}
	}

	fmt.Printf("\nTotal: %d agents\n", len(shards))
	return nil
}

// runToolCommand handles tool management
func runToolCommand(cmd *cobra.Command, args []string) error {
	if len(args) == 0 {
		fmt.Println("Usage: nerd tool <list|run|info|generate> [args]")
		return nil
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	// Resolve API key
	key := apiKey
	if key == "" {
		key = os.Getenv("ZAI_API_KEY")
	}

	// Boot Cortex
	cortex, err := coresys.GetOrBootCortex(ctx, workspace, key, nil)
	if err != nil {
		return fmt.Errorf("failed to boot cortex: %w", err)
	}
	defer cortex.Close()

	subCmd := args[0]
	switch subCmd {
	case "list":
		fmt.Println("ðŸ”§ Generated Tools (Ouroboros)")
		fmt.Println(strings.Repeat("â”€", 60))

		// Query tool facts
		tools, _ := cortex.Kernel.Query("tool_registered")
		if len(tools) == 0 {
			fmt.Println("No tools generated yet.")
			fmt.Println("\nUse 'nerd tool generate <description>' to create one.")
		} else {
			for _, tool := range tools {
				fmt.Printf("  - %s\n", tool.Args[0])
			}
		}

	case "run":
		if len(args) < 2 {
			return fmt.Errorf("usage: nerd tool run <name> [input]")
		}
		toolName := args[1]
		toolInput := ""
		if len(args) > 2 {
			toolInput = strings.Join(args[2:], " ")
		}

		fmt.Printf("ðŸ”§ Running tool: %s\n", toolName)
		fmt.Println(strings.Repeat("â”€", 60))

		// Find tool binary path from kernel facts
		var binaryPath string
		allBinaries, _ := cortex.Kernel.Query("tool_binary_path")
		for _, b := range allBinaries {
			if len(b.Args) >= 2 && fmt.Sprintf("%v", b.Args[0]) == toolName {
				binaryPath = fmt.Sprintf("%v", b.Args[1])
				break
			}
		}

		if binaryPath == "" {
			return fmt.Errorf("tool '%s' not found. Run 'nerd tool list' to see available tools", toolName)
		}

		// Execute tool binary directly
		toolCmd := exec.CommandContext(ctx, binaryPath)
		if toolInput != "" {
			toolCmd.Stdin = strings.NewReader(toolInput)
		}
		toolCmd.Stdout = os.Stdout
		toolCmd.Stderr = os.Stderr

		if err := toolCmd.Run(); err != nil {
			return fmt.Errorf("tool execution failed: %w", err)
		}

	case "info":
		if len(args) < 2 {
			return fmt.Errorf("usage: nerd tool info <name>")
		}
		toolName := args[1]

		fmt.Printf("ðŸ”§ Tool Info: %s\n", toolName)
		fmt.Println(strings.Repeat("â”€", 60))

		// Query tool details (filter results in Go since kernel.Query returns all facts)
		allDetails, _ := cortex.Kernel.Query("tool_description")
		for _, d := range allDetails {
			if len(d.Args) >= 2 && fmt.Sprintf("%v", d.Args[0]) == toolName {
				fmt.Printf("Description: %v\n", d.Args[1])
				break
			}
		}

		allBinaries, _ := cortex.Kernel.Query("tool_binary_path")
		for _, b := range allBinaries {
			if len(b.Args) >= 2 && fmt.Sprintf("%v", b.Args[0]) == toolName {
				fmt.Printf("Binary: %v\n", b.Args[1])
				break
			}
		}

	case "generate":
		if len(args) < 2 {
			return fmt.Errorf("usage: nerd tool generate <description>")
		}
		description := strings.Join(args[1:], " ")

		fmt.Printf("ðŸ”§ Generating Tool\n")
		fmt.Printf("ðŸ“ Description: %s\n", description)
		fmt.Println(strings.Repeat("â”€", 60))

		// Use tool_generator shard
		result, err := cortex.ShardManager.Spawn(ctx, "tool_generator", description)
		if err != nil {
			return fmt.Errorf("tool generation failed: %w", err)
		}
		fmt.Println(result)

	default:
		return fmt.Errorf("unknown subcommand: %s (use list, run, info, or generate)", subCmd)
	}

	return nil
}

// runJITStatus shows JIT compiler status
func runJITStatus(cmd *cobra.Command, args []string) error {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	fmt.Printf("âš¡ JIT Prompt Compiler Status\n")
	fmt.Println(strings.Repeat("â”€", 60))

	// Resolve API key
	key := apiKey
	if key == "" {
		key = os.Getenv("ZAI_API_KEY")
	}

	// Boot Cortex
	cortex, err := coresys.GetOrBootCortex(ctx, workspace, key, nil)
	if err != nil {
		return fmt.Errorf("failed to boot cortex: %w", err)
	}
	defer cortex.Close()

	// Get compiler stats
	if cortex.JITCompiler != nil {
		stats := cortex.JITCompiler.GetStats()
		fmt.Printf("Embedded Atoms:   %d\n", stats.EmbeddedAtomCount)
		fmt.Printf("Project Atoms:    %d\n", stats.ProjectAtomCount)
		fmt.Printf("Shard DBs:        %d\n", stats.ShardDBCount)
		fmt.Printf("Compilations:     %d\n", stats.TotalCompilations)
		fmt.Printf("Avg Time (ms):    %.2f\n", stats.AverageTimeMs)
	} else {
		fmt.Println("JIT Compiler not initialized")
	}

	// Show loaded prompt atoms
	atoms, _ := cortex.Kernel.Query("prompt_atom")
	fmt.Printf("\nLoaded Prompt Atoms: %d\n", len(atoms))
	if len(atoms) > 0 && len(atoms) <= 10 {
		for _, atom := range atoms {
			fmt.Printf("  - %v\n", atom.Args[0])
		}
	}

	return nil
}
